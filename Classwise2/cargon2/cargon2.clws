imports cargon2

> void setup(%Pass result){
  }
> void generate(%Pass result){
  }
class com.rem.gen.parser.Parser < '"com.rem.output.helpers.OutputHelper.Parser<Parser.Result,Parser.Result.Pass>"' {
> @%New Object rootContender;
  
  %Result parse(String fileName) {
    try {
      File file = new File(fileName);
      if !file.exists() {
        return null;
      }
      BufferedReader reader = new BufferedReader(new FileReader(file));
	  CharBuffer chars = CharBuffer.allocate((int) file.length()+1);
	  reader.read(chars);
	  chars.position(0);
      %Result result = parse(chars);
      reader.close();
      return result.setFileName(fileName);
    }
    print catch IO {}
    return null;
  }
  %Result parse(CharBuffer chars){
    Contension contension = `rootContender`.contend(chars);
    ErrorList errors = contension.errors();
    if errors.isEmpty() {
      Token rootToken = new Token(Token.Id.ROOT,null);
      contension.tokenize(rootToken);
      return new Parser.Result.Pass(rootToken);
    }
    else {
      return new Parser.Result.Fail(errors);
    }
  }
  
  class Result < '"com.rem.output.helpers.OutputHelper.Parser.Result"' {
    String fileName;
    Result setFileName(String newFileName){
      fileName = newFileName;
      return this;
    }
    '"com.rem.output.helpers.OutputHelper.Parser.State"' getState(){
      return null;
    }
    class Pass Result {
      '"com.rem.output.helpers.OutputHelper.Parser.State"' getState(){
        return '"com.rem.output.helpers.OutputHelper.Parser.State.SUCCESS"';
      }
    }
    class Fail Result {
      '"com.rem.output.helpers.OutputHelper.Parser.State"' getState(){
        return '"com.rem.output.helpers.OutputHelper.Parser.State.FAIL"';
      }
    }
  }
}
interface com.rem.gen.parser.Contender {
  Contension contend(CharBuffer chars,Map<Integer, Braces.BraceData> braceData)?
  
  class One < Contender {
    Contender contender;
    Token.Id id;
    One(Token.Id id, Contender contender){
      this.contender = contender;
      this.id = id;
    }
    Contension contend(CharBuffer chars,Map<Integer, Braces.BraceData> braceData){
      int position = chars.position();
      Contension result = contender.contend(chars,braceData);
      if result.errors().isEmpty() {
        if id == null{
          return result;
        }
        else {
          return new Contension.One(id,result);
        }
      }
      else {
        chars.position(position);
        return result;
      }
    }
  }
  class Optional < Contender {
    Contender contender;
    Token.Id id;
    Optional(Token.Id id,Contender contender){
      this.contender = contender;
      this.id = id;
    }
    Contension contend(CharBuffer chars,Map<Integer, Braces.BraceData> braceData){
      int position = chars.position();
      Contension result = contender.contend(chars,braceData);
      if result.errors().isEmpty() {
        if id == null {
          return result;
        }
        else {
          return new Contension.One(id,result);
        }
      }
      else {
        chars.position(position);
        return new Contension.Empty(id);
      }
    }
  }
  class Many < Contender {
    Contender contender;
    Token.Id id;
    Many(Token.Id id,Contender contender){
      this.contender = contender;
      this.id = id;
    }
    Contension contend(CharBuffer chars,Map<Integer, Braces.BraceData> braceData){
      int position = chars.position();
      List<Contension> results = new ArrayList<Contension>();
      Contension result = contender.contend(chars,braceData);
      while result.errors().isEmpty() {
        results.add(result);
        position = chars.position();
        result = contender.contend(chars,braceData);
      }
      chars.position(position);
      if results.isEmpty() {
        return new Contension.Empty(id);
      }
      else {
        if results.size() == 1 {
          if id == null {
            return results.get(0);
          }
          else {
            return new Contension.One(id,results.get(0));
          }
        }
        else {
          return new Contension.Many(id,results);
        }
      }
    }
  }
  class More < Contender {
    Contender contender;
    Token.Id id;
    More(Token.Id id,Contender contender){
      this.contender = contender;
      this.id = id;
    }
    Contension contend(CharBuffer chars,Map<Integer, Braces.BraceData> braceData){
      int position = chars.position();
      List<Contension> results = new ArrayList<Contension>();
      Contension result = contender.contend(chars,braceData);
      while result.errors().isEmpty() {
        results.add(result);
        position = chars.position();
        result = contender.contend(chars, braceData);
      }
      chars.position(position);
      if results.isEmpty() {
        return result;
      }
      else {
        if results.size() == 1 {
          if id == null {
            return results.get(0);
          }
          else {
            return new Contension.One(id,results.get(0));
          }
        }
        else {
          return new Contension.Many(id,results);
        }
      }
    }
  }
  class Branch < Contender {
    List<Contender> contenders;
    Branch(Contender... contenders){
      this.contenders = Arrays.asList(contenders);
    }
    Contension contend(CharBuffer chars,Map<Integer, Braces.BraceData> braceData){
      HasErrors errors = new HasErrors(); 
      return contenders.parallelStream().map(
          C=>new ErrorPlot(C.contend(chars.duplicate(),braceData),errors)).filter(E=>errors.has()?true:E.getContension().errors().isEmpty()).sorted().map(E=>E.getContension()).findFirst().orElse(null);
    }
    class HasErrors {
      boolean hasErrors = true;
      void foundFreeOfErrors(){
        hasErrors = false;
      }
      boolean has(){
        return hasErrors;
      }
    }
    class ErrorPlot < Comparable<ErrorPlot> {
      int furthest;
      Contension contension;
      ErrorPlot(Contension contension,HasErrors errors){
        this.contension = contension;
        if contension.errors().isEmpty() {
          errors.foundFreeOfErrors();
        }
      }
      int compareTo(ErrorPlot plot){
        return plot.furthest - furthest;
      }
    }
  }
  class Chain < Contender {
    List<Contender> contenders;
    Chain(Contender... contenders){
      this.contenders = Arrays.asList(contenders);
    }
    Contension contend(CharBuffer chars,Map<Integer, Braces.BraceData> braceData){
      List<Contension> results = new ArrayList<Contension>(contenders.size());
      for Contender contender: contenders {
        Contension result = contender.contend(chars,braceData);
        if result.errors().isEmpty() {
          results.add(result);
        }
        else {
          return result;
        }
      }
      return new Contension.Many(null,results);
    }
  }
  class Braces {
    interface Brace {
      boolean open(int c1, int c2)?
      boolean close(int c1, int c2)?
      boolean ignore(int c)?
      boolean isLock()?
      int advanceOpen()?
      int advanceClose()?
    }
    class B11 < Brace {
      char ignore = char\\;
      char open;
      char close;
      boolean isLock = false;
      B11(char o, char c, char i, boolean isLock){
        open = o;
        close = c;
        ignore = i;
        this.isLock = isLock;
      }
      boolean open(int c1, int c2) { return c1==open;  }
      boolean close(int c1, int c2){ return c1==close; }
      boolean ignore(int c){         return c==ignore; }
      boolean isLock(){              return isLock;    }
      int advanceOpen(){             return 1;         }
      int advanceClose(){            return 1;         }
    }
    class B12 < Brace {
      char ignore = char\\;
      char open;
      char close1;
      char close2;
      boolean isLock = false;
      B12(char o, char c1, char c2, char i, boolean isLock){
        open = o;
        close1 = c1;
        close2 = c2;
        ignore = i;
        this.isLock = isLock;
      }
      boolean open(int c1, int c2) { return c1==open;  }
      boolean close(int c1, int c2){ return c1==close1&&c2==close2; }
      boolean ignore(int c){         return c==ignore; }
      boolean isLock(){              return isLock;    }
      int advanceOpen(){             return 1;         }
      int advanceClose(){            return 2;         }
    }
    class B21 < Brace {
      char ignore = char\\;
      char open1;
      char open2;
      char close;
      boolean isLock = false;
      B21(char o1, char o2, char c, char i, boolean isLock){
        open1 = o1;
        open2 = o2;
        close = c;
        ignore = i;
        this.isLock = isLock;
      }
      boolean open(int c1, int c2) { return c1==open1&&c2==open2;  }
      boolean close(int c1, int c2){ return c1==close; }
      boolean ignore(int c){         return c==ignore; }
      boolean isLock(){              return isLock;    }
      int advanceOpen(){             return 2;         }
      int advanceClose(){            return 1;         }
    }
    class B22 < Brace {
      char ignore = char\\;
      char open1;
      char open2;
      char close1;
      char close2;
      boolean isLock = false;
      B22(char o1, char o2, char c1, char c2, char i, boolean isLock){
        open1 = o1;
        open2 = o2;
        close1 = c1;
        close2 = c2;
        ignore = i;
        this.isLock = isLock;
      }
      boolean open(int c1, int c2) { return c1==open1&&c2==open2;  }
      boolean close(int c1, int c2){ return c1==close1&&c2==close2; }
      boolean ignore(int c){         return c==ignore; }
      boolean isLock(){              return isLock;    }
      int advanceOpen(){             return 2;         }
      int advanceClose(){            return 2;         }
    }
    class BraceContender < Contender {
      Brace brace;
      Contender contender;
      BraceContender(Brace brace, Contender contender){
        this.brace = brace;
        this.contender = contender;
      }
      Contension contend(CharBuffer chars, Map<Integer,BraceData> braceData){
        BraceData data = braceData.get(chars.position());
        if data != null {
          CharBuffer buffer = chars.duplicate();
          buffer.position(buffer.position()+data.getBrace().advanceOpen());
          buffer.limit(data.getClose());
          Contension contension = contender.contend(buffer,braceData);
          if contension.errors().isEmpty() {
            if data.getClose() == buffer.position() {
              chars.position(data.getClose()+data.getBrace().advanceClose());
              return contension;
            }
            else {
              chars.position(data.getClose()+data.getBrace().advanceClose());
              return new Contension.Unsuccessful(null,buffer.position());
            }
          }
          else {
            chars.position(data.getClose()+data.getBrace().advanceClose());
            return contension;
          }
        }
        else {
          return new Contension.Unsuccessful(null,chars.position());
        }
      }
    }
    > %A braces_2_2 = %A;
    > %A braces_2_1 = %A;
    > %A braces_1_2 = %A;
    > %A braces_1_1 = %A;
    > %A allBraces = %A.add(braces_2_2).add(braces_2_1).add(braces_1_2).add(braces_1_1);
    > Set<String> allBraceSet = new HashSet<String>();
    > void setup(){
    }
    > void addBrace(boolean lock, String open, String close, String ignore){
      if allBraceSet.add(open+''" "''+close) {
        if open.length() == 1 {
          if close.length() == 1 {
            braces_1_1.add(|new Contender.Brace.B11(`%E(open.charAt(0))`,`%E(close.charAt(0))`,`%E(ignore.charAt(0))`,`%E(lock)`)|);
          }
          else {
            braces_1_2.add(|new Contender.Brace.B12(`%E(open.charAt(0))`,`%E(close.charAt(0))`,`%E(close.charAt(1))`,`%E(ignore.charAt(0))`,`%E(lock)`)|);
          }
        }
        else {
          if close.length() == 1 {
            braces_2_1.add(|new Contender.Brace.B21(`%E(open.charAt(0))`,`%E(open.charAt(1))`,`%E(close.charAt(0))`,`%E(ignore.charAt(0))`,`%E(lock)`)|);
          }
          else {
            braces_2_2.add(|new Contender.Brace.B22(`%E(open.charAt(0))`,`%E(open.charAt(1))`,`%E(close.charAt(0))`,`%E(close.charAt(1))`,`%E(ignore.charAt(0))`,`%E(lock)`)|);
          } 
        }
      }
    }
    @List<Brace> braces = Arrays.asList(`allBraces`);
    @Map<Integer,BraceData> find(CharBuffer chars){
      Stack<BraceData> data = new Stack<BraceData>();
      Map<Integer, BraceData> positions = new HashMap<Integer,BraceData>();
      OfInt itr = chars.duplicate().chars().iterator();
      if !itr.hasNext() {
        return positions;
      }
      boolean locked = false;
      int position = 0;
      int c1;
      int c2;
      int c3 = itr.next();
      if !itr.hasNext() {
        return positions;
      }
      c2 = c3;
      c3 = itr.next();
      int cf1 = c2;
      int cf2 = c3;
      Brace open = braces.stream().filter(B=>B.open(cf1,cf2)).findAny().orElse(null);
      if open != null {
        data.push(new BraceData(position,open));
        locked = open.isLock();
      }
      while itr.hasNext() {
        c1 = c2;
        c2 = c3;
        c3 = itr.next();
        if !data.isEmpty() {
          if !data.peek().getBrace().ignore(c1)&&data.peek().getBrace().close(c2,c3) {
            locked = false;
            positions.put(position,data.pop().close(position));
            ++position;
            continue;
          }
        }
        if !locked {
          int cf3 = c1;
          int cf4 = c2;
          int cf5 = c3;
          open = braces.stream().filter(B=>!B.ignore(cf3)&&B.open(cf4,cf5)).findAny().orElse(null);
          if open != null {
            data.push(new BraceData(position,open));
            locked = open.isLock();
          }
        }
        ++position;
      }
      return positions;
    }
    class BraceData {
      Integer open;
      Integer close;
      Brace brace;
      
      BraceData(Integer start, Brace brace){
        this.open = start;
        this.brace = brace;
      }
      BraceData close(Integer close){
        this.close = close;
        return this;
      }
    }
  }
  class Any < Contender {
    String value;
    Any(String value){
      this.value = value;
    }
    Contension contend(CharBuffer chars,Map<Integer,Braces.BraceData> braceData){
      if chars.remaining() == 0 {
        return new Contension.Unsuccessful(null,chars.position());
      }
      else {
        char c = chars.get();
        if value.chars().anyMatch(C=>C==c) {
          chars.position(chars.position()+1);
          return new Contension.Concrete(null,'' "" ''+c);
        }
        else {
          return new Contension.Unsuccessful(null,chars.position());
        }
      }
    }
    class Not < Contender {
      String value;
      Not(String value){
        this.value = value;
      }
      Contension contend(CharBuffer chars,Map<Integer,Braces.BraceData> braceData){
        if chars.remaining() == 0 {
          return new Contension.Unsuccessful(null,chars.position());
        }
        else {
          char c = chars.get();
          if !value.chars().anyMatch(C=>C==c) {
            chars.position(chars.position()+1);
            return new Contension.Concrete(null,'' "" ''+c);
          }
          else {
            return new Contension.Unsuccessful(null,chars.position());
          }
        }
      }
    }
  }
  class Terminal < Contender {
    String value;
    Terminal(String value){
      this.value = value;
    }
    Contension contend(CharBuffer chars,Map<Integer,Braces.BraceData> braceData){
      if value.length() > chars.remaining() {
        return new Contension.Unsuccessful(null,chars.position());
      }
      else {
        CharBuffer buffer = chars.duplicate();
        buffer.limit(buffer.position()+value.length());
        OfInt values = value.chars().iterator();
        if buffer.chars().allMatch(C=>C==values.next()) {
          chars.position(chars.position()+value.length());
          return new Contension.Concrete(null,value);
        }
        else {
          return new Contension.Unsuccessful(null,chars.position());
        }
      }
    }
  }
}
class com.rem.gen.parser.Contension? <T> {
  Token.Id id;
  T value;
  
  Contension(Token.Id id, T value){
    this.id = id;
    this.value = value;
  }
  
  T getValue(){ return value ; }
  boolean noErrors(){ return errors().isEmpty(); }
  
  ErrorList errors()?
  void tokenize(Consumer<Token> token)?

  class Unsuccessful Contension<Integer> {
    Unsuccessful(Token.Id id, Integer position){
      super(id,position);
    }
    ErrorList errors(){
      return new ErrorList(new ParseError(this.id,this.value));
    }
    void tokenize(Consumer<Token> token){
    }
  }
  class Empty Contension<Void> {
    Empty(Token.Id id){
      super(id,null);
    }
    ErrorList errors(){
      return new ErrorList();
    }
    void tokenize(Consumer<Token> token){
    }
  }
  class Concrete Contension<String> {
    
    Concrete (Token.Id id, String value){
      super(id,value);
    }
    ErrorList errors(){
      return new ErrorList();
    }
    void tokenize(Consumer<Token> tokens){
      tokens.accept(new Token(this.id,this.value));
    }
  }
  class One Contension<Contension> {
    One (Token.Id id, Contension value){
      super(id,value);
    }
    ErrorList errors(){
      return this.value.errors();
    }
    void tokenize(Consumer<Token> token){
      if this.id == null {
        this.value.tokenize(token);
      }
      else {
        Token subToken = new Token(this.id,null);
        token.accept(subToken);
        this.value.tokenize(subToken);
      }
    }
  }
  class Many Contension<List<Contension>> {
    Many (Token.Id id, List<Contension> value){
      super(id,value);
    }
    ErrorList errors(){
      ErrorList result = new ErrorList();
      this.value.stream().map(C=>C.errors()).forEach(E=>result.addAll(E));
      return result;
    }
    void tokenize(Consumer<Token> token){
      if this.id == null {
        this.value.stream().forEach(C=>C.tokenize(token));
      }
      else {
        Token subToken = new Token(this.id,null);
        token.accept(subToken);
        this.value.stream().forEach(C=>C.tokenize(subToken));
      }
    }
  }
  class Regex Contension<List<Contension.Concrete>> < Consumer<Token> {
    StringBuilder builder;
    Regex (Token.Id id, List<Contension.Concrete> value){
      super(id,value);
    }
    ErrorList errors(){
      ErrorList result = new ErrorList();
      this.value.stream().map(C=>C.errors()).forEach(E=>result.addAll(E));
      return result;
    }
    void tokenize(Consumer<Token> token){
      builder = new StringBuilder();
      this.value.stream().forEach(C=>C.tokenize(Contension.Regex.this));
      if this.id == null {
        token.accept(new Token(Token.Id._SYNTAX,builder.toString()));
      }
      else {
        token.accept(new Token(this.id,builder.toString()));
      }
    }
    void accept(Token token){
      if token.getValue() == null {
        token.build(this);
      }
      else {
        builder.append(token.getValue());
      }
    }
  }
}

class com.rem.gen.parser.Token < Consumer<Token> {
  enum Id {
    void ROOT;
    void _SYNTAX;
  }
  List<Token> children;
  Map<Id, List<Token>> map;
  String value;
  Id id;
  Token(Id id, String value){
    this.id = id;
    if value != null {
      this.value = value;
    }
    else {
     this.children = new ArrayList<Token>();
     this.map = new EnumMap<Id, List<Token>>(Id.class);
    }
  }
  void accept(Token newToken){
    this.children.add(newToken);
    if this.map.containsKey(newToken.id) == false {
      this.map.put(newToken.id,new ArrayList<Token>());
    }
    this.map.get(newToken.id).add(newToken);
  }
  void build(Consumer<Token> builder){
    if children != null {
      children.forEach(builder);
    }
    else {
      builder.accept(this);
    }
  }
  Token get(Id id){
    List<Token> result = map.get(id);
    if result != null && result.isEmpty() == false {
      return result.get(0);
    }
    else {
      return null;
    }
  }
  List<Token> getAll(){
    return children;
  }
  List<Token> getAllSafely(Id id){
    List<Token> result = map.get(id);
    if result != null {
      return result;
    }
    else {
      return new ArrayList<Token>();
    }
  }
}

class com.rem.gen.parser.ErrorList {
  List<ParseError> list;
  int furthest = 0;
  ErrorList(){
    list = new ArrayList<ParseError>();
  }
  ErrorList(ParseError error){
    list = Arrays.asList(error);
  }
  void add(ParseError newError){
    list.add(newError);
    if newError.getPosition() > furthest {
      furthest = newError.getPosition();
    }
  }
  void addAll(ErrorList errors){
    if errors.furthest > furthest {
      furthest = errors.furthest;
    }
    list.addAll(errors.list);
  }
  boolean isEmpty(){
   return list.isEmpty();
 }
}
class com.rem.gen.parser.ParseError {
  Token.Id id;
  Integer position;
  ParseError(Token.Id id, Integer position){
    this.id = id;
    this.position = position;
  }
}