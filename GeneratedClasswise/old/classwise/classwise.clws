< Parser : \com.\rem.\gen.\parser;
< Token  : \com.\rem.\gen.\parser;
> class Result //{}

<IParser : \com.\rem.\parser.\parser;
<RegexParser : \com.\rem.\parser.\parser;
<IToken : \com.\rem.\parser.\token;
< Generator : \com.\rem.\parser.\generation;
< GeneralFlowController : \com.\rem.\parser.\generation;
< FlowController : \com.\rem.\parser.\generation;
< ExternalFlow : \com.\rem.\parser.\generation.`classwise`;
< ExternalClassHelper : \com.\rem.\parser.\generation.`classwise`;
< ExternalClassEntry : \com.\rem.\parser.\generation.`classwise`;
< ExternalMethodEntry : \com.\rem.\parser.\generation.`classwise`;
< ExternalVariableEntry : \com.\rem.\parser.\generation.`classwise`;
< ExternalContext : \com.\rem.\parser.\generation.`classwise`;
< ExternalImportEntry : \com.\rem.\parser.\generation.`classwise`;

< TabEntry : \com.\rem.\parser.\generation;
< StringEntry : \com.\rem.\parser.\generation;
< VariableNameEntry : \com.\rem.\parser.\generation;
< QuoteEntry : \com.\rem.\parser.\generation;
< Entry : \com.\rem.\parser.\generation;
< ParseContext : \com.\rem.\parser; 

< File : \java.\io;
< List : \java.\util;
< ArrayList : \java.\util;
< Set  : \java.\util;
< HashSet : \java.\util;
< Map  : \java.\util;
< HashMap : \java.\util;
< StringBuilder : \java.\lang;

> String packageName = "com.rem.crg.generator";

> String outerPackageName = "com.rem.cls";
> String innerPackageName = "com.rem.gen";
> Map<String, Class > innerClasses = new HashMap<String, Class >();
> Map<String, Class > outerClasses = new HashMap<String, Class > ();
> List< Class > outerClassList = new ArrayList< Class >();
> Body addClassFileList = new Body ();
> Body setupClassList = new Body ();

> Classwise classwise = new Classwise();
> class 'packageName' Classwise {

> ~File innerDirectory = null;
> ~File outerDirectory = null;
> ~Class mainClass = null;
> Parser pulsar = null;

> ~String sourceDirectory = null;
> void setup(Parser.Result result){
    ~String fileName = result.getFileName();
	Integer indexOfDot = fileName.lastIndexOf(".");
	if indexOfDot > -1 {
	  fileName = fileName.substring(0,indexOfDot);
	}
	~int indexOfSlash = fileName.lastIndexOf("/");
	if indexOfSlash > -1 {
	  fileName = fileName.substring(indexOfSlash\+1);
	}
	indexOfSlash = fileName.lastIndexOf("\\");
	if indexOfSlash > -1 {
	  fileName = fileName.substring(indexOfSlash\+1);
	}
	fileName = ^fileName;
	innerDirectory = new File("../"\+fileName\+"/src");
	innerDirectory.mkdirs();
	outerDirectory = new File("../"\+fileName\+"/src",innerPackageName.replace(".","/"));
	outerDirectory.mkdirs();
	sourceDirectory = "../"\+fileName\+"/src/";
  }
> void importAllClasses(Token input) {
    for Token element: input.getAllSafely("anonymous_classes") {
      StringBuilder anonymousPackageName = new StringBuilder();
      Statement classPackageName = new Statement(".");
      for Token packageElement: element.getAllSafely("packageName") {
	    if packageElement->"NAME" != null {
  	      classPackageName.add(|'packageElement->"NAME"'|);
	    }
	    else if packageElement->"quote" != null {
	      classPackageName.add(|'packageElement->"quote"'|);
	    }
	    else if packageElement->"statement_as_string" != null {
	      classPackageName.add(body.statement(packageElement->"statement_as_string"->"body_statement",true,new Context (false)));
	    }
	  }
	  classPackageName.get(anonymousPackageName);
	  for Token anonymousClass : element.getAllSafely("anonymous_class") {
	    \defineAnonymousClass(anonymousClass, true, 'anonymousPackageName', "");
	  }
    }
  }
> void defineAnonymousClass(Token anonymousClass, Boolean isFirst, String anonymousPackageName, String parentClass) {
    StringBuilder currentClass = new StringBuilder();
    currentClass.append(parentClass);
    for Token className : anonymousClass.getAllSafely("className") {
      if isFirst == false { currentClass.append("."); }
	  currentClass.append(className);
	  String currentClassValue = 'currentClass';
	  setupClassList.add(|\ExternalClassEntry.suppliment('' 'currentClassValue' '', '' 'anonymousPackageName' '');|);
	  ExternalClassEntry.suppliment('currentClassValue','anonymousPackageName');
	}
	
	for Token subAnonymousClass : anonymousClass.getAllSafely("anonymous_class") {
	  \defineAnonymousClass(subAnonymousClass, false, anonymousPackageName, 'currentClass');
	}
  }
> void findAllClasses(Token input){
    for Token element: input.getAllSafely("import_imports") {
      \importAllClasses(element);
    }
    for Token element: input.getAllSafely("import_clws") {
      \findAllClasses(element);
    }
    
    for Token element: input.getAllSafely("class_declaration") {
      classGenerator.collectClassNames(element);
    }
  }
> void generateGlobals(Token input){
    for Token element: input.getAllSafely("import_clws") {
      \generateGlobals(element);
    }
    for Token element: input.getAllSafely("variable_declaration") {
	  Variable newVariable = variable.declaration(element,true,mainClass.getContext());
	  mainClass.addVariable(newVariable);
	  variable.addDefinedVariableName(newVariable);
	}
    for Token element: input.getAllSafely("method_declaration") {
	  Method newMethod = method.declaration(element,true,mainClass.getContext());
	  mainClass.addMethod(newMethod);
	  method.addDefinedMethodName(newMethod);
	}
  }
> void generateAll(Token input){
    for Token element: input.getAllSafely("import_clws") {
      \generateAll(element);
    }
    String packageFileName = packageName.replace(".",File.separator);
    
    for Token element: input.getAllSafely("class_declaration") {
      classGenerator.collectClassNames(element);
    }
    for Token element: input.getAllSafely("class_declaration") {
	  Class innerClass = new Class ();
	  Class outerClass = new Class ();
	  classGenerator.declaration(element,innerClass,outerClass,false,null);
      String className = ^element->"className";
	  if element->"inner" == null {
	    innerClass.setIsStatic(false);
	    outerClass.setIsStatic(false);
	    innerClass.addVariable(@'outerClass.getName()' "_" = "new "+'outerClass.getName()'+"()";);
	    innerClass.addInitMethodFromClass(outerClass);
	    innerClass.setParentClass(new ExternalStatement.TypeName("ExternalClassEntry"));
		outerClasses.put(outerClass.getFullName(),outerClass);
		innerClass.removeInterfaces();
		innerClass.removeConstructors();
		setupClassList.add(|'className'."_".__INIT__();
		  ExternalFlow.outputClasses.add('className'."_");|);
      }
	  innerClasses.put(innerClass.getFullName(),innerClass);
	  innerClass.setPackageName(innerPackageName);
      innerClass.outputToFile(\MainFlow.methods,innerDirectory);
    }
	
  }
> void generate(Parser.Result result){
    String mainPackageName = sourceDirectory;
    String mainFlow = "MainFlow";
    String parserTypePath = "com.rem.gen.parser.Parser";
    String resultTypePath = "com.rem.gen.parser.Parser.Result";
    String passTypePath = "com.rem.gen.parser.Parser.Result.Pass";
	class 'innerPackageName' mainFlow Object ExternalFlow->Generator {
	    @'mainFlow' self = new 'mainFlow'();
	    @void main(String[] args){
	      ExternalFlow.parse(args,new 'parserTypePath'(),self);
	    }
	    void onSuccessfulParse(ExternalFlow->Parser->Result result){
	      ExternalClassHelper.setup();
	      `setupClassList`;
	      
		  self.classwise.setup(('passTypePath')result);
		  self.classwise.generate(('passTypePath'.Pass)result);
	    }
	  }
	\mainClass = \mainFlowClass; 
	\mainClass.removeConstructors();
    \findAllClasses(((Parser\.\Result\.\Pass)result).\getRoot());
    \generateGlobals(((Parser\.\Result\.\Pass)result).\getRoot());
	\generateAll(((Parser\.\Result\.\Pass)result).\getRoot());
	\mainClass.outputToFile(\MainFlow.methods,innerDirectory);
  }
> void name_var(Token input, NameVar nameVar, boolean isInner, Context context){
    if isInner {
      nameVar.inner();
    }
    else {
      nameVar.outer();
    }
    if input->"tokenAccess" != null {
      \tokenAccess(input->"tokenAccess",nameVar,isInner,context);
    }
    else {
      ~NameVar right = null;
      for Token atom: input.getAllSafely("cast_statement") {
        Type castType = new Type();
        classwise.type_var(atom->"type_var",castType,isInner,context);
        castType.plain();
        nameVar.addCastStatement(castType.getAsStatement());
      }
      for Token atom: input.getAllSafely("name_atom") {
	    if right == null {
	      \name_atom(atom,nameVar,isInner,context);
	      right = new NameVar();
	    }
		else {
		  right = new NameVar();
		  \name_atom(atom,right,isInner,context);
		  nameVar.concatenateWith(right);
		}
      }
    }
  }
> void tokenAccess(Token element, NameVar nameVar, boolean isInner, Context context){
     nameVar.tokenAccess();
     \name_atom(element->"name_atom",nameVar,isInner,context);
     for Token atom: element.getAllSafely("access") {
       String name = 'atom->"NAME"';
       if atom->"get" != null {
	     nameVar.add(|\get("com.rem.gen.parser.Token.Id._"+'name')|);
	   }
	   else if atom->"getAllSafely" != null {
	     nameVar.add(|\getAllSafely("com.rem.gen.parser.Token.Id._"+'name')|);
	   }
	 }
  }
> void name_atom(Token input, NameVar nameVar, Boolean isInner, Context parentContext) {
    if input->"statement_as_char" != null {
      if 'input->"statement_as_char"->"value"'.equals("\\") {
        nameVar.add(new Statement (new StringEntry("\'"), new StringEntry("\'"),new Statement (new StringEntry("\\")),new Statement (new StringEntry("\\"))));
      }
      else if 'input->"statement_as_char"->"value"'.equals("\"") {
        nameVar.add(new Statement (new StringEntry("\'"), new StringEntry("\'"),new Statement (new StringEntry("\\")),new Statement (new StringEntry("\""))));
      }
      else if 'input->"statement_as_char"->"value"'.equals("\'") {
        nameVar.add(new Statement (new StringEntry("\'"), new StringEntry("\'"),new Statement (new StringEntry("\\")),new Statement (new StringEntry("\'"))));
      }
      else if 'input->"statement_as_char"->"value"'.equals("\'") {
        nameVar.add(new Statement (new StringEntry("\'"), new StringEntry("\'"),new Statement (new StringEntry('input->"value"'))));
      }
	}
    else if input->"statement_as_method" != null {
      if isInner {
		nameVar.add(body.statement(input->"statement_as_method"->"body_statement",true,parentContext));
      }
      else {
		nameVar.add(
		  new Statement (
		    new VariableNameEntry (body.statement(input->"statement_as_method"->"body_statement",true,parentContext),false)));
	  }
	}
	else if input->"statement_as_quote" != null {
	  Statement asQuoteStatement = body.statement(input->"statement_as_quote"->"body_statement",isInner,parentContext);
	  if isInner {
		nameVar.add(new ExternalStatement(new StringEntry("\""),new StringEntry("\""), asQuoteStatement));
      }
	  else {
		StringBuilder checkBuilder = new StringBuilder();
		asQuoteStatement.get(checkBuilder);
		if 'checkBuilder'.startsWith("\"") {
		  nameVar.add(asQuoteStatement);
		}
		else {
		  nameVar.add(new ExternalStatement(new StringEntry("\""),new StringEntry("\""), asQuoteStatement));
		}
      }
	}
	else if input->"statement_as_string" != null {
	  nameVar.setWrapNumbers(true);
	  nameVar.add(new Statement (new VariableNameEntry(body.statement(input->"statement_as_string"->"body_statement",true,parentContext)).asString()));
	  nameVar.setWrapNumbers(false);
	}
	else if input->"quote" != null {
	  if isInner {
		nameVar.add("\""+'input->"quote"'\+"\"");
	  }
	  else {
		nameVar.add('input->"quote"');
	  }
	}
	else if input->"NUMBER" != null {
	  nameVar.add('input->"NUMBER"');
	}
	else if input->"variable_names" != null {
	  ~String value = 'input->"variable_names"';
 	  if \mainClass.getVariables().containsKey(value) && (parentContext == null || parentContext.hasLink(value) == false) {
 	    value = "MainFlow.self."\+value;
 	    if isInner {
 	      nameVar.add(new ExternalStatement(new VariableNameEntry(value)));
 	    }
 	    else {
 	      nameVar.add(new ExternalStatement(new StringEntry(value)));
        }
 	  }
 	  else {
 	    if parentContext != null && parentContext.hasLink(value) {
 	      String typeName = parentContext.type(value);
 	      ~NumberVar asNumber = null;
 	      if "int".equals(typeName) {
 	        asNumber = new IntegerVar(value);
 	      }
 	      else if "double".equals(typeName) {
 	        asNumber = new DoubleVar(value);
 	      }
 	      else if "float".equals(typeName) {
 	        asNumber = new FloatVar(value);
 	      }
 	      else if "long".equals(typeName) {
 	        asNumber = new LongVar(value);
 	      }
 	      else if "byte".equals(typeName) {
 	        asNumber = new ByteVar(value);
 	      }
 	      if asNumber != null {
 	        if nameVar.getWrapNumbers() {
 	          if isInner {
 	            nameVar.add(new ExternalStatement(new VariableNameEntry(asNumber.getAsWrapped())));
 	          }
 	          else {
 	            nameVar.add(new ExternalStatement(new StringEntry(asNumber.getAsWrapped())));
              }
 	        }
 	        else {
 	          if isInner {
 	            nameVar.add(new ExternalStatement(new VariableNameEntry(value)));
 	          }
 	          else {
 	            nameVar.add(new ExternalStatement(new StringEntry(value)));
              }
 	        }
 	      }
 	      else {
 	        if isInner {
 	          nameVar.add(new ExternalStatement(new VariableNameEntry(value)));
 	        }
 	        else {
 	          nameVar.add(new ExternalStatement(new StringEntry(value)));
            }
 	      }
 	    }
 	    else {
 	      if isInner {
 	        nameVar.add(new ExternalStatement(new VariableNameEntry(value)));
 	      }
 	      else {
 	        nameVar.add(new ExternalStatement(new StringEntry(value)));
          }
 	    } 
 	  }
 	  
	}
	else {
	  input.err();
	}
  }  
> void type_var(Token input, Type output, Boolean isInner, Context parentContext){
    if isInner {
      output.inner();
    }
    else {
      output.outer();
    }
    for Token element: input.getAll() {
      if element.getName().equals("type_atom") {
          \type_atom(element,output,isInner,parentContext);
      }
      else if element.getName().equals("accessMethod") {
        if element->"name_var" != null {
          NameVar methodNameVar = new NameVar();
          \name_var(element->"name_var",methodNameVar,isInner,parentContext);
          output.addFindMethod(methodNameVar.getAsStatement());
        }
        else {
          output.addFindMethod(|'' "*" ''|);
        }
      }
      else if element.getName().equals("template_parameters") { 
        for Token quark: element.getAllSafely("template_parameter") {
          Type templateType = new Type();
          \all_type(quark,templateType,isInner,parentContext);
          output.addTemplateClass(templateType);
        }
      }
    }
  }
> void type_atom(Token input, Type output, Boolean isInner, Context parentContext){
    if input->"statement_as_method" != null {
      Statement statement = body.statement(input->"statement_as_method"->"body_statement",true,parentContext);
      StringBuilder builder = new StringBuilder();
      statement.get(builder);
      if isInner {
        output.addSubClass('builder');
      }
      else {
        output.addSubClass(new Statement (new VariableNameEntry('builder')));
      }
    }
    else if input->"statement_as_quote" != null {
      Statement quoteAsStatement = body.statement(input->"statement_as_quote"->"body_statement",true,parentContext);
      output.addSubClass(new Statement (new StringEntry("\""), new StringEntry("\""), quoteAsStatement));
    }
    else if input->"statement_as_string" != null {
      if isInner {
        output.addSubClass(
          |"\"+"+`body.statement(input->"statement_as_string"->"body_statement",true,parentContext)`.toString()+"\""|);
        output.as_entry();
      }
      else {
        output.addSubClass(
          new ExternalStatement(new VariableNameEntry(body.statement(input->"statement_as_string"->"body_statement",true,parentContext)).asString()));
      }
    }
    else if input->"class" != null {
      ~Statement value = null;
      if input->"class"->"class_variable_names" != null {
        if isInner {
          value = |'input->"class"->"class_variable_names"'|;
        }
        else {
          value = new Statement (new VariableNameEntry('input->"class"->"class_variable_names"'\+".getFullName()"));
        }
        output.plain();
      }
      else {
        value = |'input->"class"->"class_names"'|;
      }
      output.addSubClass(value);
    }
  }
> void all_type(Token input, Type output, Boolean isInner, Context parentContext){

	if input.getName().equals("as_statement") {
	  output.addSubClass("ExternalStatement");
	  if input->"subClass" != null {
		output.addSubClass('input->"subClass"');
	  }
	  return void;
	}
    if input.getAll() != null {
      if input->"type_var" != null {
        for Token element: input.getAllSafely("type_var") {
          \type_var(element,output,isInner,parentContext);
	    }
	  }
	  else {
	    for Token element: input.getAll() {
          \all_type(element,output,isInner,parentContext);
	    }
	  }
    }
    else {
      if input.getValue().equals("%T") {
		output.addSubClass("com.rem.gen.parser.Token");
	  }
	  else if input.getValue().equals("%Id") {
		output.addSubClass("com.rem.gen.parser.Token.Id");
	  }
	  else if input.getValue().equals("%Parser") {
		output.addSubClass("com.rem.gen.parser.Parser");
	  }
	  else if input.getValue().equals("%Result") {
		output.addSubClass("com.rem.gen.parser.Parser.Result");
	  }
	  else if input.getValue().equals("%Pass") {
		output.addSubClass("com.rem.gen.parser.Parser.Result.Pass");
	  }
	  else if input.getValue().equals("%Fail") {
		output.addSubClass("com.rem.gen.parser.Parser.Result.Fail");
	  }
	  else if input.getValue().trim().equals("Class") {
		output.addSubClass("ExternalClassEntry");
	  }
	  else if input.getValue().trim().equals("Method") {
		output.addSubClass("ExternalMethodEntry");
	  }
	  else if input.getValue().trim().equals("Variable") {
		output.addSubClass("ExternalVariableEntry");
	  }
	  else if input.getValue().trim().equals("Body") {
		output.addSubClass(new ExternalStatement.TypeName(|"ExternalStatement"|));
		output.addSubClass(|"Body"|);
	  }
	  else if input.getValue().trim().equals("Parameters") {
	  
		output.addSubClass(new ExternalStatement.TypeName(|"ExternalStatement"|));
		output.addSubClass(|"Parameters"|);
	  }
	  else if input.getValue().trim().equals("Context") {
		output.addSubClass("com.rem.parser.generation.classwise.ExternalContext");
	  }
	}
  }
}

import classes.clws
import methods.clws
import bodies.clws
import variables.clws

< ExternalStatement : \com.\rem.\parser.\generation.`classwise`;
> class TypeName // {}
> class TypeStatement // {
    ~Statement asStatement = null;
    ~String asString = null;
    void set(Statement statement){
      asStatement = statement;
    }
    void set(String string){
      asString = string;
    }
  }
> class Type // {
  ~ExternalStatement.TypeName asPublicStatement = new ExternalStatement.TypeName ();
  ~List<TypeStatement > parts = new ArrayList<TypeStatement >();
  ~List<ExternalStatement.TypeName > templateTypes = new ArrayList<ExternalStatement.TypeName >();
  
  ~Boolean isInlineList = false;
  ~Boolean isInner = true;
  ~Boolean isActuallyPlain = false;
  ~Boolean isPlain = true;
  ~Boolean isAsVariable = false;
  ~int numberOfArraySymbols = 0;
  ~Boolean hasChanged = false;
  ~Statement findMethod = null;
  
  ExternalStatement.TypeName getAsStatement(){
    if hasChanged {
      \update();
      hasChanged = false;
    }
    return asPublicStatement;
  }
  void inner(){
    isInner = true;
    hasChanged = true;
  }
  void outer(){
    isInner = false;
    hasChanged = true;
  }
  void as_variable(){
    isAsVariable = true;
  }
  void plain(){
    isPlain = true;
    isActuallyPlain = true;
  }
  void as_entry(){
    isPlain = false;
  }
  TypeStatement statement(Statement statement){
    TypeStatement typeStatement = new TypeStatement();
    typeStatement.set(statement);
    return typeStatement;
  }
  TypeStatement string(String string){
    TypeStatement typeStatement = new TypeStatement();
    typeStatement.set(|'string'|);
    typeStatement.set(string);
    return typeStatement;
  }
  void addSubClass(String subClass){
    parts.add(\string(subClass));
    hasChanged = true;
  }
  void addSubClass(Statement subClass){
    parts.add(\statement(subClass));
    hasChanged = true;
  }
  void addSubClass(Type subType){
    int numberOfParts = parts.size();
    parts.addAll(subType.parts);
    templateTypes.addAll(subType.templateTypes);
    if subType.isInlineList {
      isInlineList = true;
    }
    numberOfArraySymbols = subType.numberOfArraySymbols;
    hasChanged = true;
  }
  void addTemplateClass(ExternalStatement.TypeName templateType){
    templateTypes.add(templateType);
    hasChanged = true;
  }
  void addTemplateClass(Type templateType){
    templateTypes.add(templateType.getAsStatement());
    hasChanged = true;
  }
  void addArraySymbol(){
    numberOfArraySymbols \+= 1;
    hasChanged = true;
  }
  void setIsInlineList(Boolean newInlineList){
    isInlineList = newInlineList;
    hasChanged = true;
  }
  void concatenateWith(Type otherType){
    ~int i = 0;
    while i < otherType.parts.size() {
      parts.add(otherType.parts.get(i));
      i \+= 1;
    }
    hasChanged = true;
  }
  void addFindMethod(Statement newFindMethod){
    findMethod = newFindMethod;
    if isActuallyPlain == false {
      isPlain = false;
    }
  }
    
  void update(){
    asPublicStatement.clear();
    Statement partStatement = new Statement (".");
    for Integer i < parts.size() {
      TypeStatement part = parts.get(i);
      if isInner {
        if i == 0 {
          if part.getAsString() == null {
            if isPlain {
              partStatement.add(|`part.getAsStatement()`|);
            }
            else {
              StringBuilder nextTypeBuilder = new StringBuilder();
              part.getAsStatement().get(nextTypeBuilder);
              if classGenerator.hasDefinedClassName('nextTypeBuilder'){
                partStatement.add(|\ExternalClassEntry.classMap.get("\""+`part.getAsStatement()`+"\"")|);
              }
              else {
                partStatement.add(|`part.getAsStatement()`|);
              }
            }
          }
          else {
            partStatement.add(|'part.getAsString()'|);
          }
        }
        else {
          if part.getAsString() == null {
            if isPlain {
              partStatement.add(|`part.getAsStatement()`|);
            }
            else {
              partStatement.add(|\getSubClass("\""+`part.getAsStatement()`+"\"")|);
            }
          }
          else {
            partStatement.add(|'part.getAsString()'|);
          }
        }
      }
      else {
        if part.getAsString() == null {
          partStatement.add(|`part.getAsStatement()`|);
        }
        else {
          partStatement.add(|'part.getAsString()'|);
        }
      }
    }
    asPublicStatement.setTypeName(partStatement);
    if templateTypes.isEmpty() == false {
      Parameters templateStatement = new Parameters ();
      for ExternalStatement.TypeName type: templateTypes {
        templateStatement.add(type);
      }
      asPublicStatement.setTemplateType(templateStatement); 
    }
    asPublicStatement.setNumberOfArraySymbols(numberOfArraySymbols);
    if isInlineList {
      asPublicStatement.setIsInlineList(true);
    }
    if findMethod != null {
      asPublicStatement.add(|".getMethod"(`findMethod`)|);
    }
    if isPlain && isInner && isAsVariable {
      String lastAsString;
      if parts.get(parts.size()-1).getAsString() != null {
        lastAsString  = parts.get(parts.size()-1).getAsString(); 
      }
      else {
        StringBuilder lastBuilder = new StringBuilder();
        parts.get(parts.size()-1).getAsStatement().get(lastBuilder);
        lastAsString = lastBuilder.toString();
      }
      if classGenerator.hasDefinedClassName('lastAsString') {
        asPublicStatement.add(|"._"|);
      }
    }
  }
}
> class NameVar // {
  @~boolean wrapNumbers = false;
  ~ExternalStatement asPublicStatement = new ExternalStatement ();
  ~List<Statement > castStatements = new ArrayList<Statement >();
  
  
  ~String asPublicString = null;
  ~List<Statement > parts   = new ArrayList<Statement >();
  ~List<String> strings = new ArrayList<String    >();
  ~Boolean hasChanged = false;
  ~Boolean isInner = true;
  ~Boolean isToken = false;
  HashSet<Integer> asStatementParts = new HashSet<Integer>();
    
  void tokenAccess(){
    isToken = true;
  }
  ExternalStatement getAsStatement(){
    if hasChanged {
      \update();
      hasChanged = false;
    }
    return asPublicStatement;
  }
  String getAsString(){
    if hasChanged {
      \update();
      hasChanged = false;
    }
    return asPublicString;
  }
  void inner(){
    isInner = true;
    hasChanged = true;
  }
  void outer(){
    isInner = false;
    hasChanged = true;
  }
  void addCastStatement(Statement castStatement){
    castStatements.add(castStatement);
  }
  void add(Statement subStatement){
    StringBuilder builder = new StringBuilder();
    subStatement.get(builder);
    strings.add(builder.toString());
    parts.add(subStatement);
    hasChanged = true;
  }
  void add(String subStatement){
    if isInner {
      parts.add(|'subStatement'|);
    }
    else {
      parts.add(|'subStatement.replace("\"","\\\"")'|);
    }
    strings.add(subStatement);
    hasChanged = true;
  }
  void add(NumberVar numberVar) {
    if NameVar.wrapNumbers {
      parts.add(|'numberVar.getAsWrapped()'|);
      strings.add(numberVar.getAsWrapped());
    }
    else {
      parts.add(|'numberVar.getPlain()'|);
      strings.add(numberVar.getPlain());
    }
  }
  void add(NameVar otherNameVar){
    parts.addAll(otherNameVar.parts);
    strings.addAll(otherNameVar.strings);
    hasChanged = true;
  }
  void concatenateWith(NameVar otherNameVar){
    parts.addAll(otherNameVar.parts);
    strings.addAll(otherNameVar.strings);
    hasChanged = true;
  }
  void update(){
    asPublicStatement.clear();
    for Statement castStatement: castStatements {
      asPublicStatement.add(|(`castStatement`)|);
    }
    Statement newStatement = new Statement ();
    if isToken {
      newStatement.set(".");
    }
    else {
      newStatement.set("+");
    }
    for Statement part: parts {
      newStatement.add(part);
    }
    asPublicStatement.add(newStatement);
    StringBuilder stringBuilder = new StringBuilder();
    for String string: strings {
      stringBuilder.append(string);
    }
    asPublicString = stringBuilder.toString();
  }
  void setWrapNumbers(boolean isWrapped){
    wrapNumbers = isWrapped;
  }
}

> class NumberVar //{
  NumberVar *(String iPlain){
    plain = iPlain;
  }
  ~String plain;
  String getAsWrapped(){return "new "+\getName()+"("+\getPlain()+")"; }
  String getName(){ return null; }
}
> class DoubleVar /NumberVar/ {
  DoubleVar *(String plain){super(plain);}
  String getName(){ return "Double";}
}
> class FloatVar /NumberVar/ {
  FloatVar *(String plain){super(plain);}
  String getName(){ return "Float";}
}
> class IntegerVar /NumberVar/ {
  IntegerVar *(String plain){super(plain);}
  String getName(){ return "Integer";}
}
> class LongVar /NumberVar/ {
  LongVar *(String plain){super(plain);}
  String getName(){ return "Long";}
}
> class ByteVar /NumberVar/ {
  ByteVar *(String plain){super(plain);}
  String getName(){ return "Byte";}
}

IParser getRootParser() {return null;}
List<IParser> getRules() {return null;}
List<IParser> getListnames() {return null;}
RegexParser getLazyNameParser() {return null;}
void assignListElementNames(ParseContext data, IToken rootToken) {}
void setup(ParseContext data) {}