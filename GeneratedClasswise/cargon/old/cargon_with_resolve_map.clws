

< EnumMap : \java.\util;
< CargonTokens : \lists;
< Rules : \lists;
< Listnames : \lists;
< Arrays : \java.\util;

> Body variableDeclarations = new Body ();
> Statement globalIgnoresHeader = new Statement ();
> Map<String, Statement > ruleIgnoresHeaders = new HashMap<String, Statement >();
> Set<String> variableDeclarationNames = new HashSet<String>();
> Map<String, Set<String> > ruleHeirachy = new HashMap<String, Set<String>>();
> Set<String > listNames = new HashSet<String>();
> Map<String, %T > subRulesProposed = new HashMap<String, %T >();
> Set<String> declaredContexts = new HashSet<String>();
> ~String previousContextClassName = "AnonymousContext";

> void generate(%Pass data){
	%T root = data.getRoot();
	Body vb = new Body ();
	vb.add(variableDeclarations);
	Parser->Context->*"parse".appendToBody(vb);
	Statement globalIgnoresHeaderVariableSection = new Statement ();
	\setupIgnoresHeader(globalIgnoresHeader,globalIgnoresHeaderVariableSection);
	if root->"ignores" != null {
	  root :  element : ignores {
        element : atom : ignoreCharacter {
          \addIgnoresCharacter('atom',globalIgnoresHeaderVariableSection);
	    }
	  }
	}
	else {
	  \addIgnoresCharacter(" ",globalIgnoresHeaderVariableSection);
	  \addIgnoresCharacter("\\t",globalIgnoresHeaderVariableSection);
	  \addIgnoresCharacter("\\n",globalIgnoresHeaderVariableSection);
	}
	root : list : list {
		Parser.list(list);
	}
	root : rule : rule {
		Parser.findSilentRule(rule);
	}
	root : rule : rule {
		Parser.findRuleHeirachy(rule);
	}
	~boolean hasAllRulesDefined = true;
	for String ruleName: subRulesProposed.keySet() {
	  if ruleHeirachy.containsKey(ruleName) == false && listNames.contains(ruleName)==false {
	    System.out.println("Could not find rule name: "\+ruleName\+" from :");
	    subRulesProposed.get(ruleName).print();
	    hasAllRulesDefined = false;
	  }
	}
	if hasAllRulesDefined {
	  Parser.consolidateRuleHeirachy();
	  root : rule : rule {
		Parser.define(rule,null);
	  }
	  Parser.outputBraces();
	  Parser.output();
	}
  }
> void setup(%Result data){
    Parser.setupCompile();
  }
> String parserPackageName = "com.rem.gen.parser";
> String packageName = "com.rem.gen";
> String charArray = "char[]";

> void setupIgnoresHeader(Statement toSetup, Statement variableSection){
    toSetup.set("&&");
    variableSection.set("||");
    variableSection.add(|"false"|);
    toSetup.add(|"_position" < "_inputLength" |);
    toSetup.add(|(`variableSection`)|);
  }
> void addIgnoresCharacter(String ignoresCharacter, Statement variableSection){
    if ignoresCharacter== null || ignoresCharacter.equals("") {
 	  variableSection.add(|"_inputArray[_position]" == "' '"|);
    }
    else {
      StringBuilder characterBuilder = new StringBuilder();
      characterBuilder.append("'");
      characterBuilder.append(ignoresCharacter);
      characterBuilder.append("'");
	  variableSection.add(|"_inputArray[_position]" == 'characterBuilder' |);
	  if ignoresCharacter.equals("\\n") {
	    variableSection.add(|"_inputArray[_position]" == "'\\r'"|);
      } 
    }
  }

class 'packageName'."parser" Parser {
  @Integer SUCCESS = 0;
  @Integer FAILED = 1;
  @Integer FIRST_PASS = 0;
  @Integer SECOND_PASS = 1;
  @Set<String> fileNames = new HashSet<String>();
  @Map<String, Parser\>Context > contexts = new HashMap<String, Parser\>Context >();
  
  Parser->Result parse(String fileName){
    long startParseTime = System.currentTimeMillis();
    Parser->Result firstResult = \parseFile(fileName, FIRST_PASS);
    if firstResult.getState() == SUCCESS {
      System.out.println('' "First-Pass Successful" '' );
      fileNames.clear();
      Parser->Result secondResult = \parseFile(fileName, SECOND_PASS);
      if secondResult.getState() == SUCCESS {
        System.out.println('' "Second-Pass Successful" '' );
      }
      else {
        System.out.println('' "Second-Pass Failed" '' );
      }
      secondResult.setParseTime(System.currentTimeMillis() \- startParseTime);
      return secondResult;
    }
    else {
      System.out.println('' "First-Pass Failed" '' );
      firstResult.setParseTime(System.currentTimeMillis() \- startParseTime);
      return firstResult;
    }
  }
  Parser->Result parseFile(String fileName, int _pass){
  }
  
  > @ Body readInputBody = new Body ();
  > Body braceVariableDeclaration = new Body ();
  > String notQuoting = "!quoting";
  > String notEscaping = "!escaping";
> Map<String,List<Body >> rules = new HashMap<String,List<Body >>();
> Map<String,List<Body >> completeRules = new HashMap<String,List<Body >>();
> Map<Body , String> ruleHolders = new HashMap<Body , String>();
> Map<String, Map<Integer, List< Body >>> unsatisfiedRules = new HashMap<String, Map<Integer, List< Body >>>();
> Map<String, Body > ruleForeBodies = new HashMap<String, Body >();
> Map<String,String> parentRuleNames = new HashMap<String,String>();
> Set<String > silentRules = new HashSet<String>();
> Set<String > globalListNames = new HashSet<String>();
> Map<String, String> listFirstPassRules = new HashMap<String, String>();
> Set<String> listPreparers = new HashSet<String>();
> Map<String, Set<String>> listNamesInRule = new HashMap<String, Set<String>>();
> Map<String, String> handleListAdditions = new HashMap<String, String>();
> Map<String, Body > handleListAdditionAftBodies = new HashMap<String, Body >();
> Set<String> handleRecursionProtection = new HashSet<String>();
> ~Integer tokenId = 1;
> ~String ROOT_NAME = null;
> Map<String,Set<String>> declaredPositions = new HashMap<String,Set<String>>();
> Statement bracedCondition = new Statement ();
> Set<String> declaredBraces = new HashSet<String>();
> Map<String, List<String>> declaredBraceValues = new HashMap<String, List<String>>();
> Map<String, String> declaredBraceRules = new HashMap<String, String>();
> Map<String, Integer> braceIds = new HashMap<String,Integer>();
> Map<String, Integer> declaredBraceOpenLengths = new HashMap<String, Integer> ();
> Map<String, Integer> declaredBraceCloseLengths = new HashMap<String, Integer> ();
> Map<Integer, Map<String, List<Integer>>> declaredBraceOpenValues = new HashMap<Integer, Map<String, List<Integer>>>();
> Map<Integer, Map<String, List<Integer>>> declaredBraceCloseValues = new HashMap<Integer, Map<String, List<Integer>>>();
> Map<String, Integer> declaredBracePasses = new HashMap<String, Integer>();
> Parameters newContextParameters = new Parameters ();
> Map<String, Set<String>> subRuleTokenDeclarations = new HashMap<String,Set<String>>();

> ~Integer currentPositionIndex = 0;
> ~Integer anonymousRuleIndex = 0;
> ~String plainTokenClassName = "_0";
> ~Integer plainTokenIndex = 0;
> Set<String> createdPlainTokens = new HashSet<String>();
> Map<String,String> createdSyntaxTokens = new HashMap<String,String>();
> Set<String> importRuleNameTokens = new HashSet<String>();
> Map<String,Set<String>> createdSyntaxNameTokens = new HashMap<String,Set<String>>();
> Set<String> createdNameTokens = new HashSet<String>();
> Body preparsedListRun = new Body ();

  ?class Context // {
  
  	~Integer SUCCESS = Parser.SUCCESS;
  	~Integer FAILED = Parser.FAILED;
  	~Integer FIRST_PASS = Parser.FIRST_PASS;
  	~Integer SECOND_PASS = Parser.SECOND_PASS;
    ~int _pass = FIRST_PASS;
    ~\int _position = 0;
    ~\int _inputLength = -1;
    ~\int _state = SUCCESS;
    ~\int _furthestPosition = -1;
    ~\int _lineNumber = 1;
    ~String _input = null;
    ~String _directoryName = null;
    ~String _fileName = null;
    ~'charArray' _inputArray = null;
    ~Parser->Result _result = null;
    ~Parser->Result->Acceptor _result_acceptor = new Parser->Result->Acceptor();
    ~Boolean _succeedOnEnd = true;
    ~String _list_name_result = null;
    ~List<Integer> _lineNumberRanges = new ArrayList<Integer>();
    ~Token->Parsed _root = new Token->Parsed(Token->Id.ROOT);
    ~Token->Parsed _token = _root;
    ~Set<ImportThread> _import_threads = new HashSet<ImportThread>();
    Parser->Result parse(String _fileName, int _pass_index){
      if fileNames.add(_fileName) == false {
        return null;
      }
      _pass = _pass_index;
      _directoryName = ''"./"'';
      int indexOfDirectorySlash = _fileName.lastIndexOf(''"/"'');
      if indexOfDirectorySlash == -1 {
        indexOfDirectorySlash = _fileName.lastIndexOf(''"\\\\"'');
      }
      if indexOfDirectorySlash > -1 {
        _directoryName = _fileName.substring(0,indexOfDirectorySlash\+1);
        _fileName      = _fileName.substring(indexOfDirectorySlash\+1);
      }
      StringBuilder _inputBuffer = new StringBuilder();
      try {
        BufferedReader _inputReader = new BufferedReader(new FileReader(_directoryName\+_fileName));
        \int _readInput = _inputReader.read();
        \boolean escaping = false;
        \boolean quoting = false; 
        while _readInput >= 0 `readInputBody`
        _lineNumberRanges.add(_position);
        _inputReader.close();
      }
      print catch IO {}
      
    }
    void addImportThread(String importFileName){
      synchronized _import_threads {
        ImportThread thread = new ImportThread(this,Parser.contexts.get(importFileName),importFileName);
        _import_threads.add(thread);
        thread.start();
      }
    }
    class ImportThread / Thread / {
      Parser->Context parentContext = null;
      Parser->Context context = null;
      String fileName = null;
      void run() {
        Parser->Result result = context.parse(fileName,parentContext.get_pass());
        if result != null {
          parentContext.get_resultAcceptor().add(result);
          result.setFileName(fileName);
        }
      }
    }
  }
  @String readLine(String input, int position){
    int indexOfLine = input.indexOf("'\\n'",position);
    if indexOfLine == -1 {
      return input.substring(position);
    }
    else {
      return input.substring(position,indexOfLine);
    }
  }
> Body endBuildersBody = new Body ();
> void output(){
    if ROOT_NAME == null {
	  \System.err.println("No root rule found!");
	}
    else {
      for String ruleName: rules.keySet() { 
        Body ruleBody = new Body ();
        \getRuleBody(ruleBody,ruleName,new HashMap<String, Set<Integer>>());
      }
      Body extendsBody = new Body ();
      Body keepsBody = new Body ();
      for String listName: listNames {
        extendsBody.add(|'listName'.extend();|);
        keepsBody.add(|'listName'.keep();|);
      }
      Parser->Context->*"parse".appendToBody(endBuildersBody);
      Parser->Context->*"parse".appendToBody(|
        "_input" = "_inputBuffer".toString();
        "_inputArray" = "_input".toCharArray();
        "_inputLength" = "_inputArray".length;
        "this._fileName" = "_fileName";
        "_furthestPosition" = 0;
        "_result" = null;
        "_position" = 0;
        "_state" = SUCCESS;
      
        while `globalIgnoresHeader` {
          "++_position";
        }|);
      Parser->Context->*"parse".appendToBody(|
        if "_pass" == Parser.SECOND_PASS `extendsBody`
        \_parse_root();|);
        
      Parser->Context->*"parse".appendToBody(|
        if "_pass" == Parser.FIRST_PASS `keepsBody`
        
        try {
          for ImportThread _import_thread: "_import_threads" {
            _import_thread.join();
            if _import_thread.getContext().get_state() == "FAILED" {
              "_state" = "FAILED";
            }
          }
        }
        print catch * {}
        "_import_threads".clear();|);
      Parser->Context += void _parse_root() {
          "parse_"+'ROOT_NAME'();
        }
      Parser->Context->*"parse".appendToBody(|
        if "_state" == "SUCCESS" && "_position" == "_inputLength" {
          if "_succeedOnEnd" {
            Parser->Result->Pass pass = new Parser->Result->Pass("SUCCESS", "_position","_lineNumberRanges","_input", "_fileName", "_root" );
            pass.setup();
            "_result" = pass;
          }
          else {
            "_result_acceptor".setFileName("_fileName");
            "_result" = "_result_acceptor";
		    "_state" = "FAILED";
          }
        }
        else if "_state" == "SUCCESS" {
          if "_result" != null {
		    "_result_acceptor".add("_result");
		  }
          "_result_acceptor".add(new Parser->Result->Fail->EOF("_fileName"));
          "_result_acceptor".setFileName("_fileName");
          "_result" = "_result_acceptor";
          "_state" = "FAILED";
        }
        else if "_state" == "FAILED" {
          "_result_acceptor".add("_result");
          "_result_acceptor".setFileName("_fileName");
          "_result" = "_result_acceptor";
        }|);
      for String listName: listNames {
        String listNameForMethod = ^listName;
        Parser->Context->*"parse".appendToBody(|"_result"."set"+'listNameForMethod'('listName');|);
        Parser->Result += ~Set<String> 'listName' = null;
      }
      Parser->Context->*"parse".appendToBody(|return "_result";|);
      Parser->*"parseFile".appendToBody(|
        if "_pass" == "FIRST_PASS" {
          Parser->Context context = new \FinalContext(`newContextParameters`);
          "contexts".put(fileName, context);
          return context.parse(fileName, "FIRST_PASS");
        }
        else {
          "contexts".get(fileName)._root = new Token->Parsed(Token->Id.ROOT);
		  "contexts".get(fileName)._token = "contexts".get(fileName)._root; 
          return "contexts".get(fileName).parse(fileName, "SECOND_PASS");
        } |);
    }
    String previousContextClassNameValue = previousContextClassName;
    ~class 'packageName'."contexts" FinalContext 'previousContextClassNameValue' {
    }
  }
  
> void outputBraces() {
    ~Integer maxOpen = 0;
    for Integer key : declaredBraceOpenValues.keySet() {
      if key > maxOpen {
        maxOpen = key;
      }
    }
    ~Integer maxClose = 0;
    for Integer key : declaredBraceCloseValues.keySet() {
      if key > maxClose {
        maxClose = key;
      }
    }
    ~Integer max = 0;
    if maxOpen > maxClose {
      max = maxOpen;
    }
    else {
      max = maxClose;
    }
    Body readBracesBody = new Body ();
    readInputBody.add(preparsedListRun);
    readInputBody.add(|
      if "_readInput" != 13 {
        "_inputBuffer".append("(char)_readInput");
      }
      if "_readInput" == "'"+"\\n"+"'" {
        "_lineNumberRanges".add("_position");
      }
      if "escaping" {
        "escaping" = false;
      }
      else if 'notEscaping' && "_readInput" == char\\ {
        "escaping" = true;
      }
      else if 'notQuoting' && "_readInput" == char\"  {
        "quoting" = true;
        "brace_open_0".push("_position");
      }
      else if "quoting" && "_readInput" == char\" {
        "quoting" = false;
        "brace_0".put("brace_open_0".pop(),"_position");
      }
      else if 'notQuoting' && 'notEscaping' `readBracesBody`
      if "_readInput" != 13 {
        "++_position";
      }|);
    ~Integer i = maxOpen;
    while i > 0 {
    if declaredBraceCloseValues.containsKey(i) {
        Map<String,List<Integer>> closeMap = declaredBraceCloseValues.get(i);
        for String key : closeMap.keySet() {
          Body closeBody = new Body ();
          Statement closeHeader = new Statement ();
          ~Integer j = i;
          closeHeader.set("&&");
          Integer jndexFirst = j;
          if new Character(key.charAt(jndexFirst\-1)).toString().equals("\'") {
            closeHeader.add(|"_readInput" == "'\\"+'new Character(key.charAt(jndexFirst\-1))'+"'"|);
          }
          else {
            closeHeader.add(|"_readInput" == "'"+'new Character(key.charAt(jndexFirst\-1))'+"'"|);
          }
          j \-= 1;
          while j > 0 {
            Integer jndex = j;
            if new Character(key.charAt(j\-1)).toString().equals("\'") {
              closeHeader.add(|"_readInput_"+'jndex' == "'\\"+'new Character(key.charAt(jndex\-1))'+"'"|);
            }
            else {
              closeHeader.add(|"_readInput_"+'jndex' == "'"+'new Character(key.charAt(jndex\-1))'+"'"|);
            }
            j \-= 1;
          }
          readBracesBody.add(|if `closeHeader` `closeBody`|);
          if key.length() == 1 {
            for Integer id : closeMap.get(key) {
              closeBody.add(|
                if "!brace_open_"+'id'.isEmpty() {
                  "brace_"+'id'.put("brace_open_"+'id'.pop(),"_position");
                }|);
            }
          }
          else {
            Integer keyOffset = key.length()\-1;
            for Integer id : closeMap.get(key) {
              closeBody.add(|
                if "!brace_open_"+'id'.isEmpty() {
                  "brace_"+'id'.put("brace_open_"+'id'.pop(),"_position"\-'keyOffset');
                }|);
            }
          }
        }
      }
      if declaredBraceOpenValues.containsKey(i) {
        Map<String,List<Integer>> openMap = declaredBraceOpenValues.get(i);
        for String key : openMap.keySet() {
          Body openBody = new Body ();
          Statement openHeader = new Statement ();
          ~Integer j = i;
          openHeader.set("&&");
          Integer jndexFirst = j;
          if new Character(key.charAt(jndexFirst\-1)).toString().equals("\'") {
            openHeader.add(|"_readInput" == "'\\"+'new Character(key.charAt(jndexFirst\-1))'+"'"|);
          }
          else {
            openHeader.add(|"_readInput" == "'"+'new Character(key.charAt(jndexFirst\-1))'+"'"|);
          }
          j \-= 1;
          while j > 0 {
            Integer jndex = j;
            if new Character(key.charAt(j\-1)).toString().equals("\'") {
              openHeader.add(|"_readInput_"+'jndex' == "'\\"+'new Character(key.charAt(jndex\-1))'+"'"|);
            }
            else {
              openHeader.add(|"_readInput_"+'jndex' == "'"+'new Character(key.charAt(jndex\-1))'+"'"|);
            }
            j \-= 1;
          }
          readBracesBody.add(|
            if `openHeader` `openBody`|);
          if key.length() == 1 {
            for Integer id : openMap.get(key) {
              openBody.add(|
                "brace_open_"+'id'.push("_position");|);
            }
          }
          else {
            Integer keyOffset = key.length()\-1;
            for Integer id : openMap.get(key) {
              openBody.add(|
                "brace_open_"+'id'.push("_position"\-'keyOffset');|);
            }
          }
        }
      }
      
      i \-= 1;
    }
    i = max\-1;
    while i > 1 {
      Integer index = i;
      Integer jndex = i\-1;
      Parser->Context += ~\int "_readInput_"+'index' = "0";
      readInputBody.add(|"_readInput_"+'index' = "_readInput_"+'jndex';|);
      i \-= 1;
    }
    if max > 0 {
      Parser->Context += ~\int "_readInput_1" = "0";
      readInputBody.add(|"_readInput_1" = "_readInput";|);
    }
    readInputBody.add(|
      "_readInput" = "_inputReader".read();|);
  }
> void findSilentRule(%T input) {
    if input->"ruleName" != null {
      String ruleName = 'input->"ruleName"';
      if input->"SILENT" != null {
        silentRules.add(ruleName);
      }
      if ROOT_NAME == null {
        ROOT_NAME = ruleName;
      }
    }
  }
> void setupCompile(){
    declaredBraces.add("\"\"");
    Integer braceId = braceIds.size();
    braceIds.put("\"\"",braceId);
    Parser->Context += ~Map<Integer, Integer> "brace_"+'braceId' = new HashMap<Integer, Integer>();
    Parser->Context->*"parse".prependToBody(|Stack<Integer> "brace_open_"+'braceId' = new Stack<Integer>(); |);
  }
> void findRuleHeirachy(%T ruleToken){
    if ruleToken->"ruleName" != null {
      String ruleName = 'ruleToken->"ruleName"';
      ruleHeirachy.put(ruleName,new HashSet<String>());
      if ROOT_NAME == null {
        ROOT_NAME = ruleName;
      }
      ruleToken : definition : definition {
        \findRuleHeirachy(ruleName,definition,ruleToken,ruleHeirachy.get(ruleName));
      }
    }
  }
> void findRuleHeirachy(String ruleName, %T definition, %T parentRule, Set<String> subRuleSet){
    ~Boolean hasFoundStopToken = false; 
    definition : chain : chain {
      chain : element : element {
        if hasFoundStopToken == false {
          element : atom : multiple {
            atom : quark : definition {
              \findRuleHeirachy(ruleName, quark, parentRule, subRuleSet);
            }
          }
          : braced_definition {
            atom : quark : definition {
              \findRuleHeirachy(ruleName, quark, parentRule, subRuleSet);
            }
          }
          : ruleToken {
            subRuleSet.add('element');
            subRulesProposed.put('element',parentRule);
          }
          : regexToken {
            hasFoundStopToken = true;
          }
          : quoteToken {
            hasFoundStopToken = true;
          }
        }
      }
    }
    definition : choice : choice {
      choice : element : definition {
        \findRuleHeirachy(ruleName, element, parentRule, subRuleSet);
      }
    }
  }
> void consolidateRuleHeirachy(){
    Map<String,Set<String>> additions = new HashMap<String,Set<String>>();
    additions.put(ROOT_NAME, new HashSet<String>());
    \consolidateRuleHeirachy(ROOT_NAME, additions, new HashSet<String>());
    for String ruleName: additions.keySet() {
      if ruleHeirachy.containsKey(ruleName) {
        ruleHeirachy.get(ruleName).addAll(additions.get(ruleName));
      }
    }
  }
> void consolidateRuleHeirachy(String ruleName, Map<String,Set<String>> additions, Set<String> consulted){
    if consulted.add(ruleName) {
      if ruleHeirachy.containsKey(ruleName) {
        for String subRuleName: ruleHeirachy.get(ruleName) {
          if additions.containsKey(subRuleName) {
            additions.get(subRuleName).add(ruleName);
          }
          else {
            additions.put(subRuleName, new HashSet<String>());
            \consolidateRuleHeirachy(subRuleName, additions, consulted);
          }
        }
      }
    }
  }
> void list(%T input){
    String listName = 'input->"listName"';
    Parser += ~Parser->NameList 'listName'+"_root" = new Parser->NameList(null);
    newContextParameters.add(|'input->"listName"'+"_root"|);
    Parser->Context += Parser->NameList 'input->"listName"'+"_root" = null;
    Parser->Context += ~Parser->NameList 'input->"listName"' = null;
    Parser->Context->*.appendToBody(|
      'input->"listName"' = 'input->"listName"'+"_root".push();|); 
    listNames.add('input->"listName"');
    input : element : SYNTAX {
      if element.getValue().equals("global") {
        globalListNames.add('input->"listName"');
      }
    }
    if input->"listRuleName" != null {
      listFirstPassRules.put('listName','input->"listRuleName"');
      if listPreparers.add('input->"listRuleName"') {
        String builderClassName = 'input->"listRuleName"';
        Parser->NameList->Builder += class builderClassName / Parser->NameList->Builder / {
          boolean can(int position, char nextChar){
          }
        }
        Parser->Context += ~Map<Integer,String> "_preparsed_"+'builderClassName' = new HashMap<Integer,String>();
        Parser->Context->*"parse".prependToBody(|Parser->NameList->Builder "_builder_"+'builderClassName' = new Parser->NameList->Builder->'builderClassName'("_preparsed_"+'builderClassName');|);
        endBuildersBody.add(|"_builder_"+'builderClassName'.end("_position");|);
        preparsedListRun.add(|"_builder_"+'builderClassName'.add("_position",(char)"_readInput");|);
      }
    }
    input : element : quote {
      Parser->*"parseFile".appendToBody({
       'listName'+"_root".add('' 'element' '');
      });
    }
    Parser->*"parseFile".appendToBody({
      });
  }
> Body getListDeclarations(String ruleName, boolean hasSecondPass){
    Body listDeclarations = new Body ();
    for String listName: listNames {
      if globalListNames.contains(listName) == false{
        if hasSecondPass {
          listDeclarations.add(|
            if "_pass" == Parser.SECOND_PASS {
              'listName' = 'listName'.push();
            }|);
        }
        else {
          listDeclarations.add(|
            'listName' = 'listName'.push("_position","_pass");|);
        }
      }
    }
    return listDeclarations;
  }
> Body getListReallocations(String ruleName){
    Body listReallocations = new Body ();
    for String listName: listNames {
      if globalListNames.contains(listName) == false {
        listReallocations.add(|'listName' = 'listName'.pop();|);
      }
    }
    return listReallocations;
  }
> ~Integer listIndex = 0;
> void getRuleBody(Body completeBody, String ruleName, Map<String, Set<Integer>> excludeIndicesMap){
    String currentLengthValue = "_length_" \+ 'ruleName' \+ "_brace";

    List<Body > rule = rules.get(ruleName);
    ~Body currentOption = completeBody;
    Body withinBraces = new Body ();
    Integer ruleListIndex = listIndex;
    
    String currentRulePositionValue = "_position_"\+ruleName;
    String currentRuleTokenValue = "_token_"\+ruleName;
    currentOption.add(|\int 'currentRulePositionValue' = -1;|);
    currentOption.add(|Token->Parsed 'currentRuleTokenValue' = null;|);
    if declaredPositions.containsKey(ruleName) {
      for String subRuleName : declaredPositions.get(ruleName) {  
        currentOption.add(|int "_position_"+'subRuleName' = -1;|);
      }
    }
    if subRuleTokenDeclarations.containsKey(ruleName) {
      for String subRuleName : subRuleTokenDeclarations.get(ruleName) {
        currentOption.add(|Token->Parsed "_token_"+'subRuleName' = null;|);  
      }
    }
    if declaredBraceRules.containsKey(ruleName) {
      listIndex \+= 1;
      
      currentOption.add(|\int 'currentLengthValue' = "_inputLength";|);
      if declaredBracePasses.containsKey(ruleName) {
      	if declaredBracePasses.get(ruleName) == 1 {
          withinBraces.add(|if "_pass" == "FIRST_PASS" `withinBraces`|);
          withinBraces.add(\getListDeclarations(ruleName,false));
        }
        else if declaredBracePasses.get(ruleName) == 2 {
          Body completeBraceBody = new Body ();
          completeBraceBody.add(\getListDeclarations(ruleName,true));
          completeBraceBody.add(|
              if "_pass" == "SECOND_PASS" `withinBraces`
              else {
                "_position" = "brace_"+'braceIds.get(declaredBraceRules.get(ruleName))'.get("_position") \+ 'declaredBraceCloseLengths.get(ruleName)';
                while `ruleIgnoresHeaders.get(ruleName)` {
                  "++_position";
                }
              }|);
          
          currentOption.add(|
            if "brace_"+'braceIds.get(declaredBraceRules.get(ruleName))'.containsKey("_position") `completeBraceBody`|);
        }
      }
      else {
        currentOption.add(|if "brace_"+'braceIds.get(declaredBraceRules.get(ruleName))'.containsKey("_position") `withinBraces`|);
        withinBraces.add(\getListDeclarations(ruleName,false));
      }
      currentOption = withinBraces;
      String currentPositionValue = "_position_" \+ 'ruleName' \+ "_brace";
      
      currentOption.add(|"_inputLength" = "brace_"+'braceIds.get(declaredBraceRules.get(ruleName))'.get("_position");|);
      currentOption.add(|\int 'currentPositionValue' = "_position";|);
      currentOption.add(|"_position" \+= 'declaredBraceOpenLengths.get(ruleName)';|);
      
      currentOption.add(|
        while `ruleIgnoresHeaders.get(ruleName)` {
          "++_position";
        }|);
    }
    for String listName: listNames {
      currentOption.add(|'listName'.start("_position");|);
    }
    ~Body previousOption = null;
    for Integer i < rule.size() {
      if previousOption != null {
        previousOption.add(|if "_state" == "FAILED" `currentOption`|);
      }
      if previousOption != null {
        for String listName: listNames {
          currentOption.add(|'listName'.reject("_position_"+'ruleName');|);
        }
        currentOption.add(|"_state" = "SUCCESS";|);
      }
      
      previousOption = currentOption;
      currentOption.add(rule.get(i));
      currentOption = new Body ();
    }
    if declaredBraceRules.containsKey(ruleName) {
      String currentPositionValue = "_position_" \+ 'ruleName' \+ "_brace";
      
      withinBraces.add(|if "_state" == "SUCCESS" && "brace_"+'braceIds.get(declaredBraceRules.get(ruleName))'.get("_position_"+'ruleName'+"_brace") == "_position" {
        "_position" \+= 'declaredBraceCloseLengths.get(ruleName)';
      }
      else {
        "_state" = "SUCCESS";
        "_result_acceptor".add("_result");
        "_result_acceptor".add(new Parser->Result->Fail->EOB('' 'ruleName' '',"_position","_lineNumberRanges"));
        "_position" = "brace_"+'braceIds.get(declaredBraceRules.get(ruleName))'.get("_position_"+'ruleName'+"_brace")\+'declaredBraceCloseLengths.get(ruleName)';
        "_succeedOnEnd" = false;
      }
      "_inputLength" = 'currentLengthValue';
      while `globalIgnoresHeader` {
        "++_position";
      }|);
    }
    Body removeAdditionsBody = new Body ();
    Body addAdditionBody = new Body ();
        
    previousOption.add(|if "_state" == "FAILED" `removeAdditionsBody` |);
    previousOption.add(|else if "_state" == "SUCCESS" `addAdditionBody` |);
    if declaredBraceRules.containsKey(ruleName) {
      previousOption.add(\getListReallocations(ruleName));
    }
    for String listName: listNames {
      removeAdditionsBody.add(|'listName'.reject("_position_"+'ruleName');|);
      addAdditionBody.add(|'listName'.accept("_position_"+'ruleName');|);
    }
    if declaredBraceRules.containsKey(ruleName) {
      completeBody.add(|else {
        "_state" = "FAILED";
        if "_position" >= "_furthestPosition" {
          "_result" = new Parser->Result->Fail("FAILED", "_position","_lineNumberRanges","_input", "_fileName", '' 'parentRuleNames.get(ruleName)'+"("+'ruleName'+")" '');
          "_furthestPosition" = "_position";
        }
      }|);
    }
    if('ruleName'.startsWith("_anonymous")){
      Parser->Context += ?void "parse_"+'ruleName'(){}
      AnonymousContext += void "parse_"+'ruleName'(){
      }
      AnonymousContext->*"parse_"+'ruleName'.appendToBody(completeBody);
    }
    else {
      String contextClassName;
      String contextPackageName;
      int indexOfUnderscore = 'ruleName'.indexOf("_");
      if indexOfUnderscore > -1 && 'ruleName'.substring(0,indexOfUnderscore).equals("class") == false {
        contextClassName = 'ruleName'.substring(0,indexOfUnderscore).toLowerCase()+"_context";
        contextPackageName = 'ruleName'.substring(0,indexOfUnderscore);
      }
      else {
        contextClassName = 'ruleName'.toLowerCase()+"_context";
        contextPackageName = 'ruleName';
      }
      if declaredContexts.add(contextClassName) {
        String previousContextClassNameValue = previousContextClassName;
        ~?class 'packageName'."contexts" contextClassName 'previousContextClassNameValue' {
          ~Parser __parser__ = null;
          ~Tokens __tokens__ = null;
        }
        previousContextClassName = contextClassName;
      }
      \ExternalClassEntry.classMap.get('contextClassName').addMethod(void "parse_"+'ruleName'(){});
      \ExternalClassEntry.classMap.get('contextClassName').getMethod("parse_"+'ruleName').appendToBody(completeBody);
    }
    Parser->Context += ?void "parse_"+'ruleName'(){} 
  }
> String define(%T input, String previousParentRuleName){
    return \define(input,previousParentRuleName,null,null);
  }
> String define(%T input, String previousParentRuleName, String handleBracedTokenName, Set<String> parentImportRuleNames){
    String ruleName;
    String parentRuleName;
    if input->"ruleName" != null {
      ruleName = 'input->"ruleName"';
      String ruleClassName = ^ruleName\+"Token";
      String nameWithResolve = "Resolve"\+ruleName;
      \declareResolverMapName(ruleName);
      Token->Id += void "_"+'ruleName';
      Tokens->Rule += class ruleClassName / Token->Parsed /{
        Token->Id getName(){
          return Token->Id."_"+'ruleName';
        }
        ~String value = null;
        String getValue(){
          if value == null {
            return super.getValue();
          }
          else {
            return value;
          }
        }
        Token->Resolver getResolver(Token->ResolverMap map){
            return ((Token->ResolverMap->'nameWithResolve')\map)."resolve_"+'ruleName'();
        }
      }
      parentRuleName = ruleName;
    }
    else {
      ruleName = "_anonymous_" \+ anonymousRuleIndex;
      anonymousRuleIndex \+= 1;
      silentRules.add(ruleName);
      parentRuleName = previousParentRuleName;
    }
    parentRuleNames.put(ruleName,parentRuleName);
    if ROOT_NAME == null {
      ROOT_NAME = ruleName;
    }
    if rules.containsKey(ruleName) == false {
      completeRules.put(ruleName, new ArrayList<Body >());
      rules.put(ruleName, completeRules.get(ruleName));
      completeRules.get(ruleName).add(new Body ());
    }
    List<Body > rule = completeRules.get(ruleName);
    Boolean isSilent = input->"SILENT" != null;
    if isSilent {
      silentRules.add(ruleName);
    }
    
    Body foreBody = new Body ();
    String currentPositionValue = "_position_"\+ruleName;
    foreBody.add(|
      if "_position" >= "_furthestPosition" {
        "_result" = new Parser->Result->Fail("FAILED", "_position","_lineNumberRanges","_input", "_fileName", '' 'parentRuleNames.get(ruleName)'+"("+'ruleName'+")" '');
        "_furthestPosition" = "_position";
      }
      "_position" = 'currentPositionValue';|);
    ruleForeBodies.put(ruleName,foreBody);
    if input->"ignores_character" != null {
      Statement newIgnoresHeader = new Statement ();
      Statement newIgnoresVariableSection = new Statement ();
      \setupIgnoresHeader(newIgnoresHeader, newIgnoresVariableSection);
      input : character: ignores_character {
        \addIgnoresCharacter('character', newIgnoresVariableSection);
      }
      ruleIgnoresHeaders.put(ruleName,newIgnoresHeader);
    }
    else if input->"ignores_none" != null {
      Statement newIgnoresHeader = new Statement ();
      \setupIgnoresHeader(newIgnoresHeader, new Statement ());
      ruleIgnoresHeaders.put(ruleName,newIgnoresHeader);
    }
    else {
      ruleIgnoresHeaders.put(ruleName,globalIgnoresHeader);
    }
    if input->"import_parameter" != null {
      Set<String> importRuleNames = new HashSet<String>();
      String ruleClassName = ^ruleName;
      String fileImportRuleName = ruleName+"__file_import";
      String fileImportRuleClassName = ^fileImportRuleName\+"Token";
      String importContextClassName = ^fileImportRuleName;
      silentRules.add(fileImportRuleName);
      Parser->Context += class importContextClassName / \FinalContext / {
          void _parse_root() {
            "parse_"+'fileImportRuleName'();
          }
        }
      Body fileNameStatement = new Body ();
      fileNameStatement.add(|StringBuilder _fileNameBuilder = new StringBuilder();|);
      input : parameter : import_parameter {
        parameter : element : quote {
          fileNameStatement.add(|"_fileNameBuilder".append('' 'element' '');|);
        }
        : ruleName {
          String importRuleName = 'element';
          importRuleNames.add(importRuleName);
          if importRuleNameTokens.add('importRuleName'\+"_token") {
            Parser->Context += ~String "_import_"+'importRuleName'+"_value" = null;
          }
          fileNameStatement.add(|"_fileNameBuilder".append("_import_"+'importRuleName'+"_value");|);
        }
      }
      fileNameStatement.add(|
        String _import_file_name = "_directoryName"\+"_fileNameBuilder".toString();
        if new File(_import_file_name).exists() {
          if Parser.contexts.containsKey(_import_file_name) == false {
            Parser->Context _import_context = new Parser->Context->'importContextClassName'(`newContextParameters`);
            Parser.contexts.put(_import_file_name,_import_context);
          }
          Parser.contexts.get(_import_file_name).set_root(new Token.Parsed(Token->Id.ROOT));
		  Parser.contexts.get(_import_file_name).set_token(Parser.contexts.get(_import_file_name).get_root());
		  "_token".add("_position",new Token->Parsed->Import(_import_file_name));
          \addImportThread(_import_file_name);
        }
        else {
          if "_position" >= "_furthestPosition" {
            "_result" = new Parser->Result->Fail("FAILED", "_position","_lineNumberRanges","_input", "_fileName", "_directoryName"\+"_fileNameBuilder".toString()\+'' " cannot be found!" '');
            "_furthestPosition" = "_position";
          }
          "_position" = "_position_"+'ruleName';
          "_state" = "FAILED";
		  System.err.println(''"Could not find file:"''\+"_directoryName"\+"_fileNameBuilder".toString());
        }|);
      \define(input->"import_definition",ruleName,parentRuleName, handleBracedTokenName, importRuleNames, {if "_state" == SUCCESS `fileNameStatement`}, rule);
      if rules.containsKey(fileImportRuleName) == false {
        completeRules.put(fileImportRuleName, new ArrayList<Body >());
        rules.put(fileImportRuleName, completeRules.get(fileImportRuleName));
        completeRules.get(fileImportRuleName).add(new Body ());
      }
      String nameWithResolve = "Resolve"\+'fileImportRuleName';
      Token->Id += void "_"+'fileImportRuleName';
      \declareResolverMapName(fileImportRuleName);
      Tokens->Rule += class fileImportRuleClassName / Token->Parsed /{
        Token->Id getName(){
          return Token->Id."_"+'fileImportRuleName';
        }
        ~String value = null;
        String getValue(){
          if value == null {
            return super.getValue();
          }
          else {
            return value;
          }
        }
        Token->Resolver getResolver(Token->ResolverMap map){
            return ((Token->ResolverMap->'nameWithResolve')\map)."resolve_"+'fileImportRuleName'();
        }
      }
      ruleForeBodies.put(fileImportRuleName, new Body ());
      List< Body > importRule = completeRules.get(fileImportRuleName);
      input : definition : definition {
        \define(definition,fileImportRuleName,ruleName, null, parentImportRuleNames, null, importRule);
      }
      return ruleName;
    }
    if input->"braced_parameters" != null {
      String left = 'input->"braced_parameters"->"left"';
      String right = 'input->"braced_parameters"->"right"';
      String both = left \+ right;
      Integer openLength = left.length();
      Integer closeLength = right.length();
      if declaredBraceValues.containsKey(both) == false {
        declaredBraceValues.put(both,new ArrayList<String>());
      }
      if input->"passConstraint" != null {
        declaredBracePasses.put(ruleName,Integer.parseInt('input->"passConstraint"'.trim()));
      }
      declaredBraceValues.get(both).add(ruleName);
      declaredBraceRules.put(ruleName,both);
      declaredBraceOpenLengths.put(ruleName,openLength);
      declaredBraceCloseLengths.put(ruleName,closeLength);
      if declaredBraces.add(both) {
        Integer braceId = braceIds.size();
        braceIds.put(both,braceId);
        if declaredBraceOpenValues.containsKey(left.length()) == false {
          declaredBraceOpenValues.put(left.length(),new HashMap<String,List<Integer>>());
        }
        if declaredBraceOpenValues.get(left.length()).containsKey(left) == false {
          declaredBraceOpenValues.get(left.length()).put(left,new ArrayList<Integer>());
        }
        declaredBraceOpenValues.get(left.length()).get(left).add(braceId);
        if declaredBraceCloseValues.containsKey(right.length()) == false {
          declaredBraceCloseValues.put(right.length(),new HashMap<String,List<Integer>>());
        }
        if declaredBraceCloseValues.get(right.length()).containsKey(right) == false {
          declaredBraceCloseValues.get(right.length()).put(right,new ArrayList<Integer>());
        }
        declaredBraceCloseValues.get(right.length()).get(right).add(braceId);
        Parser->Context += ~Map<Integer, Integer> "brace_"+'braceId' = new HashMap<Integer, Integer>();
        Parser->Context->*"parse".prependToBody(|Stack<Integer> "brace_open_"+'braceId' = new Stack<Integer>(); |);
      }
    }
    input : definition : definition {
      \define(definition,ruleName,parentRuleName, handleBracedTokenName, rule);
    }
    return ruleName;
  }
> void define(%T definition,String ruleName, String parentRuleName, String handleBracedTokenName, List<Body > inputRule){
    \define(definition,ruleName,parentRuleName,handleBracedTokenName,null,null, inputRule);
  } 
> void define(%T definition,String ruleName, String parentRuleName, String handleBracedTokenName,Set<String> importRuleNames, Body importFileNameBody, List<Body > inputRule){
    ~Boolean isFirst = true;
    String ruleAsClass = ^ruleName\+"Token"; 
    Integer choiceIndex = inputRule.size() \- 1;
    ~Body rule = inputRule.get(choiceIndex);
    ~Body nextBody = null;
    String currentPositionValue = "_position_"\+ruleName;
    String currentTokenValue = "_token_"\+ruleName;
    rule.add(|'currentPositionValue' = "_position";|);
    rule.add(|'currentTokenValue' = "_token";|);
    if silentRules.contains(ruleName) == false {
      rule.add(|"_token" = new Tokens->Rule->'ruleAsClass'();|);
    }
    else {
      if handleBracedTokenName != null {
        rule.add(|"_token" = new Tokens->Name->'handleBracedTokenName'();|);
      }
      else if(ruleName.startsWith("_anonymous")){
        rule.add(|"_token" = new Token->Parsed(Token->Id.ANON);|);
      }
      else {
        rule.add(|"_token" = new Tokens->Rule->'ruleAsClass'();|);
      }
    }
    Body foreBody = ruleForeBodies.get(ruleName);
    definition : chain : chain {
      chain : element : element {
        Body elementBody = \encloseRuleByMultiple(element->"multiple",ruleName,rule);
        \parseElement(element, ruleName, parentRuleName, elementBody, choiceIndex ,importRuleNames,isFirst);
        isFirst = false;
        nextBody = new Body ();
        Body realNextBody = nextBody;
        rule.add(|if "_state" == "FAILED" `foreBody` else `realNextBody` |);
        rule = nextBody;
      }
    }
    if importFileNameBody != null {
      inputRule.get(inputRule.size() \- 1).add(importFileNameBody);
    }
    if silentRules.contains(ruleName) == false || handleBracedTokenName != null {
      inputRule.get(inputRule.size() \- 1).add(|
        if "_state" == "SUCCESS" {
          'currentTokenValue'.add('currentPositionValue',"_token");
        }|);
      if handleBracedTokenName!=null && importRuleNames != null && importRuleNames.contains(handleBracedTokenName) {
        inputRule.get(inputRule.size() \- 1).add(|
          if "_state" == "SUCCESS" {
            "_import_"+'handleBracedTokenName'+"_value" = "_token".getValue();
          }|);
      }
      else if importRuleNames != null && importRuleNames.contains(ruleName) {
        inputRule.get(inputRule.size() \- 1).add(|
          if "_state" == "SUCCESS" {
            "_import_"+'ruleName'+"_value" = "_token".getValue();
          }|);
      }
      inputRule.get(inputRule.size() \- 1).add(|
        "_token" = 'currentTokenValue';|);
    }
    else {
      inputRule.get(inputRule.size() \- 1).add(|
        if "_state" == "SUCCESS" {
          'currentTokenValue'.addAll("_token");
          'currentTokenValue'.setValue("_token".getValue());
        }
        "_token" = 'currentTokenValue';|);
    }
    if definition->"choice" != null {
      inputRule.add(new Body ());
      \define(definition->"choice"->"definition",ruleName,parentRuleName,handleBracedTokenName,inputRule);
    }
  }
> ~Integer multipleIndex = 0;
> Body encloseRuleByMultiple(%T multiple, String ruleName, Body rule) {
    if multiple == null {
      return rule;
    }
    if handleListAdditionAftBodies.containsKey(ruleName) == false {
      handleListAdditionAftBodies.put(ruleName,new Body ());
    }
    Body aftBody = new Body ();
    Body resultBody = new Body ();
    String stateName = "_state_"\+multipleIndex;
    multiple : option : OPTIONAL {
      rule.add(|\int 'stateName' = "_state";|);
      rule.add(resultBody);
      rule.add(aftBody);
      rule.add(|if 'stateName' == "SUCCESS" && "_state" == "FAILED" {
        "_state" = "SUCCESS";}|);
    }
    : MANY {
      rule.add(|\int 'stateName' = "_state";|);
      Body whileRuleBody = new Body ();
      rule.add(| while"_position" < "_inputLength" `whileRuleBody` |);
      whileRuleBody.add(resultBody);
      Body breakAftBody = new Body ();
      breakAftBody.add(aftBody);
      breakAftBody.add(|"break";|);
      whileRuleBody.add(|if "_state" == "FAILED" `breakAftBody` |);
      Body afterMultipleBody = new Body ();
      afterMultipleBody.add(aftBody);
      afterMultipleBody.add(|"_state" = "SUCCESS";|); 
      rule.add(|
        if 'stateName' == "SUCCESS" && "_state" == "FAILED" `afterMultipleBody`|);
    }
    : PLUS {
      String multipleValueName = "_iteration_achieved_"\+multipleIndex;
      rule.add(|\int 'stateName' = "_state";|);
      rule.add(|boolean 'multipleValueName' = false;|);
      Body breakAftBody = new Body ();
      breakAftBody.add(aftBody);
      breakAftBody.add(|"break";|);
      Body whileRuleBody = new Body ();
      whileRuleBody.add(resultBody);
      whileRuleBody.add(|if "_state" == "FAILED" `breakAftBody`
        else {
          'multipleValueName' = true;
        }|);
      rule.add(| while "_position" < "_inputLength" `whileRuleBody` |);
      Body noIterationFailBody = new Body ();
      noIterationFailBody.add(aftBody);
      noIterationFailBody.add(|"_state" = "FAILED";|);
      rule.add(|
        if 'multipleValueName' == false `noIterationFailBody`
        else if 'stateName' == "SUCCESS" && "_state" == "FAILED" {
          "_state" = "SUCCESS";
        }|);
    }
    multipleIndex \+= 1;
    return resultBody;
  }
> ~Integer recursionIndex = 0;
> void parseElement(%T element, String ruleName, String parentRuleName, Body rule, Integer choiceIndex,Set<String> importRuleNames, Boolean isFirst){
    element : query : braced_definition {
      String handleBracedTokenName;
      if element->"newName" != null {
        String newTokenName = ^element->"newName" \+ "Token";
        String simpleTokenName = 'element->"newName"';
        \declareNamedToken(newTokenName,simpleTokenName);
        handleBracedTokenName = newTokenName;
      }
      else if element->"listName"!=null {
        handleBracedTokenName = ^element->"listName"\+"Token";
      }
      else {
        handleBracedTokenName = null;
      }
      String subRuleName = \define(query, parentRuleName, handleBracedTokenName, importRuleNames);
      rule.add(|"parse_"+'subRuleName'();|);
      if element->"listName"!=null {
        rule.add(|if "_state" == "SUCCESS" {
          String _value = "_token".getLastValue();
          if _value!=null {
            'element->"listName"'.add(_value);
          }
        }|);
        if listNamesInRule.containsKey(parentRuleName) == false {
          listNamesInRule.put(parentRuleName, new HashSet<String>());
        }
        listNamesInRule.get(parentRuleName).add('element->"listName"');
        handleListAdditions.put(ruleName, parentRuleName);
        if handleListAdditionAftBodies.containsKey(ruleName) == false {
          handleListAdditionAftBodies.put(ruleName,new Body ());
        }
      }
    } 
    : quoteToken {
      String quote = 'element->"quoteToken"->"quote"';
      ~Integer quoteLength = quote.length();
      Body subrule = new Body ();
      StringBuilder quoteValue = new StringBuilder();
      ~Integer ip = 0; 
      for Integer i < quote.length() {
        String ch;
        String quoteChar = quote.charAt(i)\+""; 
        if quoteChar.equals("\\") {
          if i\+1 < quote.length() {
            String nextChar = quote.charAt(i\+1)\+"";
            if nextChar.equals("t") {
              ch = "\'\\t'"; 
              quoteValue.append("\\t");
              quoteLength \-= 1;
              i\+=1;
            }
            else if nextChar.equals("n") {
              ch = "\'\\n'"; 
              quoteValue.append("\\n");
              quoteLength \-= 1;
              i\+=1;
            }
            else if nextChar.equals("r") {
              ch = "\'\\r'"; 
              quoteValue.append("\\r");
              quoteLength \-= 1;
              i\+=1;
            }
            else if nextChar.equals("\"") {
              ch = "\'\"'"; 
              quoteValue.append("\"");
              quoteLength \-= 1;
              i\+=1;
            }
            else if nextChar.equals("\'") {
              ch = "\'\\\'\'"; 
              quoteValue.append("\'");
              quoteLength \-= 1;
              i\+=1;
            }
            else if nextChar.equals("\\") {
              ch = "\'\\\\\'"; 
              quoteValue.append("\\\\");
              quoteLength \-= 1;
              i\+=1;
            }
            else {
              ch = "\'\\\\\'"; 
              quoteValue.append("\\\\");
            }
          }
          else {
            ch = "\'\\\\\'"; 
            quoteValue.append("\\\\");
          }
        }
        else if quoteChar.equals("'") {
          ch = "\'\\\'\'"; 
          quoteValue.append("\\'");
        }
        else {
          ch = "\'"\+quote.charAt(i)\+"\'";
          quoteValue.append(quote.charAt(i));
        }
        String ipValue = 'ip';
        if ch.equals("\'\\n'") {
          subrule.add(|if "_inputArray"[ "_position+"+'ipValue' ] != 'ch' && "_inputArray"[ "_position+"+'ipValue' ] != "\'\\r'" {
            "_state" = "FAILED";
          }|);
        }
        else {
          subrule.add(|if "_inputArray"[ "_position+"+'ipValue' ] != 'ch' {
            "_state" = "FAILED";
          }|);
        }
        ip \+= 1;
      }
      rule.add(|if "_position" \+ 'quoteLength' \- 1 >= "_inputLength"  {
          "_state" = "FAILED";
        }
        else `subrule`
        |);
      
      Integer quoteLengthValue = quoteLength;
      if createdSyntaxTokens.containsKey(quote) == false {
        String quoteName = "syntax_"\+plainTokenIndex;
        plainTokenIndex \+= 1;
        createdSyntaxTokens.put(quote,quoteName);
        createdSyntaxNameTokens.put(quote,new HashSet<String>());
        Tokens->Syntax += class quoteName / Token->Parsed / {
          @Tokens->Syntax->'quoteName' SYNTAX = new Tokens->Syntax->'quoteName'(Token->Id.SYNTAX);
          String getValue(){
            return '' 'quote.replace("\\","\\\\")' '';
          }
          void setValue(String newValue){
          }
          Token->Resolver getResolver(Token->ResolverMap map){
            return "((Token.ResolverMap.SYNTAX)map).SYNTAX()";
          }
        }
      }
      String quoteName = createdSyntaxTokens.get(quote);
      String newTokenName;
      if element->"newName" != null {
        newTokenName = 'element->"newName"';
        if createdSyntaxNameTokens.get(quote).add(newTokenName) {
          Token->Id += void "_"+'newTokenName';
          \declareResolverMapName(newTokenName);
          Tokens->Syntax->'quoteName' += @Token->Parsed 'newTokenName' = "new Tokens.Syntax."+'quoteName'+"(Token.Id._"+'newTokenName'+"){public Token.Resolver getResolver(Token.ResolverMap map){return ((Token.ResolverMap.Resolve"+'newTokenName'+")map).resolve_"+'newTokenName'+"();}}";
        }
      }
      else {
        newTokenName = "SYNTAX";
      }
      rule.add(|
        if "_state" == "SUCCESS" {
          "_token".add("_position",Tokens->Syntax->'quoteName'->'newTokenName');
          "_position" = "_position" \+ 'quoteLengthValue';
          while `ruleIgnoresHeaders.get(ruleName)` {
            "++_position";
          }
        }
        else if "_state" == "FAILED" {
          if "_position" >= "_furthestPosition" {
            "_result" = new Parser->Result->Fail("FAILED", "_position","_lineNumberRanges","_input", "_fileName", '' "unexpected plain "+'quoteValue' '');
            "_furthestPosition" = "_position";
          }
        }|);
      if importRuleNames != null && importRuleNames.contains(newTokenName) {
        rule.add(|
          if "_state" == "SUCCESS" {
            "_import_"+'newTokenName'+"_value" = "_token".getLastValue();
          }|);
      }
    }
    : regexToken {
      %T regex = element->"regexToken"->"regex";
      String currentPositionValue = "_position_regex_"\+currentPositionIndex;
      StringBuilder regexValue = new StringBuilder();
      rule.add(|\int 'currentPositionValue' = "_position";|);
      regex : regexElement : regex_element {
        regexValue.append(\addRegexElementToRule(regexElement,rule,currentPositionValue));
      }
      if listPreparers.contains(ruleName) {
        ~int currentStateOfPreparer = 0;
        Class preparerClass = Parser->NameList->Builder->'ruleName';
        Body switchBody = new Body ();
        regex : regexElement : regex_element {
          switchBody.add(\getRegexForPreparer(regexElement,ruleName,preparerClass,currentStateOfPreparer));
          currentStateOfPreparer \+= 1;
        }
        preparerClass->*"can".appendToBody(|switch "state" `switchBody` return false;|);
      }
      currentPositionIndex \+= 1;
      
      if element->"newName" != null {
        String newTokenName = ^element->"newName";
        if createdPlainTokens.add(newTokenName) {
          Token->Id += void "_"+'newTokenName';
          \declareResolverMapName(newTokenName);
          String nameWithResolve = "Resolve"\+'newTokenName';
          Tokens->Plain += class newTokenName /  Token->Parsed / {
            String value = null;
            Token->Id getName(){
              return Token->Id."_"+'newTokenName';
            }
            Token->Resolver getResolver(Token->ResolverMap map){
              return ((Token->ResolverMap->'nameWithResolve')\map)."resolve_"+'newTokenName'();
            }
          }
        }
        if element->"listName" != null {
          rule.add(|if "_state" == "SUCCESS" {
            "_token".add('currentPositionValue',new Tokens->Plain->'newTokenName'("_input".substring('currentPositionValue',"_position")));
            'element->"listName"'.add("_input".substring('currentPositionValue',"_position"));
            while `ruleIgnoresHeaders.get(ruleName)` {
              "++_position";
            }
          }|);
          if listNamesInRule.containsKey(parentRuleName) == false {
            listNamesInRule.put(parentRuleName, new HashSet<String>());
          }
          listNamesInRule.get(parentRuleName).add('element->"listName"');
          handleListAdditions.put(ruleName, parentRuleName);
          if handleListAdditionAftBodies.containsKey(ruleName) == false {
            handleListAdditionAftBodies.put(ruleName,new Body ());
          }
        }
        else {        
          rule.add(|if "_state" == "SUCCESS" {
            "_token".add('currentPositionValue',new Tokens->Plain->'newTokenName'("_input".substring('currentPositionValue',"_position")));
            while `ruleIgnoresHeaders.get(ruleName)` {
              "++_position";
            }
          }|);
        }
        if importRuleNames != null && importRuleNames.contains(newTokenName) {
          rule.add(|
            if "_state" == "SUCCESS" {
              "_import_"+'newTokenName'+"_value" = "_token".getLastValue();
            }|);
        }
      }
      else {
        rule.add(|if "_state" == "SUCCESS" {
            "_token".setValue("_input".substring('currentPositionValue',"_position"));
            while `ruleIgnoresHeaders.get(ruleName)` {
              "++_position";
            }
          }|);
      }
      rule.add(|
        if "_state" == "FAILED" {
          if "_position" >= "_furthestPosition" {
            "_result" = new Parser->Result->Fail("FAILED", "_position","_lineNumberRanges","_input", "_fileName", '' 'regexValue.toString().replace("\\","\\\\").replace("\"","\\\"").replace("\'","\\\'")' '');
            "_furthestPosition" = "_position";
          }
          "_position" = 'currentPositionValue';
        }|);
    }
    : ruleToken {
      if listNames.contains('query'){
        String listName = 'query';
        String newTokenClassName;
        String newTokenName;
        
        if element->"newName" != null {
          newTokenClassName = ^element->"newName"\+"Token";
          newTokenName = 'query';
        }
        else {
          newTokenClassName = ^query\+"Token";
          newTokenName = 'query';
        }
        \declareNamedToken(newTokenClassName,newTokenName);
        Body listRuleBody;
        if listFirstPassRules.containsKey('listName') {
          String passRuleName = ^listFirstPassRules->listName \+ "Token";
          listRuleBody = new Body ();
          \declareNamedToken(passRuleName,listFirstPassRules.get(listName));
          rule.add(|
            if "_pass" == "FIRST_PASS" { 
              String _result = "_preparsed_"+'listFirstPassRules.get(listName)'.get("_position");
              if _result == null {
                "_state" = "FAILED";
              }
              else {
                Token->Parsed _first_pass_token = new Tokens->Name->'passRuleName'(_result);
                "_token".add("_position",_first_pass_token);
                "_position" \+= "_result".length();
                while `ruleIgnoresHeaders.get(ruleName)` {
                  "++_position";
                }
              }
            }
            else if "_pass" == "SECOND_PASS" `listRuleBody`|);
        }
        else {
          listRuleBody = rule;
        }
        String isNameableCharacter = "_next_char == 95 || (_next_char >= 48 && _next_char <= 57 ) || (_next_char >= 65 && _next_char <= 90 ) || (_next_char >= 97 && _next_char <= 122 )"; 
        listRuleBody.add(|
          "_list_name_result" = "_preparsed_"+'listFirstPassRules.get(listName)'.get("_position");
          if "_list_name_result" != null && 'listName'.contains("_list_name_result") {
            if "_position"\+"_list_name_result".length() < "_inputLength" {
              int _next_char = "_inputArray"["_position"\+"_list_name_result".length()];
              if 'isNameableCharacter' {
                "_state" = "FAILED";
              }
            }
            if "_state" == "SUCCESS" {
              "_token".add("_position",new Tokens->Name->'newTokenClassName'("_list_name_result"));
              "_position" \+= "_list_name_result".length();
              while `ruleIgnoresHeaders.get(ruleName)` {
                "++_position";
              }
            }
          }
          else {
            "_state" = "FAILED";
          }
          if "_state" == "FAILED" {
            if "_position" >= "_furthestPosition" {
              "_result" = new Parser->Result->Fail("FAILED", "_position","_lineNumberRanges","_input", "_fileName", '' 'listName' '');
              "_furthestPosition" = "_position";
            }
          }|);
      }
      else {
        String subRuleName = 'query';
        ~Boolean protectAgainstRecursion = false;
        String exceptionMessage = " : rule not found!";
        if ruleHeirachy.containsKey(subRuleName) == false {
          throw "+subRuleName+exceptionMessage+";
        }
        if isFirst {
          protectAgainstRecursion = ruleHeirachy.get(subRuleName).contains(parentRuleName);
        }
        if element->"newName" != null && element->"listName" == null{
          String newTokenName = 'element->"newName"';
          String newTokenClassName = ^newTokenName \+ "Token";
          \declareNamedToken(newTokenClassName, newTokenName);
          \declareSubRuleTokenInRule(ruleName,subRuleName,rule);
          rule.add(|
            "_token" = new Tokens->Name->'newTokenClassName'();|);
          \declarePosition(rule,ruleName,subRuleName);
        }
        else if protectAgainstRecursion {
          \declarePosition(rule,ruleName,subRuleName);
        }
        if protectAgainstRecursion {
          Integer recursionIndexValue = recursionIndex;
          recursionIndex \+= 1;
          String recursionVariableName = "_recursion_protection_"\+'subRuleName'\+"_"\+'recursionIndexValue';
          Parser->Context += ~Set<Integer> 'recursionVariableName' = new HashSet<Integer>();
          rule.add(|
            if "_state" == "SUCCESS" &&! 'recursionVariableName'.contains("_position") {
              'recursionVariableName'.add("_position");
              "parse_"+'subRuleName'();
              'recursionVariableName'.remove("_position_"+'subRuleName');
            }
            else {
              "_state" = "FAILED";
            }|);
        }
        else {
          rule.add(|"parse_"+'subRuleName'();|);
        }
        if element->"newName" != null && element->"listName" == null{
          rule.add(|
            if "_state" == "SUCCESS" {
              "_token_"+'subRuleName'.add("_position_"+'subRuleName',"_token");
            }|);
          if importRuleNames != null && importRuleNames.contains('element->"newName"') {
            rule.add(|
              if "_state" == "SUCCESS" {
                "_import_"+'element->"newName"'+"_value" = "_token".getValue();
              }|);
          }
          rule.add(|
            "_token" = "_token_"+'subRuleName';|);
        }
        else if importRuleNames != null && importRuleNames.contains(subRuleName) {
          rule.add(|
            if "_state" == "SUCCESS" {
              "_import_"+'subRuleName'+"_value" = "_token".getLastValue();
            }|);
        }
        if element->"listName"!=null {
          String listTokenName;
          if element->"newName" != null {
            listTokenName = ^element->"newName" \+ "Token";
            String simpleTokenName = 'element->"newName"';
            \declareNamedToken(listTokenName, simpleTokenName);
          }
          else {
            listTokenName = ^element->"listName"\+"Token";
          }
          rule.add(|if "_state" == "SUCCESS" {
            String _value = "_token".getLastValue();
            if _value!=null  {
              'element->"listName"'.add(_value);
            }
            "_token".add("_position",new Tokens->Name->'listTokenName'(_value));
          }|);
          if listNamesInRule.containsKey(parentRuleName) == false {
            listNamesInRule.put(parentRuleName, new HashSet<String>());
          }
          listNamesInRule.get(parentRuleName).add('element->"listName"');
          handleListAdditions.put(ruleName, parentRuleName);
          if handleListAdditionAftBodies.containsKey(ruleName) == false {
            handleListAdditionAftBodies.put(ruleName,new Body ());
          }
        }
      }
    }
  }
> ~Integer groupSuccessfulPositionIndex = 0;
> String addRegexElementToRule(%T element, Body rule, String positionName){
    String groupSuccessfulPositionName = "_position_of_last_success_" + groupSuccessfulPositionIndex;
    groupSuccessfulPositionIndex \+= 1;
    if element->"option" != null {
      StringBuilder regexValue = new StringBuilder();
      regexValue.append("[");
      Statement option = new Statement ();
      if element->"option"->"negate" == null {
        option.set("||");
        %T optionToken = element->"option";
        optionToken : atom : range {
          Character ch = 'atom->"left"'.charAt(0);
          Integer end = 'atom->"right"'.charAt(0) -  ch;
          for Integer i <= end {
            String chValue = "'" + ((char)(ch + i)) + "'";
            option.add(|"_inputArray[_position]" == 'chValue'|);
          }
          regexValue.append('atom->"left"');
          regexValue.append("-");
          regexValue.append('atom->"right"');
        }
        : regex_special {
          atom : quark : number {
            Character ch = "0".charAt(0);
            Integer end = "9".charAt(0) -  ch;
            for Integer i <= end {
              String chValue = "'" + (char)(ch + i) + "'";
              option.add(|"_inputArray[_position]" == 'chValue'|);
            }
            regexValue.append("\\\\d");
          }
          : whitespace {
            option.add(|"_inputArray[_position]" == "' '"|);
            option.add(|"_inputArray[_position]" == "'\\t'"|);
            option.add(|"_inputArray[_position]" == "'\\r'"|);
            option.add(|"_inputArray[_position]" == "'\\n'"|);
            regexValue.append("\\\\s");  
          }
          : quote {
            option.add(|"_inputArray[_position]" == char\"|);
            regexValue.append("\\\"");  
          }
          : escaped {
            option.add(|"_inputArray[_position]" == "'\\"+'quark'+"'"|);
            regexValue.append("\\"\+'quark');
          }
          : dot {
            option.add(|"_inputArray[_position]" == "'.'"|);
            regexValue.append("\\.");  
          }
          : slash {
            option.add(|"_inputArray[_position]" == "'\\\\'"|);
            regexValue.append("\\\\");  
          }
        }
        : standAlone {
          String ch;
          String quoteChar = 'atom'; 
          if quoteChar.equals("\\") {
            ch = "\\\\"; 
          }
          else if quoteChar.equals("\"") {
            ch = "\\\""; 
          }
          else {
            ch = 'atom';
          }
          option.add(|"_inputArray[_position]" == "'"+'ch'+"'"|);
          regexValue.append('atom');
        }
      }
      else {
        option.set("&&");
        %T optionToken = element->"option";
        optionToken : atom : range {
          Character ch = 'atom->"left"'.charAt(0);
          Integer end = 'atom->"right"'.charAt(0) -  ch;
          for Integer i <= end {
            String chValue = "'" + (char)(ch + i) + "'";
            option.add(|"_inputArray[_position]" != 'chValue'|);
          }
          regexValue.append('atom->"left"');
          regexValue.append("-");
          regexValue.append('atom->"right"');
        }
        : regex_special {
          atom : quark : number {
            Character ch = "0".charAt(0);
            Integer end = "9".charAt(0) -  ch;
            for Integer i <= end {
              String chValue = "'" + (char)(ch + i) + "'";
              option.add(|"_inputArray[_position]" != 'chValue'|);
            }
            regexValue.append("\\\\d");
          }
          : whitespace {
            option.add(|"_inputArray[_position]" != "' '"|);
            option.add(|"_inputArray[_position]" != "'\\t'"|);
            option.add(|"_inputArray[_position]" != "'\\r'"|);
            option.add(|"_inputArray[_position]" != "'\\n'"|);
            regexValue.append("\\\\s");  
          }
          : escaped {
            option.add(|"_inputArray[_position]" != "'\\"+'quark'+"'"|);
            regexValue.append("\\"\+'quark');
          }
          : dot {
            option.add(|"_inputArray[_position]" != "'.'"|);
            regexValue.append("\\.");  
          }
          : slash {
            option.add(|"_inputArray[_position]" != "'\\\\'"|);
            regexValue.append("\\\\");  
          }
        }
        : standAlone {
          String ch;
          String quoteChar = 'atom'; 
          if quoteChar.equals("\\") {
            ch = "\\\\"; 
          }
          else if quoteChar.equals("\"") {
            ch = "\\\""; 
          }
          else if quoteChar.equals("\'") {
            ch = "\\\'"; 
          }
          else {
            ch = 'atom';
          }
          option.add(|"_inputArray[_position]" != "'"+'ch'+"'"|);
          regexValue.append('atom');
        }
      }
      if element->"multiple" != null {
        String multipleValueName = "_multiple_index_"\+multipleIndex;
        multipleIndex \+= 1;
        if element->"multiple"->"OPTIONAL" != null {
          rule.add(|
            if "_position" < "_inputLength" {
              if `option` {
                "++_position";
              }
            }
          |);
        }
        else if element->"multiple"->"MANY" != null {
          rule.add(|
            while "_position" < "_inputLength" {
              if `option` {
                "++_position";
              }
              else {
                "break";
              }
            }
          |);
        }
        else if element->"multiple"->"PLUS" != null{
          rule.add(|
            \int 'multipleValueName' = 0;
            while "_position" < "_inputLength" {
              if `option` {
                "++_position";
                "++"+'multipleValueName';
              }
              else {
                "break";
              }
            }
            if 'multipleValueName' == 0 {
              "_state" = "FAILED";
            }
          |);
        }
      }
      else {
        rule.add(|
          if "_position" < "_inputLength" {
            if `option` {
              "++_position";
            }
            else {
              "_state" = "FAILED";
            }
          }
          else {
            "_state" = "FAILED";
          }
        |);
      }
      regexValue.append("]");
      if element->"multiple" != null {
      if element->"multiple"->"OPTIONAL" != null {
        regexValue.append("?");
      }
      else if element->"multiple"->"MANY" != null {
        regexValue.append("*");
      }
      else if element->"multiple"->"PLUS" != null {
        regexValue.append("+");
      }
      }
      return 'regexValue';
    }
    else {
      StringBuilder regexValue = new StringBuilder();
      Body regexBody;
      String multipleValueName;
      String stateName;
      if element->"multiple" != null {
        multipleValueName = "_multiple_index_"\+multipleIndex;
        stateName = "_state_"\+multipleIndex;
        multipleIndex \+= 1;
        String multipleValueLimit;
        if element->"multiple"->"OPTIONAL" != null {
          multipleValueLimit = "1";
        }
        else {
          multipleValueLimit = "Integer.MAX_VALUE";
        }
        regexBody = new Body ();
        if element->"multiple"->"PLUS" != null{
          rule.add(|
            \int 'multipleValueName' = 0;
            \int 'stateName' = "_state";
            while "_position" < "_inputLength" `regexBody`
          |);
        }
        else {
          if element->"multiple"->"OPTIONAL" != null {
            rule.add(|
              \int 'stateName' = "_state";
              if "_position" < "_inputLength" `regexBody`
            |);
          }
          else if element->"multiple"->"MANY" != null {
            rule.add(|
              \int 'multipleValueName' = 0;
              \int 'stateName' = "_state";
              while "_position" < "_inputLength" `regexBody`
            |);
          }
        }
      }
      else {
        regexBody = rule;
        multipleValueName = null;
        stateName = null;
      }
      if element->"regex_special" != null {
        Statement option = new Statement ();
        option.set("||");
        element->"regex_special" : quark : number {
          Character ch = "0".charAt(0);
          Integer end = "9".charAt(0) -  ch;
          for Integer i <= end {
            String chValue = "'" + (char)(ch + i) + "'";
            option.add(|"_inputArray[_position]" == 'chValue'|);
          }
          regexValue.append("\\\\d");
        }
        : whitespace {
          option.add(|"_inputArray[_position]" == "' '"|);
          option.add(|"_inputArray[_position]" == "'\\t'"|);
          option.add(|"_inputArray[_position]" == "'\\r'"|);
          option.add(|"_inputArray[_position]" == "'\\n'"|);
          regexValue.append("\\\\s");  
        }
        : escaped {
          option.add(|"_inputArray[_position]" == "'\\"+'quark'+"'"|);
          regexValue.append("\\"\+'quark');
        }
        : dot {
          option.add(|"_inputArray[_position]" == "'.'"|);
          regexValue.append("\\.");  
        }
        : slash {
          option.add(|"_inputArray[_position]" == "'\\\\'"|);
          regexValue.append("\\\\");  
        }
        regexBody.add(|
          if "_position" < "_inputLength" {
            if `option` {
              "++_position";
            }
            else {
              "_state" = "FAILED";
            }
          }
          else {
            "_state" = "FAILED";
          }|);
      }
      
      if element->"character" != null {
        if 'element->"character"'.equals("."){
          regexBody.add(|
            if "_position" < "_inputLength" {
              "++_position";
            }
            else {
              "_state" = "FAILED";
            }|);
        }
        else {
          regexBody.add(|
            if "_position" < "_inputLength" {
              if "_inputArray[_position]" == "'"+'element->"character"'+"'" {
                "++_position";
              }
              else {
                "_state" = "FAILED";
              }
            }
            else {
              "_state" = "FAILED";
            }|);
        }
        regexValue.append('element->"character"');
      }
      else if element->"group" != null {
        String op = "(";
        String cp = ")";
        regexValue.append(op);
        %T regexToken = element->"group"->"regex";
        regexBody.add(|int 'groupSuccessfulPositionName' = "_position"; |);
        regexToken : regexElement : regex_element {
          regexValue.append(\addRegexElementToRule(regexElement, regexBody, positionName));
        }
      }
      if element->"multiple" != null {
        if element->"multiple"->"PLUS" != null{
          if element->"group" != null {
            regexBody.add(|
              if "_state" == "FAILED" {
                "_position" = 'groupSuccessfulPositionName';
                "break";
              }
              else {
                "++"+'multipleValueName';
                'groupSuccessfulPositionName' = "_position";
              }|);
          }
          else {
            regexBody.add(|
              if "_state" == "FAILED" {
                "break";
              }
              else {
                "++"+'multipleValueName';
              }|);
          }
          rule.add(|
            if 'stateName' == "SUCCESS" && 'multipleValueName' > 0 {
              "_state" = "SUCCESS";
            }
            else {
              "_state" = "FAILED";
            }
          |);
          regexValue.append("+");
        }
        else {
          if element->"multiple"->"OPTIONAL" != null {
            regexValue.append("?");
            if element->"group" != null {
              regexBody.add(|
                if "_state" == "FAILED" {
                  "_position" = 'groupSuccessfulPositionName';
                }|);
            }
          }
          else if element->"multiple"->"MANY" != null {            
            if element->"group" != null {
              regexBody.add(|
                if "_state" == "FAILED" {
                  "_position" = 'groupSuccessfulPositionName';
                  "break";
                }
                else {
                  "++"+'multipleValueName';
                  'groupSuccessfulPositionName' = "_position";
                }|);
            }
            else {
              regexBody.add(|
                if "_state" == "FAILED" {
                  "break";
                }
                else {
                  "++"+'multipleValueName';
                }|);
            }
            regexValue.append("*");
          }
          rule.add(|
            if 'stateName' == "SUCCESS" {
              "_state" = "SUCCESS";
            }|);
        }
      }
      return 'regexValue';
    }
  }
> Body getRegexForPreparer(%T element, String ruleName, Class preparerClass, Integer preparerState) {
    Integer nextPreparerState = preparerState \+ 1;
    Body resultBody = new Body ();
    Body regex = new Body ();
    resultBody.add(|case 'preparerState' `regex`|);
    Statement option = new Statement ();
    ~%T optionToken = null;
    ~String lowerBoundOperator = ">=";
    ~String upperBoundOperator = "<=";
    ~String unionOperator = "&&";
    ~String equalityOperator = "==";
    option.set("||");
    if element->"option" != null {
      if element->"option"->"negate" != null {
        lowerBoundOperator = "<=";
        upperBoundOperator = ">=";
        unionOperator = "||";
        equalityOperator = "!=";
        option.set("&&");
      }
      optionToken = element->"option";
    }
    else if element->"regex_special" != null {
      optionToken = element->"regex_special";
    }
    else if element->"character" != null {
      optionToken = element;
    }
    optionToken : atom
    : range {
      Character begin = 'atom->"left"'.charAt(0);
      Character end = 'atom->"right"'.charAt(0);
      Statement rangeStatement = new Statement (unionOperator);
      Statement leftSideStatement = new Statement ( lowerBoundOperator );
      leftSideStatement.add(|"nextChar"|);
      leftSideStatement.add(|"\'"+'begin'+"\'"|);
      Statement rightSideStatement = new Statement ( upperBoundOperator );
      rightSideStatement.add(|"nextChar"|);
      rightSideStatement.add(|"\'"+'end'+"\'"|);
      rangeStatement.add(leftSideStatement);
      rangeStatement.add(rightSideStatement);
      option.add(|(`rangeStatement`)|);
    }
    : regex_special {
      atom : quark : number {
        Character begin = "0".charAt(0);
        Character end = "9".charAt(0);
        Statement rangeStatement = new Statement (unionOperator);
        Statement leftSideStatement = new Statement ( lowerBoundOperator );
        leftSideStatement.add(|"nextChar"|);
        leftSideStatement.add(|"\'"+'begin'+"\'"|);
        Statement rightSideStatement = new Statement ( upperBoundOperator );
        rightSideStatement.add(|"nextChar"|);
        rightSideStatement.add(|"\'"+'end'+"\'"|);
        rangeStatement.add(leftSideStatement);
        rangeStatement.add(rightSideStatement);
        option.add(|(`rangeStatement`)|);
      }
      : whitespace {
        Statement whitespaceStatement = new Statement (unionOperator);
        ~Statement statement = new Statement (equalityOperator);
        statement.add(|"nextChar"|);
        statement.add(|"' '"|);
        whitespaceStatement.add(statement);
        statement = new Statement (equalityOperator);
        statement.add(|"nextChar"|);
        statement.add(|"'\\t'"|);
        whitespaceStatement.add(statement);
        statement = new Statement (equalityOperator);
        statement.add(|"nextChar"|);
        statement.add(|"'\\r'"|);
        whitespaceStatement.add(statement);
        statement = new Statement (equalityOperator);
        statement.add(|"nextChar"|);
        statement.add(|"'\\n'"|);
        whitespaceStatement.add(statement);
        option.add(|(`whitespaceStatement`)|);
      }
      : escaped {
        Statement statement = new Statement (equalityOperator);
        statement.add(|"nextChar"|);
        statement.add(|"'\\"+'quark'+"'"|);
        option.add(statement);
      }
      : dot {
        Statement statement = new Statement (equalityOperator);
        statement.add(|"nextChar"|);
        statement.add(|"'.'"|);
        option.add(statement); 
      }
      : slash {
        Statement statement = new Statement (equalityOperator);
        statement.add(|"nextChar"|);
        statement.add(|"'\\\\'"|);
        option.add(statement);
      }
    }
    : standAlone {
      String ch;
      String quoteChar = 'atom'; 
      if quoteChar.equals("\\") {
        ch = "\\\\"; 
      }
      else if quoteChar.equals("\"") {
        ch = "\\\""; 
      }
      else {
        ch = 'atom';
      }
      Statement statement = new Statement (equalityOperator);
      statement.add(|"nextChar"|);
      statement.add(|"'"+'ch'+"'"|);
      option.add(statement);
    }
    : character {
      if 'atom'.equals("."){
        option.add(|true|);
      }
      else {
        option.add(|"nextChar" == "'"+'atom'+"'"|);
      }
    }    
    if element->"group" != null {
      String groupClass = "Group"\+preparerState;
      String groupMember = "group_"\+preparerState;
      preparerClass += class groupClass / Parser->NameList->Builder / {
          boolean can(int position, char nextChar){
          }
        }
      preparerClass += preparerClass->'groupClass' 'groupMember' = new preparerClass->'groupClass'();
      option.add(|'groupMember'.add("position","nextChar")|);
      ~int currentStateOfPreparer = 0;
      Class nextPreparerClass = preparerClass->'groupClass';
      Body switchBody = new Body ();
      element->"group"->"regex" : regexElement : regex_element {
        switchBody.add(\getRegexForPreparer(regexElement,ruleName,nextPreparerClass,currentStateOfPreparer));
        currentStateOfPreparer \+= 1;
      }
      nextPreparerClass->*"can".appendToBody(|switch "state" `switchBody` return false;|);
    }
    if element->"multiple" == null {
      regex.add(|if `option` { "state" = 'nextPreparerState'; return true; } else { "state" = "-1"; return false; }|);
    }
    else {
      if element->"multiple"->"OPTIONAL" != null  {
        regex.add(|if `option` { "state" = 'nextPreparerState'; return true; } else { "state" = 'nextPreparerState'; return \can("position","nextChar"); }|);
      }
      else if element->"multiple"->"MANY" != null {
        regex.add(|if `option` { return true; } else { "state" = 'nextPreparerState'; return \can("position","nextChar"); }|);
      }
      else if element->"multiple"->"PLUS" != null{
        regex.add(|
          if `option` { 
            "multiple_satisfied" = true;
            return true;
          } 
          else {
            if "multiple_satisfied" {
              "state" = 'nextPreparerState';
              "multiple_satisfied" = false;
              return \can("position","nextChar");
            }
            else {
              "state" = -1;
              "multiple_satisfied" = false;
              return false;
            } 
          }|);
      }
    }
    return resultBody;
  }
> void declarePosition(Body rule, String ruleName, String subRuleName){
    if declaredPositions.containsKey(ruleName) == false {
      declaredPositions.put(ruleName,new HashSet<String>());
    }
    declaredPositions.get(ruleName).add(subRuleName);
    rule.add(|"_position_"+'subRuleName' = "_position";|);
  }
> void declareSubRuleTokenInRule(String ruleName, String subRuleName, Body rule){
    if subRuleTokenDeclarations.containsKey(ruleName) == false {
      subRuleTokenDeclarations.put(ruleName,new HashSet<String>());
    }
    subRuleTokenDeclarations.get(ruleName).add(subRuleName);
    rule.add(|"_token_"+'subRuleName' = "_token";|);
  }
> void declareNamedToken(String newTokenName, String simpleTokenName){
    if createdNameTokens.add(newTokenName) {
        Token->Id += void "_"+'simpleTokenName';
        \declareResolverMapName(simpleTokenName);
        String nameWithResolve = "Resolve"\+'simpleTokenName';
        Tokens->Name += class newTokenName / Token->Parsed / {
          String value = null;
          Token->Id getName(){
            return Token->Id."_"+'simpleTokenName';
          }
          String getValue(){
            if "children".isEmpty() {
              return value;
            }
            else {
              return "children".get(0).getValue();
            }
          }
          void setValue(String newValue){
            value = newValue;
          }
          Token->Resolver getResolver(Token->ResolverMap map){
            return ((Token->ResolverMap->'nameWithResolve')\map)."resolve_"+'simpleTokenName'();
          }
        }
    }
  }
> Set<String> declaredResolverMaps = new HashSet<String>();
> void declareResolverMapName(String newResolverName){
    if declaredResolverMaps.add(newResolverName) {
      String nameWithResolve = "Resolve"\+newResolverName;
      Token->ResolverMap += interface nameWithResolve /Token->ResolverMap/{
          Token->Resolver "resolve_"+'newResolverName'(){}
        }
    }
  }
  class NameList / HashSet<String> / {
    
    NameList parent = null;
    ~Map<Integer, NameList> children = new HashMap<Integer, NameList>();
    ~List<NameList\>Addition> additions = new ArrayList<NameList\>Addition>();
    ~int addition_position = -1;
    NameList push(int position, int pass){
      NameList result = null;
      if pass == Parser.SECOND_PASS{
        synchronized children {
	      result = children.get(position);
	    }
	  }
	  if result == null {
	    result = new NameList(this);
	    if pass == Parser.FIRST_PASS {
          synchronized children {
	        children.put(position, result);
	      }
	    }
	  }
	  else {
	    result.clear();
	  }
	  synchronized this {
        synchronized result {
          for String newEntry: this {
	        result.safe_add(newEntry);
	      }
	    }
	  }
	  return result;
    }
    NameList push(){
      NameList result = new NameList(this);
	  synchronized this {
        synchronized result {
          for String newEntry: this {
	        result.safe_add(newEntry);
	      }
	    }
	  }
	  return result;
    }
    NameList pop() {
      return parent;
    }
    boolean add(String addition){
      synchronized this {
        if super.add(addition) {
          additions.add(new NameList->Addition(addition_position,addition));
          return true;
        }
        else {
          return false;
        }
      }
    }
    boolean safe_add(String addition){
      return super.add(addition);
    }
    void start(int position){
      addition_position = position;
    }
    void accept(int position){
      addition_position = position;
    }
    void reject(int position){
      synchronized this {
        addition_position = position;
        int i = additions.size()\-1;
        while i >= 0 {
          if additions.get(i).getPosition() >= addition_position {
            \remove(additions.remove(i).getEntry());
          }
          else {
            "break";
          }
          "--i";
        }
      }
    }
    void extend() {
      synchronized parent {
        for String entry: parent {
          \safe_add(entry);
        }
      }
    }
    void keep(){
      synchronized this {
        synchronized parent {
          for NameList->Addition addition: additions {
            parent.safe_add(addition.getEntry());
          }
        }
        additions.clear();
      }
    }
    class Addition //{
      Integer position;
      String entry;
    }
    class Builder // {
      ~StringBuilder builder = null;
      ~int length = 0;
      ~int state  = 0;
      ~boolean multiple_satisfied = false;
      Map<Integer, String> _output = null;
      boolean can(int position,char newChar){
        return false;
      }
      boolean add(int position, char newChar){
        if \can(position,newChar) {
          if builder == null {
            builder = new StringBuilder();
            length = 0;
          }
          builder.append(newChar);
          length \+= 1;
          return true;
        }
        else {
          if builder != null && state >= 0 {
            String result = builder.toString();
            _output.put(position\-length,result);
          }
          builder = null;
          state  = 0;
          return false;
        }
      }
      void end(int position){
        if builder != null && state >= 0 {
          String result = builder.toString();
          _output.put(position\-length,result);
        }
      }
    }
  }
  class 'packageName'."parser" Result {
    Integer state = -1;
    Integer position = -1;
    List<Integer> lineNumberRanges = null;
    String input = null;
    String fileName = null;
    ~\long parseTime = -1;
    void setFileName(String newFileName){
      "fileName" = newFileName;
    }
    Integer getLineNumber(Integer position){
      Integer upperBound = 0;
      Integer lineNumber = 0;
      while lineNumber < lineNumberRanges.size() && upperBound < position {
        upperBound = lineNumberRanges.get(lineNumber);
        lineNumber \+= 1;
      }
      return lineNumber;
    }
    Integer getLineNumber(){
      Integer upperBound = 0;
      Integer lineNumber = 0;
      while lineNumber < lineNumberRanges.size() && upperBound < position {
        upperBound = lineNumberRanges.get(lineNumber);
        lineNumber \+= 1;
      }
      return lineNumber;
    }
    String toString(){
      if state == "Parser.FAILED" {
        Integer lineNumber = \getLineNumber();
        Integer rangeIndex = lineNumber \- 1;
        if rangeIndex < 0 {
          rangeIndex = 0;
        }
        Integer upperBound = lineNumberRanges.get(rangeIndex);
        Integer lowerBound = 0;
        if rangeIndex > 0 {
          lowerBound = lineNumberRanges.get(rangeIndex \- 1) \+ 1;
        }
        String errorAt;
        if upperBound < input.length() {
          errorAt = input.substring(lowerBound,position)\+'' "$>" ''\+input.substring(position,upperBound);
        }
        else {
          errorAt = input.substring(lowerBound,position)\+'' "<$" ''\+input.substring(position);
        }
        if parseTime <= 0 {
          if fileName == null {
            return '' "\\n\\tLine Number: " '' \+lineNumber\+'' "\\n\\tError: " '' \+errorAt ;
          }
          else {
            return '' "\\nFile: " '' \+fileName\+'' " Line : " '' \+lineNumber\+'' "\\n\\tError: " '' \+errorAt;
          }
        }
        else {
          if position == -1 {
            if parseTime < 1000 {
              return '' "File: " '' \+fileName\+'' "\\nParse Time: " '' \+ parseTime \+ '' "ms" '';
            }
            else {
              int minutes = (int)(parseTime / 1000);
              int hundreds = (int)(parseTime/100) %10;
              int tens = (int)(parseTime/10) %10;
              int ones = ((int)parseTime) %10;
              return '' "File: " '' \+fileName\+'' "\\nParse Time: " '' \+ minutes \+ '' "." ''\+hundreds\+''""''\+tens \+''""''\+ones\+'' "s" '';
            }
          }
          else {
            if parseTime < 1000 {
              return '' "\\n\\tError: " '' \+errorAt\+'' "\\n\\tFile: " '' \+fileName\+'' " Line : " '' \+lineNumber\+'' "\\n\\tParse Time: " '' \+ parseTime \+ '' "ms" '';
            }
            else {
              int minutes = (int)(parseTime / 1000);
              int hundreds = (int)(parseTime/100) %10;
              int tens = (int)(parseTime/10) %10;
              int ones = ((int)parseTime) %10;
              return '' "\\n\\tError: " '' \+errorAt\+'' "\\n\\tFile: " '' \+fileName\+'' " Line: " '' \+lineNumber\+'' "\\n\\tParse Time: " '' \+ minutes \+ '' "." ''\+hundreds\+''""''\+tens \+''""''\+ones\+'' "s" '';
            }
          }
        }
      }
      else {
        if parseTime <= 0 {
          if fileName == null {
            return '' "" '' ;
          }
          else {
            return '' "File: " '' \+fileName;
          }
        }
        else {
          if parseTime < 1000 {
            if fileName == null {
              return '' "Parse Time: " '' \+ parseTime \+ '' "ms" '' ;
            }
            else {
              return '' "File: " '' \+fileName\+'' "\\nParse Time: " '' \+ parseTime \+ '' "ms" '';
            }
          }
          else {
            int minutes = (int)(parseTime / 1000);
            int hundreds = (int)(parseTime/100) %10;
            int tens = (int)(parseTime/10) %10;
            int ones = ((int)parseTime) %10;
            if fileName == null {
              return '' "Parse Time: " '' \+ minutes \+ '' "." ''\+hundreds\+''""''\+tens \+''""''\+ones\+'' "s" '';
            }
            else {
              return '' "File: " '' \+fileName\+'' "\\nParse Time: " '' \+ minutes \+ '' "." ''\+hundreds\+''""''\+tens \+''""''\+ones\+'' "s" '';
            }
          }
        }
      }
    }
    class Pass / Parser->Result / {
      Token\>Parsed  parsedRoot = null;
      ~Token->Branch root = null;
      void setup(){
        root = new Token->Branch();
		\setup(root,parsedRoot,0);
      }
      void setup(Token->Branch current, Token->Parsed currentParsed, Integer currentPosition){
        List<Token\>Parsed> children = currentParsed.getChildren();
        List<Integer> positions = currentParsed.getPositions();
        Integer size = currentParsed.getChildren().size();
        for Integer i < size {
          if children.get(i).getChildren().isEmpty() ==  false {
            if children.get(i).getName() == null {
              \setup(current,children.get(i),positions.get(i));
            }
            else {
              Token->Branch newToken = new Token->Branch(children.get(i).getName(),positions.get(i),currentPosition,"children.get(i)::getResolver",this);
              current.add(newToken);
              \setup(newToken,children.get(i),positions.get(i));
            }
          }
          else {
            current.add(new Token->Leaf(children.get(i).getName(),children.get(i).getValue(), positions.get(i),currentPosition,"children.get(i)::getResolver", this ));
          }
        }
      }
      String toString(){
        if fileName != null {
          String realFileName = fileName;
          fileName = null;
          String result = super.toString();
          fileName = realFileName;
          if result.equals('' "" '') {
            return null;
          }
          else {
            return '' "Passed: " '' \+ result ;
          }
          
        }
        else {
          return null;
        }
      }
    }
    class Fail / Parser->Result / {
      String ruleName = null;
      String toString(){
        return '' "Failed: " '' \+ruleName \+ super.toString();
      }
      class EOF / Parser->Result / {
        String erroneousFile = null;
        String toString(){
          return '' "End of file not reached:" '' \+ erroneousFile;
        }
      }
      class EOB / Parser->Result / {
        String myRuleName = null;
        Integer myPosition = -1;
        List<Integer> myLineNumberRanges = null;
        String toString(){
          lineNumberRanges = myLineNumberRanges;
          position = myPosition;
          return '' "End of brace not reached by [" ''\+ myRuleName \+'' "]:" '' \+ \getLineNumber();
        }
      }
    }
    class Acceptor / Parser->Result / {
      List<Parser\>Result> results = new ArrayList<Parser\>Result>();
      void add(Parser->Result result){
        result.setFileName(null);
        results.add(result);
      }
      String toString(){
        StringBuilder builder = new StringBuilder();
        for Parser->Result result: results {
          if result != null {
            String resultString = result.toString();
            if resultString != null {
              builder.append('' "\\n" '');
              builder.append(resultString);
            }
          }
        }
        return \super.toString()\+builder.toString();
      }
    }
  }
}
?class 'packageName'."contexts" AnonymousContext Parser->Context {
}
class 'packageName'."parser" Tokens {
  class Plain // {
  }
  class Syntax // {
  }
  class Name // {
  }
  class Rule // {
  }
}
interface 'packageName'."parser" Token {

  enum Id //{
    void SYNTAX;
    void ROOT;
    void ANON;
  }
  interface Resolver// {
    MapReturn resolve(Token nextToken){}
  }
  interface ResolverMapGetter //{
    Token->Resolver getResolver(Token->ResolverMap map){}
  }
  interface ResolverMap // {
    interface SYNTAX /Token->ResolverMap/ {
      Token->Resolver SYNTAX(){}
    }
  }
  class MapReturn <T> //{
    @MapReturn IGNORE = new MapReturn(false,null);
    boolean shouldReturn = false;
    \T value = null;
  }
  
  Token get(Token->Id tokenName){}
  Token getLast(){}
  Token getLast(Token->Id tokenName){}
  Token->Resolver getResolver(Token->ResolverMap map){}
  Token->MapReturn map(Token->Id id, Token->Resolver resolver){}
  Token->MapReturn map(Token->ResolverMap map){}
  void add(Token newToken){}
  String err(){}
  String err(int tab){}
  void print(){}
  void print(\int tab){}
  void printShort(){}
  String getFileName(){}
  \int getLineNumber(){}
  String getValue(){}
  Token->Id getName(){}
  class Parsed // {
    ~List<Token\>Parsed> children = new ArrayList<Token\>Parsed>();
    ~List<Integer> positions = new ArrayList<Integer>();
    Token->Id name = null;
    String getValue(){
      if children.isEmpty() {
        return null;
      }
      else {
        return children.get(0).getValue();
      }
    }
    void setValue(String newValue){
    }
    String getLastValue(){
      if children.isEmpty() {
        return null;
      }
      else {
        return children.get(children.size()-1).getValue();
      }
    }
    void add(Integer position, Token->Parsed newToken){
      children.add(newToken);
      positions.add(position);
    }
    void addAll(Token->Parsed inductee){
      for Integer i < inductee.children.size() {
        children.add(inductee.children.get(i));
        positions.add(inductee.positions.get(i));
      }
    }
    Token->Resolver getResolver(Token->ResolverMap map){
      return null;
    }
    class Import / Token->Parsed / {
      String fileName = null;
      List<Token\>Parsed> getChildren() {
        return Parser.contexts.get(fileName).get_root().getChildren();
      }
      List<Integer> getPositions() {
        return Parser.contexts.get(fileName).get_root().getPositions();
      }
    }
  }
  
  class Leaf // Token {
    Token->Id name = null;
    String value = null;
    Integer position = null;
    Integer parentPosition = null;
    Token->ResolverMapGetter resolveMap = null;
    Parser->Result->Pass context = null;
    
    Token get(Token->Id tokenName){
      return this;
    }
	Token getLast(){
	  return null;
	}
	Token getLast(Token->Id tokenName){
	  return null;
	}
	void add(Token token){
	}
    
    Token->Resolver getResolver(Token->ResolverMap map){
      return resolveMap.getResolver(map);
    }
    Token->MapReturn map(Token->Id id, Token->Resolver resolver){
      return Token->MapReturn.IGNORE;
    }
    Token->MapReturn map(Token->ResolverMap resolvers){
      return Token->MapReturn.IGNORE;
    }
	String toString(){
      return \getValue();
    }
    String err(){
	  return \shortString();
    }
    String err(int tab){
      StringBuilder builder = new StringBuilder();
      for Integer i < tab {
	    builder.append('' "  " '');
	  }
	  builder.append(\shortString());
	  return builder.toString();
    }
	void print(){
	  \printShort();
	}
	void print(\int tab){
	  for Integer i < tab {
	    \System.out.print('' "  " '');
	  }
	  \printShort();
	}
	void printShort(){
	  \System.out.println(\shortString());
	}
	String shortString(){
	  StringBuilder builder = new StringBuilder();
	  builder.append('' "[" '');
	  builder.append(name);
	  builder.append('' ":" '');
	  builder.append(value);
	  builder.append('' "]" '');
	  return builder.toString();
	}
	String getFileName(){
	  return context.getFileName();
	}
	\int getLineNumber(){
	  return context.getLineNumber(position);
	}
  }
  class Branch // Token {
    ~Map<Token\>Id, List<Token>> namedLists = new EnumMap<Token\>Id, List<Token>>(Token->Id.class);
    ~List<Token> children = new ArrayList<Token>();
    Token->Id name = null;
    Integer position = null;
    Integer parentPosition = null;
    Token->ResolverMapGetter resolveMap = null;
    Parser->Result->Pass context = null;
    
    Token get(Token->Id tokenName){
      List<Token> nameList = namedLists.get(tokenName);
      if nameList == null || nameList.isEmpty() {
        return null;
      }
      else {
        return nameList.get(0);
      }
    }
    String getValue(){
      return children.get(0).getValue();
    }
    String toString(){
      return children.get(0).getValue();
    }
	Token getLast(){
	  return children.get(children.size()\-1);
	}
	Token getLast(Token->Id tokenName){
	  return namedLists.get(tokenName).get(namedLists.get(tokenName).size()\-1);
	}
	void add(Token token){
	  children.add(token);
	  if namedLists.containsKey(token.getName()) == false {
	    namedLists.put(token.getName(), new ArrayList<Token>());
	  }
	  namedLists.get(token.getName()).add(token);
	}
	Token->Resolver getResolver(Token->ResolverMap map){
      return resolveMap.getResolver(map);
    }
	Token->MapReturn map(Token->Id id, Token->Resolver resolver){
	  List<Token> tokens = namedLists.get(id);
	  if tokens == null || tokens.isEmpty() {
        return Token->MapReturn.IGNORE;
      }
      else {
        for Token token:tokens {
          Token->MapReturn nextReturn = resolver.resolve(token);
          if nextReturn.getShouldReturn() {
            return nextReturn;
          }
          
        }
        return Token->MapReturn.IGNORE;
      }
    }
    Token->MapReturn map(Token->ResolverMap map){
      Token->MapReturn nextReturn = Token->MapReturn.IGNORE;
      for Token token:children {
      
        try {
          Token->Resolver resolver = token.getResolver(map);
          if resolver!=null {
            nextReturn = resolver.resolve(token);
            if nextReturn.getShouldReturn() {
              return nextReturn;
            }
          }
        }
        catch ClassCast {}
      }
      return nextReturn;
    }
	String err(){
	  StringBuilder builder = new StringBuilder();
	  builder.append('' ":>" '');
	  builder.append(name);
	  for Token node : children {
	    builder.append(node.err(1));
	  }
	  return builder.toString();
	}
	String err(int tab){
	  StringBuilder builder = new StringBuilder();
	  for Integer i < tab {
	    builder.append('' "  " '');
	  }
	  builder.append(name);
	  for Token node : children {
	    builder.append(node.err(tab\+1));
	  }
	  return builder.toString();
	}
	void print(){
	  \System.out.println('' ":>" '' \+ name);
	  for Token node : children {
	    node.print(1);
	  }
	}
	void print(\int tab){
	  for Integer i < tab {
	    \System.out.print('' "  " '');
	  }
	  \System.out.println(name);
	  for Token node : children {
	    node.print(tab\+1);
	  }
	}
	void printShort(){
	  for Token node : children {
	    \System.out.print('' "[" '');
	    \System.out.print(node.getName());
	    \System.out.print('' ":" '');
	    \System.out.print(node.getValue());
	    \System.out.print('' "]" '');
	  }
	  \System.out.println();
	}
	String getFileName(){
	  return context.getFileName();
	}
	\int getLineNumber(){
	  return context.getLineNumber(position);
	}
  }
}

