< OutputStatement : \com.\rem.\output.\helpers;
< OutputBlankStatement : \com.\rem.\output.\helpers;
< LineableOutput : \com.\rem.\output.\helpers;
< CallableOutput : \com.\rem.\output.\helpers;
< OutputBraced : \com.\rem.\output.\helpers;
< OutputCall : \com.\rem.\output.\helpers;
< OutputNewNumber : \com.\rem.\output.\helpers;
< OutputNewObject : \com.\rem.\output.\helpers;
< OutputClass : \com.\rem.\output.\helpers;
< OutputMethod : \com.\rem.\output.\helpers;
< OutputVariable : \com.\rem.\output.\helpers;
< OutputContext : \com.\rem.\output.\helpers;
< OutputOperator : \com.\rem.\output.\helpers;
< OutputLambda : \com.\rem.\output.\helpers;
< OutputStaticCall : \com.\rem.\output.\helpers;
< OutputArguments : \com.\rem.\output.\helpers;
< OutputParameters : \com.\rem.\output.\helpers;
< OutputBody : \com.\rem.\output.\helpers;
< OutputConditional : \com.\rem.\output.\helpers;
< OutputConditionalHeader : \com.\rem.\output.\helpers;
< OutputQuote : \com.\rem.\output.\helpers;
< OutputExact : \com.\rem.\output.\helpers;
< OutputConcatenation : \com.\rem.\output.\helpers;
< OutputString : \com.\rem.\output.\helpers;
< OutputCast : \com.\rem.\output.\helpers;
< OutputType : \com.\rem.\output.\helpers;
< OutputStasis : \com.\rem.\output.\helpers;
< OutputHelper : \com.\rem.\output.\helpers;
< OutputFile : \com.\rem.\output.\helpers;
< Output : \com.\rem.\output.\helpers;


< Parser : \com.\rem.\gen.\parser;
< Token  : \com.\rem.\gen.\parser;
> class Result //{}

<IParser : \com.\rem.\parser.\parser;
<RegexParser : \com.\rem.\parser.\parser;
<IToken : \com.\rem.\parser.\token;
< Generator : \com.\rem.\parser.\generation;
< GeneralFlowController : \com.\rem.\parser.\generation;
< FlowController : \com.\rem.\parser.\generation;

< ParseContext : \com.\rem.\parser; 

< File : \java.\io;
< List : \java.\util;
< ArrayList : \java.\util;
< Set  : \java.\util;
< HashSet : \java.\util;
< Map  : \java.\util;
< HashMap : \java.\util;
< StringBuilder : \java.\lang;

> String packageName = "com.rem.crg.generator";

> String outerPackageName = "com.rem.cls";
> String innerPackageName = "com.rem.gen";

> OutputBody setupClassList = new OutputBody ();

> Classwise classwise = new Classwise();
> class 'packageName' Classwise {

> ~String mainClassName = "MainFlow";
> ~File innerDirectory = null;
> ~File outerDirectory = null;
> ~OutputClass mainClass = null;

> ~String sourceDirectory = null;
> void setup(Parser.Result result){
    ~String fileName = result.getFileName();
	Integer indexOfDot = fileName.lastIndexOf(".");
	if indexOfDot > -1 {
	  fileName = fileName.substring(0,indexOfDot);
	}
	~int indexOfSlash = fileName.lastIndexOf("/");
	if indexOfSlash > -1 {
	  fileName = fileName.substring(indexOfSlash\+1);
	}
	indexOfSlash = fileName.lastIndexOf("\\");
	if indexOfSlash > -1 {
	  fileName = fileName.substring(indexOfSlash\+1);
	}
	fileName = ^fileName;
	mainClassName = fileName;
	innerDirectory = new File("../"\+fileName\+"/src");
	innerDirectory.mkdirs();
	outerDirectory = new File("../"\+fileName\+"/src",innerPackageName.replace(".","/"));
	outerDirectory.mkdirs();
	sourceDirectory = "../"\+fileName\+"/src/";
  }
> void importAllClasses(Token input) {
    for Token element: input.getAllSafely("anonymous_classes") {
      OutputCall classPackageName = new OutputCall();
      for Token packageElement: element.getAllSafely("packageName") {
	    if packageElement->"NAME" != null {
  	      classPackageName.add(new OutputExact('packageElement->"NAME"'));
	    }
	    else if packageElement->"quote" != null {
	      classPackageName.add(new OutputExact('packageElement->"quote"'));
	    }
	    else if packageElement->"statement_as_string" != null {
	      classPackageName.add(body_gen.statement(packageElement->"statement_as_string"->"body_statement",true,mainClass));
	    }
	  }
	  for Token anonymousClass : element.getAllSafely("anonymous_class") {
	    \defineAnonymousClass(anonymousClass, true, classPackageName.evaluate(), "");
	  }
    }
  }
> void defineAnonymousClass(Token anonymousClass, Boolean isFirst, String anonymousPackageName, String parentClass) {
    StringBuilder currentClass = new StringBuilder();
    currentClass.append(parentClass);
    for Token className : anonymousClass.getAllSafely("className") {
      if isFirst == false { currentClass.append("."); }
	  currentClass.append(className);
	  String currentClassValue = 'currentClass';
	  setupClassList.add(new OutputStaticCall()
	    .set(new OutputType("com.rem.output.helpers.OutputHelper"))
	    .add(new OutputExact("suppliment"),
	         new OutputArguments().add(new OutputQuote('currentClassValue')).add(new OutputQuote('anonymousPackageName'))));
	  OutputHelper.suppliment('currentClassValue','anonymousPackageName');
	}
	
	for Token subAnonymousClass : anonymousClass.getAllSafely("anonymous_class") {
	  \defineAnonymousClass(subAnonymousClass, false, anonymousPackageName, 'currentClass');
	}
  }
> void findAllClasses(Token input){
    for Token element: input.getAllSafely("import_imports") {
      \importAllClasses(element);
    }
    for Token element: input.getAllSafely("import_clws") {
      \findAllClasses(element);
    }
    
    for Token element: input.getAllSafely("class_declaration") {
      classGenerator.collectClassNames(element);
    }
  }
> void generateGlobals(Token input){
    for Token element: input.getAllSafely("import_clws") {
      \generateGlobals(element);
    }
    for Token element: input.getAllSafely("variable_declaration") {
	  OutputVariable newVariable = variable.declaration(element,true,mainClass);
	  newVariable.isStatic().isPublic();
	  mainClass.addVariable(newVariable);
	  variable.addDefinedVariableName(newVariable);
	}
    for Token element: input.getAllSafely("method_declaration") {
	  OutputMethod newMethod = method.declaration(element,true,mainClass);
	  newMethod.isStatic();
	  mainClass.addMethod(newMethod);
	  method.addDefinedMethodName(newMethod);
	}
  }
> void generateAll(Token input){
    for Token element: input.getAllSafely("import_clws") {
      \generateAll(element);
    }
    String packageFileName = packageName.replace(".",File.separator);
    
    for Token element: input.getAllSafely("class_declaration") {
      classGenerator.collectClassNames(element);
    }
    for Token element: input.getAllSafely("class_declaration") {
      OutputClass innerClass = new OutputClass();
      OutputClass outerClass = classGenerator.declaration(element, innerClass,element->"inner" == null,null);
	  if element->"inner" == null {
	    innerClass.addVariable(new OutputVariable().isStatic().set(new OutputType(innerClass.getName()), new OutputExact("_")).assign(outerClass.stasis()));
	  
		setupClassList.add(new OutputStaticCall()
		  .set(new OutputType("com.rem.output.helpers.OutputHelper"))
		  .add(new OutputExact("addOutputClass"),
		       new OutputArguments().add(new OutputStaticCall().set(new OutputType(outerClass.getName())).add(new OutputExact("_")))));
      }
      OutputHelper.addOutputClass(innerClass);
    }
	
  }
> Parser pulsar = null; #FOR IMPORTS#
> void generate(Parser.Result result){
    String mainPackageName = sourceDirectory;
    String mainFlow = "MainFlow";
    String parserTypePath = "com.rem.gen.parser.Parser";
    String resultTypePath = "com.rem.gen.parser.Parser.Result";
    String passTypePath = "com.rem.gen.parser.Parser.Result.Pass";
    mainClass = new OutputClass()
      ._package(new OutputExact(innerPackageName))
      .name(new OutputExact(mainClassName))
      .variable(new OutputVariable().isStatic().set(new OutputType(mainClassName), new OutputExact("self")).assign(new OutputNewObject().set(new OutputType(mainClassName),new OutputArguments())))
      .method(new OutputMethod().isStatic().set(new OutputType("void"),new OutputExact("main")).parameters(new OutputParameters().add(new OutputVariable(new OutputType("String").array(),new OutputExact("args")))).body(new OutputBody()
        .add(new OutputStaticCall().set(new OutputType("com.rem.output.helpers.OutputHelper")).add(new OutputExact("parse"),new OutputArguments().add(new OutputExact("args")).add(new OutputNewObject().set(new OutputType(parserTypePath),new OutputArguments())).add(new OutputExact(mainClassName+"::init")).add(new OutputExact(mainClassName+"::setup")).add(new OutputExact(mainClassName+"::generate"))))))
      .method(new OutputMethod().isStatic().set(new OutputType("void"),new OutputExact("init")).parameters(new OutputParameters().add(new OutputVariable(new OutputType("com.rem.gen.parser.Parser").add(new OutputType("Result")).add(new OutputType("Pass")),new OutputExact("result")))).body(setupClassList));
	
    \findAllClasses(((Parser\.\Result\.\Pass)result).\getRoot());
    \generateGlobals(((Parser\.\Result\.\Pass)result).\getRoot());
	\generateAll(((Parser\.\Result\.\Pass)result).\getRoot());
	OutputHelper.addOutputClass(mainClass);
  }
> Output name_var(Token input, boolean isInner, OutputContext context){
    if input->"tokenAccess" != null {
      return \tokenAccess(input->"tokenAccess",isInner,context);
    }
    else {
      OutputConcatenation result = new OutputConcatenation();
      
      for Token atom: input.getAllSafely("name_atom") {
	    result.add(\name_atom(atom,isInner,context));
      }
      
      if input->"cast_statement" !=null{
        OutputCast cast = new OutputCast();
        for Token atom: input.getAllSafely("cast_statement") {
          cast.type(classwise.all_type(atom->"all_type_name",isInner,context));
        }
        return cast.subject(result);
      }
      else {
        return result;
      }
    }
  }
> Output tokenAccess(Token element, boolean isInner, OutputContext context){
     CallableOutput call = new OutputCall().add(\name_atom(element->"name_atom",isInner,context));
     for Token atom: element.getAllSafely("access") {
       String name = 'atom->"NAME"';
       if atom->"get" != null {
	     call.add(new OutputExact("get"),         new OutputArguments().add(new OutputExact("com.rem.gen.parser.Token.Id._"\+name)));
	   }
	   else if atom->"getAllSafely" != null {
	     call.add(new OutputExact("getAllSafely"),new OutputArguments().add(new OutputExact("com.rem.gen.parser.Token.Id._"\+name)));
	   }
	 }
	 return call;
  }
> Output name_atom(Token input, Boolean isInner, OutputContext parentContext) {
    if input->"statement_as_char" != null {
      if 'input->"statement_as_char"->"value"'.equals("\\") {
        return new OutputBraced().set(new OutputExact("\\")).style("\'","\'");
      }
      else if 'input->"statement_as_char"->"value"'.equals("\"") {
        return new OutputBraced().set(new OutputExact("\"")).style("\'","\'");
      }
      else if 'input->"statement_as_char"->"value"'.equals("\'") {
        return new OutputBraced().set(new OutputExact("\'")).style("\'","\'");
      }
      else {
        return new OutputBraced().set(new OutputExact('input->"statement_as_char"->"value"')).style("\'","\'");
      }
	}
    else if input->"statement_as_method" != null {
      if isInner {
		return body_gen.statement(input->"statement_as_method"->"body_statement",true,parentContext);
      }
      else {
		return body_gen.statement(input->"statement_as_method"->"body_statement",true,parentContext).vibrate();
	  }
	}
	else if input->"statement_as_quote" != null {
	  Output asQuoteStatement = body_gen.statement(input->"statement_as_quote"->"body_statement",isInner,parentContext);
	  if isInner {
		return new OutputQuote().set(asQuoteStatement);
      }
	  else {
		return new OutputQuote().set(asQuoteStatement.vibrate()).stasis();
      }
	}
	else if input->"statement_as_string" != null {
	  Output result = new OutputString().set(body_gen.statement(input->"statement_as_string"->"body_statement",true,parentContext).vibrate());
	  return result;
	}
	else if input->"quote" != null {
	  if isInner {
		return new OutputQuote().set('input->"quote"');
      }
	  else {
		return new OutputQuote().set('input->"quote"').stasis();
      }
	}
	else if input->"NUMBER" != null {
	  return new OutputExact('input->"NUMBER"');
	}
	else if input->"variable_names" != null {
	  ~String value = 'input->"variable_names"';
 	  if isInner && mainClass.hasVariable(value) && (parentContext == null || parentContext.hasVariableInContext(value) == false) {
 	    value = mainClassName\+"."\+value;
 	    return new OutputExact(value);
 	  }
 	  else {
 	    return new OutputExact(value);
 	  }
 	  
	}
	else {
	  input.err();
	  return null;
	}
  }  
> OutputType type_var(Token input, Boolean isInner, OutputContext parentContext){
    OutputType type = new OutputType();
    for Token element: input.getAll() {
      if element.getName().equals("type_atom") {
          type.add(\type_atom(element,isInner,parentContext));
      }
      else if element.getName().equals("template_parameters") { 
        for Token quark: element.getAllSafely("template_parameter") {
          type.template(\all_type(quark,isInner,parentContext));
        }
      }
    }
    return type;
  }
> OutputType type_atom(Token input, Boolean isInner, OutputContext parentContext){
    if input->"statement_as_method" != null {
      return new OutputType(body_gen.statement(input->"statement_as_method"->"body_statement",true,parentContext));
    }
    else if input->"statement_as_string" != null {
      return new OutputType(new OutputString().set(body_gen.statement(input->"statement_as_string"->"body_statement",true,parentContext)));
    }
    else if input->"class" != null {
      if input->"class"->"class_variable_names" != null {
        return new OutputType(
          new OutputCall().add(
            new OutputExact('input->"class"->"class_variable_names"'))
          .add(new OutputExact("getFullName"),new OutputArguments()));
      }
      else {
        return new OutputType('input->"class"->"class_names"');
      }
    }
    else {
      return null;
    }
  }
> OutputType all_type(Token input, Boolean isInner, OutputContext parentContext){
	if input->"non_class_name" != null {
	  Token element = input->"non_class_name".getAll().get(0);
	  if element.getName().startsWith("O") {
	    return new OutputType(new OutputExact("com.rem.output.helpers."\+element.getName()));
	  }
	  else if element.getName().startsWith("Callable") {
	    return new OutputType(new OutputExact("com.rem.output.helpers.CallableOutput"));
	  }
	  else if element.getName().startsWith("Lineable") {
	    return new OutputType(new OutputExact("com.rem.output.helpers.LineableOutput"));
	  }
	  else {
	    if element.getName().equals("Id") {
	      return new OutputType(new OutputExact("com.rem.gen.parser.Token.Id"));
	    }
	    else if element.getName().equals("Result") {
	      return new OutputType(new OutputExact("com.rem.gen.parser.Parser.Result"));
	    }
	    else if element.getName().equals("Pass") {
	      return new OutputType(new OutputExact("com.rem.gen.parser.Parser.Result.Pass"));
	    }
	    else if element.getName().equals("Fail") {
	      return new OutputType(new OutputExact("com.rem.gen.parser.Parser.Result.Fail"));
	    }
	    else {
	      return new OutputType(new OutputExact("com.rem.gen.parser."\+element.getName()));
	    }
	  }
	}
	else if input->"type_var"!=null {
		return \type_var(input->"type_var",isInner,parentContext);
	}
	else {
		if input->"all_type_name" !=null{
			return \all_type(input.get("all_type_name"),isInner,parentContext);
		}
		else {
		  return null;
		}
	}
  }
}

import classes.clws
import methods.clws
import bodies.clws
import variables.clws


IParser getRootParser() {return null;}
List<IParser> getRules() {return null;}
List<IParser> getListnames() {return null;}
RegexParser getLazyNameParser() {return null;}
void assignListElementNames(ParseContext data, IToken rootToken) {}
void setup(ParseContext data) {}