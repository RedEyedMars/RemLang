
> BodyGenerator body_gen = new BodyGenerator();
> class BodyGenerator // {
    ~Integer exceptionIndex = 0;
    
    boolean elementHasReturn(Token input) {
      for Token element: input.getAll() {
        if element.getName().equals("body_return") {
          return true;
        }
        else if element.getName().equals("body_conditional") {
          return \conditionalHasReturn(element);
        }
      }
      return false;
    }
    boolean conditionalHasReturn(Token input){
      for Token atom: input.getAllSafely("as_body") {
        ~Token lastElement = null; 
        List<Token> elements = atom.getAllSafely("body_element");
        ~int i = elements.size() \- 1;
        while i >= 0 && lastElement==null {
          String currentName = elements.get(i).getAll().get(0).getName();
          if currentName.equals("comments")==false&&currentName.equals("SYNTAX")==false {
             lastElement = elements.get(i);
          }
          i \-= 1;
        }
        if lastElement != null {
          return \elementHasReturn(lastElement);
        }
      }
      return false;
    }
    
    LineableOutput element(Token input, Boolean isInner, OutputContext parentContext) {
      for Token element: input.getAll() {
        if element.getName().equals("body_add_to_class") {
          return \addToClass(element,isInner,parentContext);
        }
        else if element.getName().equals("body_access_token") {
          return \accessToken(element,isInner,parentContext);
        }
        else if element.getName().equals("variable_declaration") {
          return new OutputStatement().set(variable.declaration(element,isInner,parentContext));
        }
        else if element.getName().equals("variable_assignment") {
          return variable.assignment(element,isInner,parentContext);
        }
        else if element.getName().equals("body_statement") {
          return new OutputStatement().set(body_gen.statement(element,isInner,parentContext));
        }
        else if element.getName().equals("body_return") {
          if element->"method_argument" != null {
            return new OutputStatement().prefix("return ").set(body_gen.argument(element->"method_argument", isInner, parentContext));
          }
          else {
            return new OutputStatement().prefix("return ");
          }
        }
        else if element.getName().equals("body_throw") {
          return new OutputStatement().prefix("throw ").set(body_gen.statement(element->"body_statement",isInner, parentContext));
        }
        else if element.getName().equals("body_conditional") {
          OutputConditional resultingConditional = new OutputConditional();
          ~Boolean isCase = false;
          ~String conditionalName = "";
          exceptionIndex = 0;
          if element->"conditional".getAll() == null {
            conditionalName = element->"conditional".getValue().trim();
          }
          else {
            StringBuilder conditionalNameBuilder = new StringBuilder();
            ~String space = "";
            for Token conditionName: element->"conditional".getAll() {
              conditionalNameBuilder.append(space);
              conditionalNameBuilder.append(conditionName.getValue().trim());
              space = " ";
            }
            conditionalName = conditionalNameBuilder.toString();
          }
          ~OutputConditionalHeader header = new OutputConditionalHeader();
          ~Output headerCall = null;
          
          if element->"body_statement" != null {
            headerCall = body_gen.statement(element->"body_statement",isInner,parentContext);
          }
          if element->"variable_declaration" != null {
            for Token atom: element.getAllSafely("variable_declaration") {
              String operator = 'element->"OPERATOR"';
              if operator.contains(":") {
                header.declare(variable.declaration(atom,isInner,parentContext));
                header.separator(":");
                header.call(headerCall);
              }
              else {
                header.separator(";");
                OutputVariable headerVariable = variable.declaration(atom,isInner,parentContext);
                headerVariable.assign(new OutputExact("0"));
                header.declare(headerVariable);
                OutputOperator rightSide = new OutputOperator().operator(";");
                rightSide.left(new OutputOperator().left(headerVariable.getName()).operator(operator).right(headerCall));
                rightSide.right(new OutputOperator().operator("++").right(headerVariable.getName()));
                header.call(rightSide);
              }
            }
          }
          else if element->"exception" != null {
            OutputType exceptionType = new OutputType();
            for Token atom: element.getAllSafely("exception") {
              String exceptionTypeName;
              if atom.getValue().contains("*") {
                exceptionTypeName = "Exception";
              }
              else {
                exceptionTypeName = OutputHelper.camelize(atom.getValue()) \+ "Exception";
              }
              if exceptionType == null {
                exceptionType.set('exceptionTypeName');
              }
              else {
                exceptionType.or(new OutputType().set('exceptionTypeName'));
              }
            }
            header = new OutputConditionalHeader().declare(new OutputVariable().set(exceptionType, "e"\+'exceptionIndex'));
          }
          else if headerCall != null {
            header.call(headerCall);
          }
          else {
            header = null;
          }
          
          if element->"statement_as_method" != null {
            resultingConditional.body(body_gen.statement(element->"statement_as_method"->"body_statement",true,parentContext));
          }
          else {
            OutputBody resultingBody = new OutputBody();
            for Token atom: element.getAllSafely("as_body") {
              if element->"PRINT" != null {
                resultingBody.add(
                    new OutputCall().add(
                       new OutputExact().set("e"+'exceptionIndex'))
                          .add(new OutputExact("printStackTrace"),new OutputArguments()));
              }
              for Token quark: atom.getAllSafely("body_element") {
                LineableOutput bodyElem = body_gen.element(quark,isInner,resultingBody);
                if bodyElem != null {
                  resultingBody.add(bodyElem);
                }
              }
            }
            resultingConditional.body(resultingBody);
		    if element->"exception" != null {
              exceptionIndex \+= 1;
            }
          }
          if conditionalName.contains("case") {
            return resultingConditional.init(conditionalName.trim()\+" "\+headerCall.evaluate()\+":");
          }
          else {
            return resultingConditional.init(conditionalName.trim()).header(header);
          }
        }
      }
      return null; #new OutputBlankStatement();# 
    }
    
    
	Output statement(Token input, Boolean isInner, OutputContext parentContext){
	  ~OutputOperator statement = new OutputOperator();
	  ~Boolean isFirst = true;
	  for Token element: input.getAll() {
	    if element.getName().equals("body_call") {
	      if isFirst {
	        statement.left(body_gen.call(element,isInner,parentContext));
	      }
	      else {
	        statement.right(body_gen.call(element,isInner,parentContext));
	      }
	      isFirst = false;
	    }
	    else if element.getName().equals("OPERATOR") {
	      OutputOperator nextStatement = new OutputOperator().left(statement);
	      statement = nextStatement;
	      if element->"exact" != null {
	        statement.operator(element.getValue().trim());
	      }
	      else {
	        statement.operator(element.getValue().substring(1).trim());
	      }
	    }
	  }
	  return statement;
	}
	
    
	Output call(Token input, Boolean mustInner, OutputContext parentContext){
	  Boolean isInner = mustInner || input->"inner" != null;
	  if input->"as_braced" != null {
	    return new OutputBraced().set(body_gen.statement(input->"as_braced"->"statement_as_braced"->"body_statement",isInner,parentContext));
	  }
	  else if input->"as_statement" != null {
        for Token element: input->"as_statement".getAllSafely("body_element") {
          Output newBodyElement = body_gen.element(element,false,parentContext);
          if newBodyElement != null {
            return newBodyElement.stasis();
          }
        }
        for Token element: input->"as_statement".getAllSafely("body_statement") {
          Output newBodyElement = body_gen.statement(element,false,parentContext);
          if newBodyElement != null {
            return newBodyElement.stasis();
          }
        }
      }
	  ~CallableOutput call = null;
	  ~int groupIndex = 0;
	  boolean hasMethodOrVariable = input.getAllSafely("group").size() > 1;
	  for Token element: input.getAllSafely("group") {
	  
		OutputArguments arguments = new OutputArguments ();
		~boolean hasArguments = false;
		for Token atom: element.getAllSafely("method_arguments") {
		  hasArguments = true;
		  for Token quark: atom.getAllSafely("method_argument"){
			arguments.add(body_gen.argument(quark,isInner,parentContext));
	      }
	    }
		for Token atom: element.getAllSafely("array_parameters") {
		  hasArguments = true;
		  if atom->"method_argument" == null || 'atom->"method_argument"' == null {
		    arguments.array(new OutputBraced().style("[","]"));
		  }
		  else {
		    for Token quark: atom.getAllSafely("method_argument"){
			  arguments.array(new OutputBraced().style("[","]"));
	        }
	      }
	    }
		
		if element->"all_type_name" != null {
		  OutputType type = classwise.all_type(element->"all_type_name",isInner,parentContext);
		  if element->"NEW" != null || element->"all_type_name"->"non_class_name" != null {
		    call = new OutputNewObject().set(type,arguments);
		  }
		  else {
		    if hasMethodOrVariable {
		      call = new OutputStaticCall().set(type);
		    }
		    else {
		      call = new OutputStaticCall().set(type).add(new OutputExact("_"));
		    }
		  }
		}
		else {
		  Output nameVar;
		  if element->"name_var" != null {
		    nameVar = classwise.name_var(element->"name_var",isInner,parentContext);
		  }
		  else {
 		    ~String value = 'element->"NAME"';
		    if groupIndex==0&&classwise.getMainClass().getMethod(value)!=null && (parentContext == null || parentContext.hasVariableInContext(value) == false) {
 		      value = "MainFlow.self."\+value;
 	        }
		    nameVar = new OutputExact().set(value);
		  }
		  
		  if groupIndex == 0 {
            call = new OutputCall();
		  }
		  if hasArguments {
            call.add(nameVar,arguments);
		  }
		  else {
		    call.add(nameVar);
		  }
		}
		groupIndex \+= 1;
	  }
	  
	  if input->"cast_statement" !=null{
        OutputCast cast = new OutputCast();
        for Token atom: input.getAllSafely("cast_statement") {
          cast.type(classwise.all_type(atom->"all_type_name",isInner,parentContext));
        }
        return cast.subject(call);
      }
      else {
        return call;
      }
    }
  ~Integer tempTokenElementIndex = 0;
  LineableOutput addToClass(Token input, Boolean isInner, OutputContext parentContext){
    OutputType type = classwise.type_var(input->"type_var",true,parentContext);
    Output accessMethod;
    if input->"accessMethod" != null {
      if input->"accessMethod"->"name_var" != null {
        accessMethod = classwise.name_var(input->"name_var",true,parentContext);
      }
      else {
        accessMethod = new OutputExact().set('input->"accessMethod"->"NAME"');
      }
    }
    else {
      accessMethod = null;
    }
    if input->"class_declaration" != null {
      return new OutputStatement().set(
        new OutputCall().add(type).add(new OutputExact("getAsClass"), new OutputArguments()).add(new OutputExact("addEnclosedClass"),new OutputArguments().add(
           classGenerator.declaration(input->"class_declaration",new OutputClass(),false,parentContext).stasis())));
    }
    else if input->"method_declaration" != null {
      return new OutputStatement().set(
          new OutputCall().add(type).add(new OutputExact("getAsClass"), new OutputArguments()).add(new OutputExact("addMethod"),new OutputArguments().add(
            method.declaration(input->"method_declaration",false,parentContext).stasis())));
    }
    else if input->"variable_declaration" != null {
      return new OutputStatement().set(
          new OutputCall().add(type).add(new OutputExact("getAsClass"), new OutputArguments()).add(new OutputExact("addVariable"),new OutputArguments().add(
            variable.declaration(input->"variable_declaration",false,parentContext).stasis())));
    }
    else {
      OutputBody arguments = new OutputBody();
      if input->"body"->"as_statement" != null {
        for Token element: input->"body"->"as_statement".getAllSafely("body_element") {
          arguments.add(body_gen.element(element,false,parentContext));
        }
        for Token element: input->"body"->"as_statement".getAllSafely("body_statement") {
          arguments.add(body_gen.statement(element,false,parentContext));
        }
      }
      else {
        for Token element: input->"body".getAllSafely("body_element") {
          arguments.add(body_gen.element(element,false,parentContext));
        }
      }
      return new OutputStatement().set(
          new OutputCall().add(type).add(new OutputExact("getAsClass"), new OutputArguments()).add(new OutputExact("getMethod"), new OutputArguments().add(accessMethod)).add(new OutputExact("add"),new OutputArguments().add(
            arguments.stasis())));
    }
  }
    
  LineableOutput accessToken(Token input, Boolean isInner, OutputContext parentContext){
    ~String elementName = null;
    if input->"variableName" != null {
      elementName = input->"variableName".getValue();
    }
    Output subject = classwise.tokenAccess(input->"tokenAccess",true,parentContext);
    ~Integer numberOfInstances = 0;
    for Token element: input.getAllSafely("tokenInstance") {
      numberOfInstances \+= 1;
    }
    OutputBody manipulateBody = new OutputBody();
    ~String singleTokenName = null;
    OutputType tokenType = new OutputType("com.rem.gen.parser.Token");
    for Token element: input.getAllSafely("tokenInstance") {
      String tokenName = 'element->"tokenName"';
      singleTokenName = tokenName;
      OutputBody instanceBody = new OutputBody().setParent(parentContext);
      String elementNameValue;
      if elementName == null {
        elementNameValue = tokenName;
      }
      else {
        elementNameValue = elementName;
      }
      if numberOfInstances != 1 && elementName == null{
        instanceBody.add(
          new OutputVariable().set(
              tokenType,new OutputExact('elementName'))
            .assign(new OutputExact().set("__TEMP_TOKEN_ELEMENT_NAME__"\+tempTokenElementIndex)));
      }
      ~Token lastElement = null;
      for Token atom: element.getAllSafely("body_element") {
        LineableOutput newBodyElement = body_gen.element(atom,true,instanceBody);
        if newBodyElement != null {
          instanceBody.add(newBodyElement);
          lastElement = atom;
        }
      }
      if numberOfInstances == 1 {
        manipulateBody.add(instanceBody);
      }
      else {
        if lastElement != null && body_gen.elementHasReturn(lastElement) == false {
          instanceBody.add(new OutputExact().set("break"));
        }
        manipulateBody.add(
          new OutputConditional().init("case _"\+'tokenName'\+" :").body(instanceBody));
      }
    }
    if numberOfInstances == 1 {
      return new OutputConditional().init("for").header(new OutputConditionalHeader().declare(new OutputVariable().set(tokenType, new OutputExact('elementName'))).separator(":").call(new OutputCall().add(subject).add(new OutputExact("getAllSafely"),new OutputArguments().add(new OutputExact("com.rem.gen.parser.Token.Id._"\+'singleTokenName'))))).body(manipulateBody);
    }
    else {
      if elementName != null {
        return new OutputConditional().init("for").header(new OutputConditionalHeader().declare(new OutputVariable().set(tokenType,new OutputExact(elementName))).separator(":").call(new OutputCall().add(subject).add(new OutputExact("getAll"),new OutputArguments()))).body(new OutputBody().add(new OutputConditional().init("switch").header(new OutputConditionalHeader().call(new OutputCall().add(new OutputExact('elementName')).add(new OutputExact("getName"),new OutputArguments()))).body(manipulateBody)));
      }
      else {
        Integer tempTokenElementIndexValue = tempTokenElementIndex;
        tempTokenElementIndex \+= 1;
        return new OutputConditional().init("for").header(new OutputConditionalHeader().declare(new OutputVariable().set(tokenType, new OutputExact("__TEMP_TOKEN_ELEMENT_NAME__"\+'tempTokenElementIndexValue'))).separator(":").call(new OutputCall().add(subject).add(new OutputExact("getAllSafely"),new OutputArguments().add(new OutputExact("com.rem.gen.parser.Token.Id._"\+'singleTokenName'))))).body(manipulateBody);
      }
    }
  }
  Output argument(Token input, Boolean isInner, OutputContext parentContext){
    for Token element: input.getAll() {
	  if element.getName().equals("class_declaration") {
		return classGenerator.declaration(element, new OutputClass(),false,parentContext).stasis();
      }
      else if element.getName().equals("method_declaration") {
		return method.declaration(element,false, parentContext).stasis();
	  }
	  else if element.getName().equals("variable_declaration") {
		return variable.declaration(element,false,parentContext).stasis();
	  }
	  else if element.getName().equals("body_statement") {
		return body_gen.statement(element,isInner,parentContext);
	  }
	  else if element.getName().equals("as_statement") {
		if element->"body_element" != null {
		  OutputBody argumentBody = new OutputBody();
		  for Token atom: element.getAllSafely("body_element") {
		    argumentBody.add(body_gen.element(atom,false,parentContext));
		  }
		  return argumentBody.stasis();
	    }
	    else if element->"body_statement" != null {
	      return body_gen.statement(element->"body_statement",false,parentContext).stasis();
	    }
	  }
	  else if element.getName().equals("body_entries") {
	    OutputBody elements = new OutputBody ();
	    for Token atom: element.getAllSafely("body_element") {
	      elements.add(body_gen.element(atom,false, parentContext));
		}
		return elements.stasis();
	  }
	  else if element.getName().equals("lambda") {
	    OutputLambda lambda = new OutputLambda();
	    for Token atom: element.getAllSafely("variableName") {
          lambda.declare('atom');
		}
		if element->"body" !=null {
	      for Token atom: element.get("body").getAllSafely("body_element") {
	        lambda.add(body_gen.element(atom,isInner, parentContext));
		  }
		}
		else {
	      lambda.call((CallableOutput)body_gen.call(element.get("body_call"),isInner, parentContext));
		}
		return lambda;
      }
    }
    return null; #new OutputBlankStatement();# 
  }
}