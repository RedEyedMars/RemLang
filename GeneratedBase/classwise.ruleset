comment-s are Braced
	[#,#] as COMMENT with WILD as comment
token-s
	[[a-zA-Z_][a-zA-Z0-9_]*] as NAME
	[[^a-zA-Z0-9_\\s\\n\\(\\)\\{\\}\\[\\]\\;\\\"\\\'\\\\`,]+\\s*] as OPERATOR
	[[-]?(\\d*\\.)?\\d+f?(x[0-9ABCDEF]+)?\\s*] as NUMBER
	[.*] as WILD
	"\n" as NEWLINE
	"class " as CLASS
	"interface " as INTERFACE
	"method" as METHOD
	"variable" as VARIABLE
	"Class " as CLASS_TYPE
	"Method " as METHOD_TYPE
	"Variable " as VARIABLE_TYPE
	"Body " as BODY_TYPE
	"Context " as CONTEXT_TYPE
	"Statement" as STATEMENT_TYPE
	"Parameters" as PARAMETERS_TYPE
	">" as IN
	"inner " as NER
	"<" as HID
	"hidden " as DEN
	"from " as FROM
	"@" as STA
	"static " as TIC
	"->" as ACCESS
	"\\>" as SPECIAL_ACCESS
	"=" as EQUALS
	"," as COMMA
	"." as DOT
	";" as SEMICOLON
	":" as COLON
	"+=" as ADD
	"+" as PLUS
	"\\" as BACKSLASH
	"/" as FORSLASH
	"$" as ISTYPENAME
	"^" as CAMEL
	"cds" as CDS
	"clws" as CLWS
	"return " as RETURN
	"void" as VOID
	"throw " as THROW 
	"new " as NEW
	"if" as IF
	"else" as ELSE
	"while" as WHILE
	"for" as FOR
	"try" as TRY
	"catch" as CATCH
	"print" as PRINT
	"|" as PIPE
	"synchronized" as SYNCHRONIZED
	"switch" as SWITCH
	"case" as CASE
	"null" as NULL
	"true" as TRUE
	"false" as FALSE
	"~" as WEAK
	"*" as AS_METHOD_NAME
	"*" as AS_GENERIC
	"this" as THIS
	"super" as SUPER
	"..." as INLINE_LIST
	"[]" as ARRAY_TYPE

brace-s are Braced
	[{,}] as CLASS_BODY with class_element*
	[{,}] as METHOD_BODY with body_element*
	[(,)] as METHOD_PARAMETERS with ( variable_declaration ( COMMA variable_declaration )*)?
	[(,)] as PARAMETERS with ( NEWLINE* method_argument ( NEWLINE* COMMA NEWLINE* method_argument )*)?
	[[,]] as ARRAY_PARAMETERS with ( NEWLINE* method_argument ( NEWLINE* COMMA NEWLINE* method_argument )*)?
	[<,>] as TEMPLATE_PARAMETERS with all_type_name as template_parameter ( COMMA all_type_name as template_parameter )*
	[\",\"] as QUOTE with WILD
	[\'\',\'\'] as STATEMENT_AS_QUOTE with body_statement
	[\',\'] as STATEMENT_AS_STRING with body_statement
	[`,`] as STATEMENT_AS_METHOD with body_statement
	[(,)] as STATEMENT_AS_BRACED with body_statement
	[|,|] as AS_STATEMENT with (body_element+ | body_statement)
	[,.] as CLASS_FILE with WILD as class_file_name
class_name-s
	[String] as _String
	[void] as _void
	[Boolean] as _Boolean
	[boolean] as _boolean
	[Byte] as _Byte
	[byte] as _byte
	[Character] as _Character
	[char] as _char
	[Integer] as _Integer
	[int] as _int
	[Double] as _Double
	[double] as _double
	[Float] as _Float
	[float] as _float
	[Long] as _Long
	[long] as _long
	[Short] as _Short
	[short] as _short
	[System] as _System
	[Object] as _Object
class_variable_name-s are empty
variable_name-s are empty
method_definitions are empty
base is silent
	base_element*
base_element is silent
	NEWLINE
	COMMENT
	imports
	anonymous_class
	class_declaration
	method_declaration
	variable_declaration SEMICOLON
imports
	IMPORT_CLASS
simport-s are Import
	[import <<class_file_name,\".clws\">>\n] as IMPORT_CLASS from base_element*; with CLASS_FILE CLWS

anonymous_class
	(HID|DEN) NAME as className in class_names (COLON|FROM) (name_var as packageName (DOT name_var as packageName)*)? SEMICOLON 
class_declaration
	(IN|NER) as inner? WEAK? (CLASS|INTERFACE) as objectType (name_var as packageName (DOT name_var as packageName)*) (variable_name|class_variable_name|NAME) as className in class_names NEWLINE* ( HID NAME as templateTypeName in class_variable_names IN)? NEWLINE* ( type_var as parentName )? NEWLINE? ( type_var as interfaceName )* CLASS_BODY
	(IN|NER) as inner? WEAK? (CLASS|INTERFACE) as objectType (variable_name|class_variable_name|NAME) as className in class_names NEWLINE* ( HID NAME as templateTypeName in class_variable_names IN)? NEWLINE* FORSLASH ( type_var as parentName )? NEWLINE* FORSLASH ( type_var as interfaceName )* CLASS_BODY
class_element is silent
	NEWLINE
	COMMENT
	class_declaration
	method_declaration
	variable_declaration SEMICOLON
body_element
	NEWLINE
	COMMENT
	((IN|NER) as inner? RETURN (VOID | method_argument) SEMICOLON ) as body_return
	((IN|NER) as inner? THROW body_statement SEMICOLON ) as body_throw
	class_declaration
	( variable_declaration SEMICOLON) as body_line
	( variable_assignment SEMICOLON) as body_line
	body_manipulate
	body_conditional
	( body_statement SEMICOLON ) as body_line
body_conditional
	(IN|NER) as inner? (IF|ELSE IF|WHILE|SYNCHRONIZED|SWITCH|CASE) as conditional body_statement ( METHOD_BODY as as_body | STATEMENT_AS_METHOD as as_method )
	(IN|NER) as inner? ELSE as conditional ( METHOD_BODY as as_body | STATEMENT_AS_METHOD as as_method )
	(IN|NER) as inner? FOR  as conditional variable_declaration OPERATOR body_statement ( METHOD_BODY as as_body | STATEMENT_AS_METHOD as as_method )
	(IN|NER) as inner? TRY  as conditional ( METHOD_BODY as as_body | STATEMENT_AS_METHOD as as_method )
	(IN|NER) as inner? PRINT? CATCH  as conditional (AS_GENERIC | NAME) as exception ( PIPE (AS_GENERIC | NAME) as exception )* ( METHOD_BODY as as_body | STATEMENT_AS_METHOD as as_method )
body_statement
	(IN|NER) as inner? body_call ( NEWLINE* ( BACKSLASH? OPERATOR)  NEWLINE* body_call )*
	STATEMENT_AS_STRING as as_string
	( STATEMENT_AS_BRACED as left ( BACKSLASH? OPERATOR)? body_statement as right? )  as as_braced
body_call
	(NEW all_type_name as typeName PARAMETERS as parameters? ARRAY_PARAMETERS as array_parameters*) as group ( NEWLINE* DOT NEWLINE* (NAME PARAMETERS as parameters? ARRAY_PARAMETERS as array_parameters*) as group )*
	(name_var PARAMETERS as parameters? ARRAY_PARAMETERS as array_parameters*) as group ( NEWLINE* DOT NEWLINE* ((name_var | NAME) PARAMETERS as parameters? ARRAY_PARAMETERS as array_parameters*) as group )*
	(type_var (NEWLINE* DOT NEWLINE* type_var)* PARAMETERS as parameters? ARRAY_PARAMETERS as array_parameters*) as group ( NEWLINE* DOT NEWLINE* (NAME PARAMETERS as parameters? ARRAY_PARAMETERS as array_parameters*) as group )*
body_manipulate
	(IN|NER)? type_var ADD  as methodName NEWLINE* ( class_declaration | method_declaration | variable_declaration | METHOD_BODY as body | AS_STATEMENT as body )
	(IN|NER)? name_var COLON NAME as variableName in variable_names ( NEWLINE* COLON NAME as tokenName NEWLINE* METHOD_BODY) as tokenInstance+

method_argument
	class_declaration
	method_declaration
	variable_declaration SEMICOLON
	AS_STATEMENT as as_statement
	body_statement
	METHOD_BODY as body_entries
method_declaration
	method_definition as methodDefinition in method_definitions
method_definition is silent
	(IN|NER) as inner? (STA|TIC) as static? all_type_name as typeName ARRAY_TYPE* (AS_METHOD_NAME as NAME | name_var | NAME) as methodName ( METHOD_PARAMETERS as inline | STATEMENT_AS_METHOD as variableParameters ) METHOD_BODY
variable_declaration
	(IN|NER) as inner?  WEAK? (STA|TIC) as static? WEAK? ( class_name_definition | variable_name_definition ) ( EQUALS method_argument)?
variable_assignment
	(IN|NER) as inner? name_var EQUALS method_argument

variable_name_definition is silent
	all_type_name as typeName ARRAY_TYPE* INLINE_LIST? (name_var | NAME ) as variableName in variable_names
class_name_definition is silent
	CLASS_TYPE as typeName (name_var | NAME ) as variableName in class_variable_names

all_type_name is silent
	CLASS_TYPE
	METHOD_TYPE
	VARIABLE_TYPE
	BODY_TYPE
	STATEMENT_TYPE
	PARAMETERS_TYPE
	CONTEXT_TYPE
	type_var (DOT type_var)*

name_var
	( CAMEL? name_var_element as name_var ( (ACCESS) name_var_element as name_var )+ ) as access
	( CAMEL? name_var_element as name_var ( PLUS name_var_element as name_var )+ ) as concat
	name_var_element
name_var_element is silent
	( NUMBER as NAME ) as exact
	STATEMENT_AS_METHOD as as_method
	STATEMENT_AS_QUOTE as as_quote
	STATEMENT_AS_STRING as as_string
	( BACKSLASH CAMEL? (QUOTE|variable_name|NAME) ) as exact
	( CAMEL? ( variable_name ) ) as variable
	( CAMEL? (QUOTE|(NUMBER|SUPER|THIS|NULL|TRUE|FALSE) as NAME) ) as exact
type_var
	( ISTYPENAME? CAMEL? type_var_element as type_var ( (ACCESS|SPECIAL_ACCESS) type_var_element as type_var )+ ( (ACCESS) AS_METHOD_NAME name_var? ) as as_method?) as access_multi
	( ISTYPENAME? CAMEL? type_var_element as type_var (ACCESS) AS_METHOD_NAME name_var? ) as access_method
	( ISTYPENAME? CAMEL? type_var_element as type_var ( PLUS type_var_element as type_var)+ ) as concat
	ISTYPENAME? type_var_element
type_var_element is silent
	STATEMENT_AS_METHOD as as_method
	STATEMENT_AS_QUOTE as as_quote
	STATEMENT_AS_STRING as as_string
	( BACKSLASH CAMEL? ( variable_name | NAME )  TEMPLATE_PARAMETERS as template_parameters? ) as exact
	(CAMEL? (class_variable_name | class_name ) TEMPLATE_PARAMETERS as template_parameters? ) as class