#Tokens
token-s
	[\\n] as NEWLINE
	"name" as NAME_WORD
	[[a-zA-Z_][a-zA-Z0-9_]*] as NAME
	[.*] as WILD
	"generate " as ASTRO_GENERATE
	"^" as CARROT
	"=" as EQUALSIGN
	"+" as PLUS
	"*" as STAR
	"uses " as USES
	"elements" as ELEMENTS
	"generate" as GENERATE
	"takes" as TAKES
	"var " as VARIABLE
	"set " as SET
	"entry " as ENTRY
	"return" as RETURN
	"\\" as BACK_SLASH
	":" as COLON
	"," as COMMA
	"\'" as PRIME
	"to" as TO
	"new " as NEW
	"contains " as CONTAINS
	"\\" as BACKSLASH
	[[+-]] as ADDITIVE_OPERAND
	[[*/]] as MULTIPLICATIVE_OPERAND
	[(-)?\\d+] as NUMBER
	"null" as NULL
	"if " as IF
	"else" as ELSE
	"and " as AND
	"or " as OR
	"not " as NOT
	"is " as IS
	"static" as STATIC
	[[<>](=)?] as ORDINAL_OPERATOR
	"empty" as EMPTY
	"singular" as SINGULAR
	"single" as SINGLE
	"does " as DOES
	"->" as ACCESS
	[[^\\s]+] as NON_SPACE
	"flip " as FLIP
	"error" as ERROR
	"true" as TRUE
	"false" as FALSE
	"aux " as AUXILLARY
	"cast " as CAST
	"as " as AS
	"token " as TOKEN
	"property " as PROPERTY
	"each " as EACH
	"in " as IN
	"constructor" as CONSTRUCTOR
	"output" as OUTPUT
	"this" as THIS
	"constant" as CONSTANT
	"otherwise" as OTHERWISE
	"|" as PIPE
	"meta" as META
	"check " as CHECK
	[[^\\n]+] as NON_NEWLINE
	".." as DOTDOT
	"\n" as NL

#Tab collectors
tab-s are Tabbed
	[\t] as TAB

#Braces
brace-s are Braced
	[\",\"] as QUOTE with WILD as entry
	[``,``] as QUOTE_ENTRY with (QUOTE | variable_or_token_name)
	[{,}] as ENTRY_LIST with (entry_definition{-1}| generate_call{-1} | whitetab{-1}? variable_or_token_name)? ( (entry_definition{-1} | generate_call{-1} | whitetab{-1}? variable_or_token_name) )* NL*
	[[,]] as ENTRY_SET with (entry_definition{-1}| generate_call{-1} | whitetab{-1}? variable_or_token_name)? ( (entry_definition{-1} | generate_call{-1} | whitetab{-1}? variable_or_token_name) )* NL*
	[<,>] as ANGLE_CLASSES with angle_brace_class ( COMMA angle_brace_class )*	
	[:,;] as INLINE_PARAMETERS with method_parameter*
	[(,)] as TAB_BRACES with tab_brace_parameters as tab_braces
	[:,;] as CUSTOM_ENTRY_DEFINITION with ( NL* method_parameter )* NL*
	[|,|] as PIPE_ENTRY with variable_name
#Import
ingest-s are Import
	[import<<entry>>\\n] as IMPORT with QUOTE
	[from<<entry>>] as ELEMENT_IMPORT from blah:(element_definition{0}|NEWLINE)+; with QUOTE

angle_brace_class is silent
	(entry_class_name|class_name|property_name) ANGLE_CLASSES as braces?	

tab_brace_parameters is silent
	arithmatic (entry_definition{-1}|entry_name) 

arithmatic
	arithmatic ADDITIVE_OPERAND as operand arithmatic
	arithmatic MULTIPLICATIVE_OPERAND as operand arithmatic
	variable_name | NUMBER

#Class Definition	
class_definition-s are empty
entry_class_definition-s are empty
property_definition-s are empty

generator_name-s
class_name-s
	[String] as String
	[StringBuilder] as StringBuilder
	[Boolean] as Boolean
	[Integer] as Integer
	[ParseList] as ParseList
	[ParseContext] as ParseContext	
	[ParseUtil] as ParseUtil
	[IParser] as IParser
	[IToken] as IToken
	[Listnames] as Listnames
	[List] as List
	[ArrayList] as ArrayList
	[Map] as Map
	[HashMap] as HashMap
	[Set] as Set
	[HashSet] as HashSet
	[TreeSet] as TreeSet
	[File] as File
	[Entry] as Entry
	[ListEntry] as ListEntry
element_name-s are empty
variable_name-s	are empty
entry_name-s are empty
entry_class_name-s are empty
property_name-s are empty
token_name-s are empty
method_declaration-s are empty
meta_declaration-s are empty

#Rules
base is silent
	( NEWLINE | IMPORT | used_classes_list | meta_declaration in meta_declarations | property_declaration as property_dec in property_definitions | entry_class_declaration as entry_dec in entry_class_definitions | class_declaration as class_dec in class_definitions with className )+

whitetab is silent has tabs
	( NEWLINE TAB{tabs})+

used_classes_list
	USES ( NAME as className in class_names)+

meta_declaration is silent
	META NAME as metaName ( variable_declaration{1}  | meta_method_declaration in method_declarations )+

meta_method_declaration is silent
	whitetab{1} NAME as methodName cast_as_statement? takes_statement{1}?  ( entry_declaration{2} | body_element{2} )+

property_declaration is silent
	PROPERTY NAME as propertyName in property_names  entry_class_element*

entry_class_declaration is silent
	ENTRY NAME as entryClassName in entry_class_names (USES property_name+) as implements? entry_class_element*

entry_class_element
	constant_declaration{1}
	variable_declaration{1}
	entry_declaration{1}
	( whitetab{1} CONSTRUCTOR takes_statement{1}? ( entry_declaration{2} | body_element{2} )+ ) as constructor
	( whitetab{1} OUTPUT as methodName ( whitetab{3} (PLUS as break | ( entry_definition{-1} | entry_name ) as value ( OTHERWISE as otherwise | IF boolean_statement) as ifStatement?) )as  entry_values+ ( ( entry_declaration{2} | body_element{2} )* ) as body ) as output_method
	( whitetab{1} NAME as methodName cast_as_statement? takes_statement{1}? ( entry_declaration{2} | body_element{2} )+ ) as entry_method

class_declaration is silent
	NAME as className in generator_names ( class_element{1})+

class_element is silent has tabs
	constant_declaration{tabs}
	(auxillary_declaration{tabs}) as auxillary_declaration in method_declarations
	element_declaration{tabs}
	(generation_declaration{tabs}) as generation_declaration in method_declarations
	variable_declaration{tabs}

element_declaration has tabs
	whitetab{tabs} ELEMENTS ( ELEMENT_IMPORT | element_definition{tabs+1}+ )

element_definition has tabs
	whitetab{tabs} NAME as elementName in element_names element_entry{tabs+1} ( ( NAME )* as entry element_entry{tabs+1} )*

element_entry has tabs
	whitetab{tabs}? QUOTE ( PLUS whitetab{tabs} QUOTE)*

takes_statement is silent has tabs
	TAKES ( whitetab{tabs+2}? NAME as takeName in variable_names cast_as_statement? ) as parameter ( (COMMA|whitetab{tabs+2}) ( NAME as takeName in variable_names cast_as_statement? ) as parameter)*

auxillary_declaration is silent has tabs
	whitetab{tabs} AUXILLARY NAME as methodName takes_statement{tabs}? ( entry_declaration{tabs+1} | body_element{tabs+1} )+

generation_declaration is silent has tabs	
	whitetab{tabs} GENERATE NAME as tokenName in token_names takes_statement{tabs}?  ( entry_declaration{tabs+1} | body_element{tabs+1} )+ 

entry_declaration has tabs
	whitetab{tabs} ENTRY NAME as entryName in entry_names ( QUOTE as delimiter )? EQUALSIGN ( entry_definition{tabs+1} | NULL )

entry_definition has tabs
	whitetab{tabs}? ( (entry_name SINGLE) as getSingle | generate_call | entry_class_name CUSTOM_ENTRY_DEFINITION | BACKSLASH (QUOTE|variable_or_token_name) as string | QUOTE_ENTRY as quoted | generator_name as gen (element_name|variable_name) from gen in class_definitions list_entry_definition | element_name list_entry_definition | list_entry_definition | TAB_BRACES )

list_entry_definition
	ENTRY_LIST as list
	ENTRY_SET as set
	PIPE_ENTRY as exact_variable

body_element has tabs
	error_statement{tabs}
	return_statement{tabs}
	if_statement{tabs}
	check_call{tabs}
	token_declaration{tabs}
	variable_declaration{tabs}
	set_call{tabs}
	each_call{tabs}
	flip_switch{tabs}
	token_expansion{tabs}
	inline_addition_call{tabs}
	method_call{tabs}

constant_declaration has tabs
	whitetab{tabs} CONSTANT NAME as variableName in variable_names cast_as_statement? ( cast_statement{tabs+1} | whitetab{tabs+1} boolean_statement | method_call{tabs+1} | whitetab{tabs+1} method_parameter )

variable_declaration has tabs
	whitetab{tabs} VARIABLE NAME as variableName in variable_names cast_as_statement? ( EQUALSIGN ( boolean_statement | method_parameter ) | ( cast_statement{tabs+1} | whitetab{tabs+1} boolean_statement | method_call{tabs+1} | whitetab{tabs+1} method_parameter ) )?

token_declaration has tabs
	whitetab{tabs} TOKEN NAME as tokenName in token_names ( method_call{tabs+1} | ( ( ( EQUALSIGN | whitetab{tabs+1} ) (token_name|variable_name) ( ACCESS NAME as option )* ) as variable_or_token_name ) as method_parameter ) 

token_expansion has tabs
	whitetab{tabs} token_name ( clause_type_tokens{tabs} | all_type_tokens{tabs} )

clause_type_tokens has tabs
	TO NAME as tokenName in token_names token_clause{tabs+1}+

token_clause has tabs
	whitetab{tabs} NAME as specificTokenName ( entry_declaration{tabs+1} | body_element{tabs+1} )+ as body

all_type_tokens has tabs
	(STAR as wild|NAME) as specificTokenName TO NAME as tokenName in token_names ( entry_declaration{tabs+1} | body_element{tabs+1} )+ as body

return_statement has tabs
	whitetab{tabs} RETURN cast_as_statement* ( generate_call{tabs+1} | entry_definition{tabs+1} | whitetab{tabs+1} boolean_statement | method_call{tabs+1} | whitetab{tabs+1} method_parameter )

error_statement has tabs
	whitetab{tabs} ERROR token_name? ( whitetab{tabs+1}? (QUOTE|variable_or_token_name))+

each_call has tabs
	whitetab{tabs} EACH NAME as eachName in variable_names cast_as_statement* IN (range|variable_name as iterable) (entry_declaration{tabs+1} | body_element{tabs+1})+

range
	arithmatic as left DOTDOT arithmatic as right

if_statement has tabs
	whitetab{tabs} IF boolean_statement ( entry_declaration{tabs+1} | body_element{tabs+1} )+ else_statement{tabs}?

else_statement has tabs
	whitetab{tabs} ELSE ( entry_declaration{tabs+1} | body_element{tabs+1} )+

boolean_statement
	 boolean_clause ( ( ( AND | OR ) as continuationOperator boolean_clause ) as continuationStatement )*

boolean_clause
	( NOT method_parameter ) as notStatement
	( token_name CONTAINS NAME as argument ) as containsStatement
	( method_parameter as left ( IS NOT? | ORDINAL_OPERATOR | DOES NOT? NAME as methodName ) as operator (method_parameter | EMPTY | SINGULAR) as right ) as operatedStatement
	( method_parameter as left ( DOES NOT? NAME as methodName ) as operator ) as methodWithNoArgument

check_call has tabs
	whitetab{tabs} CHECK NAME as checkName ( NAME as left ( ( IS NOT? | ORDINAL_OPERATOR ) as operator | NAME as method ) NAME as right ) as parameter  ( whitetab{tabs+2}? ( AND | OR ) as con_op NAME as left ( ( IS NOT? | ORDINAL_OPERATOR ) as operator | NAME as method ) NAME as right ) as parameter*  whitetab{tabs+1} NON_NEWLINE as errorMessage

inline_addition_call has tabs
	whitetab{tabs} method_parameter as subject PLUS EQUALSIGN ( boolean_statement |  method_parameter | method_call{tabs+1} ) as parameter

method_call has tabs
	whitetab{tabs} NEW as subject angle_brace_class as angle_class? ( (whitetab{tabs+1} boolean_statement | method_call{tabs+1} | whitetab{tabs+1} method_parameter) cast_as_statement* ) as parameter*
	whitetab{tabs} (STATIC as isStatic? )( ASTRO_GENERATE | THIS | method_parameter ) as subject (generator_name NAME as methodName| NAME as methodName)  ( INLINE_PARAMETERS as inline_parameters | ( (whitetab{tabs+1} boolean_statement | method_call{tabs+1} | whitetab{tabs+1} method_parameter) cast_as_statement* ) as parameter* )

set_call has tabs
	whitetab{tabs}? SET NAME as subject cast_as_statement? ( EQUALSIGN ( boolean_statement |  method_parameter ) | ( whitetab{tabs+1} boolean_statement | method_call{tabs+1} | whitetab{tabs+1} method_parameter ) )

generate_call has tabs
	whitetab{tabs}? ASTRO_GENERATE as subject ( generator_name NAME as methodName | NAME as methodName ) INLINE_PARAMETERS as inline_parameters?

method_parameter
	NULL | TRUE | FALSE
	entry_definition{-1}
	generate_call{-1}
	QUOTE as string
	ACCESS NAME_WORD as getKeyName
	variable_or_token_name
	( PRIME as getString )? entry_name
	class_name
	generator_name
	property_name
	entry_class_name
	NUMBER

variable_or_token_name
	( PRIME as getString | CARROT as camelize )? ( (token_name|variable_name|entry_name|generator_name) ( ACCESS (variable_name|NAME) as option )+ | arithmatic )
	( PRIME as getString | CARROT as camelize )? (token_name|variable_name|entry_name)

flip_switch has tabs
	whitetab{tabs} FLIP variable_name ( whitetab{tabs+1} (QUOTE|NON_SPACE) as left EQUALSIGN (QUOTE|NON_SPACE) as right )* ( else_statement{tabs+1} )?

cast_statement has tabs
	whitetab{tabs} CAST variable_name cast_as_statement

cast_as_statement is silent
	AS ( angle_brace_class ) as castToType