uses Listnames Tokens
base
	var directory as File
		null
	var seedName
		null
	generate takes data
		var fileName
			data getFileName
		var indexOfDot
			fileName lastIndexOf
				"."
		if indexOfDot > -1
			set fileName
				fileName substring
					0
					indexOfDot
		set seedName
			fileName
		set directory
			new File
				base buildString
					"../Generated"
					base camelize
						fileName
					"/src/"
		directory mkdirs
		list generate
			data
		rule generate
			data	
			
		rule outputAll
		list outputAll
		base outputAll
	
	var lazyNameParser as IParser
		static Tokens LISTNAME
		
	aux assignListElementNames takes
			context as ParseContext
			root as IToken
		var list_rules as ParseList
			context getList
				"list_rules"
		token new_list_rules
			list_rules getNewTokens
		
		new_list_rules * to new_list_def
			var listName
				'new_list_def -> listname
			set listName
				listName replaceAll
					"[ \\t]+"
					""
			var listSingle
				listName
			var indexOfDash
				listName indexOf
					"-"
			if indexOfDash > -1
				var oldList as ParseList
					context getList
						listName
				if oldList is not null
					context removeList
						oldList
				
				set listSingle
					listName substring
						0
						indexOfDash
				set listName
					base buildString
						listSingle
						listName substring
							indexOfDash+1
							listName length
				if oldList is not null
					context addList
						oldList
			context addList
				listName						
			var listVar as ParseList
				context getList
					listName
			var listNameParser as NameParser
				listVar getNamesParser
			new_list_def list_def to def
				var name
					'def -> parameters -> name
				listNameParser addName
					name
		var listRuless as ParseList
			context getList
				"list_rules"
		var listRulessNamesParser as NameParser
			listRuless getNamesParser
		listRulessNamesParser clear

rule
	var ruleParameterNames
		new HashMap<String,List<String>>
	var directory
		null
	var packageName
		null
	elements
		outline
			"package " Package Name ";\n\n"+			
			"import com.rem.parser.*;\n"+
			"import com.rem.parser.generation.*;\n"+
			"import com.rem.parser.token.*;\n"+
			"import com.rem.parser.parser.*;\n"+
			"import lists.*;\n\n"+
			"public class " Class Name " extends ConcreteRule {\n\n"+
			"\tpublic static final IRule parser = new " Class Name "();\n" Parameter Declarations
			"\tprivate Parameter<?>[] parameters = new Parameter<?>[]{" Parameter List "};\n"+									
			"\tpublic " Class Name "(){\n"+
			"\t\tsuper(\"" Rule Name "\");\n"+
			"\t}\n"+
			"\t@Override\n"+
			"\tpublic void setup(){\n" RuleSetup "\n\t}\n"+
			"\t@Override @SuppressWarnings(\"unchecked\")\n"+
			"\tpublic Parameter<?>[] getParameters(){\n"+
			"\t\treturn parameters;\n\t}\n\n}"				
		importRules 
			"import " Seed Name ".rules.*;\n"
		ruleElement
			"\tpublic static final IRule " Rule Name " = " Class Name ".parser;\n"
		setupSilence
			"\t\tisSilent(true);\n"
		setupAdd
			"\t\tset(" Rule Definition ");\n"		
		as
			"new AddTokenParser(" Inner Rule "," Token Name ")"
		addToList
			"new AddTokenToListParser(" Inner Rule "," Token Name "," List Name ")"
		addToListWithToken
			"new AddTokenToListParser(" Inner Rule "," Token Name "," List Name "," With Name ")"
		
		chain
			"new ChainParser(" Inner Rules ")"
		choice
			"new ChoiceParser(" Inner Rules ")"
		multiple
			"new " Parser Class Name "Parser(" Inner Rule ")"
		
		listElement
			"" List Name "." Parser Name ""
		rule_parser
			"" Name ".parser"
		rule_name_parser
			"new ListNameParser(\"" Name "\")"
		rule_any_list_name
			"AnyListNameParser.parser"		
		
		parameterMember
			"\tprivate Parameter<" Type"> " Parameter Name " = new Parameter<" Type ">(" Default Value ");\n"
		parameterIndex
			"\t\tcase " Index ": return " Parameter Name ";\n"
		parameterGet
			"\t\tswitch(i){\n" Params "\t\tdefault: return null;\n\t\t}\n"
		parameterWith
			"new WithParser((IRule)" Parser "," Arguments ")"
		parameterOperator
			"new Argument." OperatorName "(" Left "," Right ")"
		parameterNewNumber
			"new Parameter<Integer>(" Value ")"
		parameterExisting
			"this." Parameter Name ""
		
	generate takes data
		set packageName
			rule buildString
				base getSeedName
				".rules"
		
		set directory			
			new File
				base getDirectory
				packageName replace
					"."
					"/"
		directory mkdirs
		var rules as ParseList			
			data getList
				"rules"
		rule generateAll
			rules getNewTokens
			"rule"
	
	generate root	
		var ruleName
			'root -> rulename
		var className
			rule camelize
				ruleName
		var fileName
			rule buildString
				className
				".java"
		
		list addClassList
			"rulenames"
			ruleName
			ruleName
			null
		
		entry rulenames = ruleElement [ruleName className]
		
		var seedName
			base getSeedName
		list addList
			{importRules {[seedName]}}
			"rules"
			ruleName
			rulenames
		
		entry param_list = {}
		entry param_declarations "" = {}
		entry parameters = {
			[packageName]
			[className]
			[className]
			param_declarations
			param_list
			[className]
			[ruleName] }
		rule addFile
			rule getDirectory
			fileName
			parameters
		
		var silence
			root -> silence
		var isSilent
			silence is not null and silence is not empty
		
		rule println
			">"
			ruleName
		
		entry parameterIndexEntries "" = {}
		var param_count
			0
		
		root to branch
			definition
				entry ruleEntry "" = {}
				if isSilent is true
					ruleEntry add
						setupSilence {}
				ruleEntry add
					setupAdd {generate definition<ruleName,3>}
				rule addEntry
					rule getDirectory
					fileName
					"rule"
					ruleEntry
			
			rule_param
				var rule_param
					'branch
				var rules_contains
					ruleParameterNames containsKey
						ruleName
				if not rules_contains
					ruleParameterNames put
						ruleName
						new ArrayList<String>
				var ruleParameterNamesList as List<String>
					ruleParameterNames get
						ruleName
				ruleParameterNamesList add
					rule_param
				param_declarations add
					parameterMember ["Integer" rule_param "Integer" "0"]
				param_list add
					[rule_param]
				parameterIndexEntries add 
					parameterIndex ['param_count rule_param]
				set param_count
					param_count+1
		
		rule addEntry
			rule getDirectory
			fileName
			"params"
			parameterGet {parameterIndexEntries}
	
	generate atom takes ruleName, tabs
		entry returnEntry = null
		var enclosingName
			null
		var enclosingList
			null
		var enclosingTokenName
			null
		atom to quark
			parameters
				var name
					quark -> name
				var listVar
					quark -> list
				var withToken
					quark -> tokenName
				if name is not null
					set enclosingName
						``'name``
				if listVar is not null
					set enclosingList
						``'listVar``
				if withToken is not null
					set enclosingTokenName
						``'withToken``		
			terminal
				set returnEntry
					generate terminal
			braced
				quark definition to energy					
					set returnEntry
						generate definition <ruleName,tabs>
			multiple
				var option
					'quark -> option
				flip option
					* = Many
					? = Optional
					+ = Multiple
				quark definition to energy
					set returnEntry
						multiple {[option] generate definition <ruleName,tabs>}
		
		if enclosingName is not null
			if enclosingList is not null
				if enclosingTokenName is not null
					set returnEntry
						addToListWithToken { (tabs+1 returnEntry) enclosingName enclosingList enclosingTokenName }
				else
					set returnEntry
						addToList { (tabs+1 returnEntry) enclosingName enclosingList }
			else
				set returnEntry
					as { (tabs+1 returnEntry) enclosingName }
		
		entry enclosingArgumentsStatement = {}
		atom parameter to energy
			enclosingArgumentsStatement add
				generate parameter
		if enclosingArgumentsStatement is not empty
			set returnEntry
				parameterWith {returnEntry enclosingArgumentsStatement}
		return
			(tabs returnEntry)
	
	generate parameter
		parameter to p
			definition
				error
					"Rules cannot have definitons as their parameter"
			arithmatic
				return
					generate arithmatic
		return
			null
	
	generate arithmatic
		entry left = null
		var operand
			null
		entry right = null
		arithmatic to element
			arithmatic
				if left is null
					set left
						generate arithmatic
				else
					set right
						generate arithmatic
			operand
				set operand
					'element
				flip operand
					* = Multiply
					/ = Divide
					+ = Add
					- = Subtract
					else
						error
							"Operand:"
							operand
							" not recognized."
			NUMBER
				if left is null
					set left
						parameterNewNumber {['element]}
				else
					set right
						parameterNewNumber {['element]}
			rule_parameters						
				if left is null
					set left
						parameterExisting {['element]}
				else
					set right
						parameterExisting {['element]}
		if right is null
			return
				left
		else
			return
				parameterOperator { [operand] left right }
	
	
	generate definition takes ruleName, tabs
		return
			generate definition2<ruleName,tabs,{}>
	
	generate definition2 takes ruleName, tabs, entries
		definition2 to element				
			choice
				element to choice
					definition
						entry nextChoices = {}
						generate definition2<ruleName,tabs,nextChoices>							
						entries addAll
							nextChoices
			chain
				entry chain = {}
				element atom to quark
					chain add
						generate atom
							ruleName
							tabs+2
				
				if chain is singular
					entries add
						chain single
				else
					entries add
						(tabs+1 chain {chain})
		if entries is singular
			return
				entries single
		else
			return
				(tabs choice {entries})
	
	generate terminal
		terminal to token
			ruleToken
				var ruleName
					rule camelize
						'token
				return
					rule_parser {[ruleName]}
			listsToken			
				var listName
					rule camelize
						'token
				if listName is "Listnames"
					return
						["com.rem.parser.parser.Listnames.parser"]
				else
					return
						rule_parser {[listName]}
			listToken
				var listName
					"#NO_LISTNAME_FOUND"
				token * to atom
					set listName
						-> name
				if listName is "listnames"
					var name
						rule buildString
							'token
							"s"
					return
						rule_name_parser {[name]}
				else
					var name
						rule camelize
							listName
					return
						listElement [name 'token]
			anyListNameToken					
				return
					rule_any_list_name {}
			token					
				return
					listElement ["Tokens" 'token]
			braceToken
				return
					listElement ["Braces" 'token]
		return
			null

list
	var listAssociatedClass
		new HashMap<String,String>
	var directory
		null
	
	elements
		outline
			"package lists;\n\n"+
			"import com.rem.parser.*;\n"+
			"import com.rem.parser.token.*;\n"+
			"import com.rem.parser.parser.*;\n" Other Imports	"\n"+
			"public class " Class Name " extends ParseList {\n\n"+
			"\t@Override\n"+
			"\tpublic String getName() {\n"+
			"\t\treturn \"" Plural Name "\";\n"+
			"\t}\n"+
			"\t@Override\n"+
			"\tpublic String getSingular() {\n"+
			"\t\treturn \"" Singular Name "\";\n"+
			"\t}\n\n" Entries "}"	
		importRules 
			"import base.rules.*;\n"
		class
			"\tpublic static final " Class "Parser " Name " = new " Class "Parser(" Parameters ");\n"
		parser
			"\n\tpublic static final ChoiceParser parser = new ChoiceParser(\n\t\t\t\t" Rules ");\n"
	
	generate takes data
		set directory	
			new File
				base getDirectory
				"lists"
		directory mkdirs
		var list_rules as ParseList			
			data getList
				"list_rules"
		list generateAll
			list_rules getNewTokens
			"list_rule"
	
	generate root
		var listName
			'root -> listname
		var indexOfDash
			listName indexOf
				"-"
		var singleListName
			listName
		if indexOfDash > -1
			set singleListName
				listName substring
					0
					indexOfDash
			set listName
				list buildString
					singleListName
					listName substring
						indexOfDash+1
						listName length
		entry fileParameters = {
					{}
					["Listnames"]
					["listnames"]
					["listname"] }
		list addFile
			directory
			"Listnames.java"
			fileParameters
		
		list addClassList
			"listnames"
			singleListName
			listName
			null
		
		var token_contains_list
			root contains listType
		if token_contains_list is true
			listAssociatedClass put
				listName
				list camelize
					'root -> listType
		
		var className
			list camelize
				listName
		var fileName
			list buildString
				className
				".java"
		
		var hasDefinition
			false
		
		root to element
			list_def
				var name
					'element -> parameters -> name
				
				token regexToken
					element -> regex
				var listAssociatedClassContainsKey
					listAssociatedClass containsKey
						listName
				if regexToken is null
					set regexToken
						element -> quote
					
					if not listAssociatedClassContainsKey
						listAssociatedClass put
							listName
							"Exact"
					else
						var listAssociatedClassListName
							listAssociatedClass get
								listName
						if listAssociatedClassListName is "Regex"
							listAssociatedClass put
								listName
								"Exact"
				else					
					if not listAssociatedClassContainsKey
						listAssociatedClass put
							listName
							"Regex"
					else
						var listAssociatedClassListName
							listAssociatedClass get
								listName
						if listAssociatedClassListName is "Exact"
							listAssociatedClass put
								listName
								"Regex"
				var regex
					'regexToken	
				token parameter
					element -> parameter
				entry parameterEntry = null
				if parameter is not null
					set parameterEntry
						rule generateDefinition
							parameter -> definition
							list buildString
								listName
								"$HIDDEN"
							5
				
				list addClassList
					listName
					name
					regex
					parameterEntry
				set hasDefinition
					true
	
	aux addClassList takes
			listName
			name
			regex
			parameter as Entry
		var containsAssociatedClass
			listAssociatedClass containsKey
				listName
		if not containsAssociatedClass
			listAssociatedClass put
				listName
				"Regex"
		
		entry params = {}
		if parameter is not null
			params add
				parameter
		params add
			``name``
		params add
			``listName``
		
		if "listnames" is listName		
			set regex
				list buildString
					regex					
					"\\b"
		params add
			``regex``
		
		var associatedClassName
			listAssociatedClass get
				listName
		entry listEntry = class {
			[associatedClassName]
			[name]
			[associatedClassName]
			params }
		list addList
			{}
			listName
			name
			listEntry
	
	aux addList takes
			imports
			listName
			name
			listEntry as Entry
		var className
			list camelize
				listName
		var fileName
			list buildString
				className
				".java"
		var listNameLength
			listName length
		var singularListName
			listName substring
				0
				listNameLength-1
		entry parameters = {
			imports
			[className]
			[listName]
			[singularListName] }
		
		list addFile
			directory
			fileName
			parameters
				
		var main as ListEntry
			list getOrAddEntry
				directory
				fileName
				"main"
				{}
		main setDelimiter
			""
		
		entry subs "" = {}
		if main is empty
			main add
				subs
			
			main add
				parser {{}}
		
		var main0 as ListEntry
			main get
				0
		main0 add
			listEntry
		var main1 as ElementEntry
			main get
				1
		var main10 as ListEntry
			main1 get
				0 
		main10 add
			name

