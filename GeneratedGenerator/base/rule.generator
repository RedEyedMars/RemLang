
rule
	var ruleParameterNames
		new HashMap<String,List<String>>
	var directory
		null
	var packageName
		null
	elements
		outline
			"package " Package Name ";\n\n"+			
			"import com.rem.parser.*;\n"+
			"import com.rem.parser.generation.*;\n"+
			"import com.rem.parser.token.*;\n"+
			"import com.rem.parser.parser.*;\n"+
			"import lists.*;\n\n"+
			"public class " Class Name " extends ConcreteRule {\n\n"+
			"\tpublic static final IRule parser = new " Class Name "();\n" Parameter Declarations "\n"+									
			"\tpublic " Class Name "(){\n"+
			"\t\tsuper(\"" Rule Name "\");\n"+
			"\t}\n"+
			"\t@Override\n"+
			"\tpublic void setup(){\n" RuleSetup "\n\t}\n\n}"				
		importRules 
			"import " Seed Name ".rules.*;\n"
		ruleElement
			"\tpublic static final IRule " Rule Name " = " Class Name ".parser;\n"
		setupSilence
			"\t\tisSilent(true);\n"
		setupAdd
			"\t\tset(" Rule Definition ");\n"		
		as
			"new AddTokenParser(" Inner Rule "," Token Name ")"
		recontextualizationParser
			"new ReContextParser(" Inner Rule "," Context Name "," List Name ")"
		addToList
			"new AddTokenToListParser(" Inner Rule "," Token Name "," List Name ")"
		addToListWithToken
			"new AddTokenToListParser(" Inner Rule "," Token Name "," List Name "," With Name ")"
		
		chain
			"new ChainParser(" Inner Rules ")"
		choice
			"new ChoiceParser(" Inner Rules ")"
		multiple
			"new " Parser Class Name "Parser(" Inner Rule ")"
		
		listElement
			"" List Name "." Parser Name ""
		rule_parser
			"" Name ".parser"
		rule_name_parser
			"new ListNameElementParser(\"" Name "\")"
		rule_any_list_name
			"AnyListNameParser.parser"		
		
		parameterMember
			"\tprivate Parameter<" Type"> " Parameter Name " = new Parameter<" Type ">(" Default Value ");\n"
		parameterIndex
			"\t\tcase " Index ": return " Parameter Name ";\n"
		parameterGet
			"\t\tswitch(i){\n" Params "\t\tdefault: return null;\n\t\t}\n"
		parameterWith
			"new WithParser((IRule)" Parser "," Arguments ")"
		parameterOperator
			"new Argument." OperatorName "(" Left "," Right ")"
		parameterNewNumber
			"new Argument.Number(" Value ")"
		parameterExisting
			"this." Parameter Name ""
	var ruleNameBuilder
		new StringBuilder
	aux setup takes data as ParseContext
		set packageName
			rule buildString
				base getSeedName
				".rules"
		set directory			
			new File
				base getDirectory
				packageName replace
					"."
					"/"
		directory mkdirs
	aux generate takes data as ParseContext
		var rules as ParseList			
			data getList
				"rules"
		rule generateAll
			rules getNewTokens
			"rule"
		rule println
			rule buildString
				"Ruleset:"
				'ruleNameBuilder
	
	
	generate root	
		var ruleName
			'root -> rulename
		var className
			rule camelize
				ruleName
		var fileName
			rule buildString
				className
				".java"
		
		list addClassList
			"rulenames"
			ruleName
			ruleName
			null
		
		entry rulenames = ruleElement {\ruleName \className}
		
		var seedName
			base getSeedName
		list addList
			{importRules {\seedName}}
			"rules"
			ruleName
			rulenames
		
		entry param_declarations "" = {}
		entry parameters = {
			\packageName
			\className
			\className
			param_declarations
			\className
			\ruleName }
		rule addFile
			rule getDirectory
			fileName
			parameters
		
		var silence
			root -> silence
		var isSilent
			silence is not null and silence is not empty
		
		ruleNameBuilder append
			ruleName
		ruleNameBuilder append
			","
		if root->isChoosy is not null
			entry ruleEntry "" = {}
			if isSilent is true
				ruleEntry += setupSilence {}
			ruleEntry += setupAdd { choice {{}}}
			rule addEntry
				rule getDirectory
				fileName
				"rule"
				ruleEntry
		else
			entry parameterIndexEntries "" = {}
			var param_count
				0		
			root to branch
				definition
					entry ruleEntry "" = {}
					if isSilent is true
						ruleEntry add
							setupSilence {}
					ruleEntry add
						setupAdd {generate definition:ruleName 3;}
					rule addEntry
						rule getDirectory
						fileName
						"rule"
						ruleEntry
				
				rule_param
					var rule_param
						'branch
					var rules_contains
						ruleParameterNames containsKey
							ruleName
					if not rules_contains
						ruleParameterNames put
							ruleName
							new ArrayList<String>
					var ruleParameterNamesList as List<String>
						ruleParameterNames get
							ruleName
					ruleParameterNamesList add
						rule_param
					param_declarations add
						parameterMember {\"Integer" \rule_param \"Integer" \"0"}
					parameterIndexEntries add 
						parameterIndex {\'param_count \rule_param}
					set param_count
						param_count+1
			
			rule addEntry
				rule getDirectory
				fileName
				"params"
				parameterGet {parameterIndexEntries}
	
	generate atom takes ruleName, tabs
		entry returnEntry = null
		var enclosingName
			null
		var enclosingList
			null
		var enclosingTokenName
			null
		var enclosingFromName
			null
		atom to quark
			parameters
				var name
					quark -> name
				var listVar
					quark -> list
				var withToken
					quark -> tokenName					
				var fromToken
					quark -> contextName
				if name is not null
					set enclosingName
						``'name``
				if listVar is not null
					set enclosingList
						``'listVar``
				if withToken is not null
					set enclosingTokenName
						``'withToken``				
				if fromToken is not null
					set enclosingFromName
						``'fromToken``
			terminal
				set returnEntry
					generate terminal
			braced
				quark definition to energy					
					set returnEntry
						generate definition:ruleName tabs;
			multiple
				var option
					'quark -> option
				flip option
					* = Many
					? = Optional
					+ = Multiple
				quark definition to energy
					set returnEntry
						multiple {\option generate definition:ruleName tabs;}
		if enclosingFromName is not null
			set returnEntry
				recontextualizationParser { (tabs+1 returnEntry) enclosingFromName enclosingList }
		else		
			if enclosingName is not null
				if enclosingList is not null
					if enclosingTokenName is not null
						set returnEntry
							addToListWithToken { (tabs+1 returnEntry) enclosingName enclosingList enclosingTokenName }
					else
						set returnEntry
							addToList { (tabs+1 returnEntry) enclosingName enclosingList }
				else
					set returnEntry
						as { (tabs+1 returnEntry) enclosingName }
			else
				if enclosingList is not null
					if enclosingTokenName is not null
						set returnEntry
							addToListWithToken { (tabs+1 returnEntry) \"null" enclosingList enclosingTokenName }
					else
						set returnEntry
							addToList { (tabs+1 returnEntry) \"null" enclosingList }
		
		entry enclosingArgumentsStatement = {}
		atom parameter to energy
			enclosingArgumentsStatement add
				generate parameter
		if enclosingArgumentsStatement is not empty
			set returnEntry
				parameterWith {returnEntry enclosingArgumentsStatement}
		return
			(tabs returnEntry)
	
	generate parameter
		parameter to p
			definition
				error
					"Rules cannot have definitons as their parameter"
			arithmatic
				return
					generate arithmatic
		return
			null
	
	generate arithmatic
		entry left = null
		var operand
			null
		entry right = null
		arithmatic to element
			arithmatic
				if left is null
					set left
						generate arithmatic
				else
					set right
						generate arithmatic
			operand
				set operand
					'element
				flip operand
					* = Multiply
					/ = Divide
					+ = Add
					- = Subtract
					else
						error
							"Operand:"
							operand
							" not recognized."
			NUMBER
				if left is null
					set left
						parameterNewNumber {\'element}
				else
					set right
						parameterNewNumber {\'element}
			rule_parameters						
				if left is null
					set left
						parameterExisting {\'element}
				else
					set right
						parameterExisting {\'element}
		if right is null
			return
				left
		else
			return
				parameterOperator { \operand left right }
	
	
	generate definition takes ruleName, tabs
		return
			generate definition2:ruleName tabs {};
	
	generate definition2 takes ruleName, tabs, entries
		definition2 to element				
			choice
				element to choice
					definition
						entry nextChoices = {}
						generate definition2:ruleName tabs nextChoices;							
						entries addAll
							nextChoices
			chain
				entry chain = {}
				element atom to quark
					chain add
						generate atom
							ruleName
							tabs+2
				
				if chain is singular
					entries add
						chain single
				else
					entries add
						(tabs+1 chain {chain})
		if entries is singular
			return
				entries single
		else
			return
				(tabs choice {entries})
	
	generate terminal
		var Xxx
			null
		terminal to token
			ruleToken
				var ruleName
					rule camelize
						'token
				return
					rule_parser {\ruleName}
			listsToken			
				var listName
					rule camelize
						'token
				if listName is "Listnames"
					return
						\"ListNameParser.parser"
				else
					return
						rule_parser {\listName}
			listToken
				var listName
					"#NO_LISTNAME_FOUND"
				token * to atom
					set listName
						-> name
				if listName is "listnames"
					var name
						rule buildString
							'token
							"s"
					return
						rule_name_parser {\name}
				else
					set listName
						rule camelize
							listName
					return
						listElement \listName \'token
			anyListNameToken					
				return
					rule_any_list_name {}
			token					
				return
					listElement \"Tokens" \'token
			braceToken
				return
					listElement \"Braces" \'token
		return
			null