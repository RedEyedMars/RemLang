uses ElementEntry
entry e_inner_call uses innerable importable
	entry value = null
	constructor takes iValue as ListEntry
		
		set value = iValue
		set isInner = true
		each v as Entry in iValue
			var valueAsImportable as importable = v
			this addImports
				valueAsImportable getImportPackage
	constructor takes iValue as Entry
		
		set value = iValue
		set isInner = true
		var valueAsImportable as importable = iValue
		this addImports
			valueAsImportable getImportPackage
	setValue takes newValue
		set value = newValue
	output
			external bodyInnerCall{value} if value is not null
entry e_quote uses innerable importable
	entry value = null
	constructor takes iValue as Entry
		
		set value = iValue
		set isInner = true
	setValue takes newValue
		set value = newValue
	output
			external bodyQuote{value} if value is not null
entry e_entry uses innerable importable
	entry value = null
	constructor takes iValue as Entry
		
		set value = iValue
		set isInner = true
	setValue takes newValue
		set value = newValue
	output
			external bodyEntry{value} if value is not null
entry e_exact uses innerable importable
	entry value = null
	constructor takes iValue as Entry
		
		set value = iValue
		set isInner = true
	setValue takes newValue
		set value = newValue
	output
			external bodyExact{value} if value is not null
entry e_name_var uses innerable importable
	entry first = null
	entry second = null
	var isConcat = false
	constructor takes iValue as Entry
		
		set first = iValue
	constructor takes iFirst as Entry, iSecond as Entry
		
		set first = iFirst
		set second = iSecond
	constructor takes iFirst as Entry, concat, iSecond as Entry
		
		set first = iFirst
		set second = iSecond
		set isConcat = true
	output
			external bodyName{first} if second is null
			external bodyName{external bodyConcat{first second}} if second is not null and isConcat is true
			external bodyName{classwise access{first second}} if second is not null and isConcat is false

entry e_type_var uses innerable importable canAddSubClass variablizable globalizable
	constant DEFAULT
		0
	constant CONCAT
		1
	constant ACCESS_CLASS
		2
	constant ACCESS_METHOD
		3
	entry first = null
	entry second = null
	var mode = DEFAULT
	entry templateParameters = {}
	var parentContext as context = null
	constructor
		set isVariable = false
		set first = {}
		first setDelimiter :".";
		set isGlobal = true
	constructor takes iValue as Entry, iContext as context
		set isVariable = false
		set first = {iValue}
		first setDelimiter :".";
		set isGlobal = true
		set parentContext = iContext
	constructor takes iValue as Entry, iTemplateParameters as ListEntry, importType as importable, iContext as context
		set isVariable = false
		set first = {iValue}
		set templateParameters = iTemplateParameters
		first setDelimiter :".";
		if importType is not null
			this addImports
				importType getImportPackage
		templateParameters setDelimiter
			","
		set isGlobal = true
		set parentContext = iContext
	constructor takes iFirst as Entry, operator, iSecond as Entry, iContext as context
		set isVariable = false
		set first = {iFirst}
		set second = iSecond
		if operator is "+"
			set mode = CONCAT
		else
			if operator is ".*"
				set mode = ACCESS_METHOD
			else
				set mode = ACCESS_CLASS
		first setDelimiter :".";
		set isGlobal = true
		set parentContext = iContext
	addSubClass takes newSubType as Entry
		first += newSubType
		var builder
			new StringBuilder
		first get
			builder
		var importType as importable
			classwise getType
				'builder
		this addImports
			importType getImportPackage
	output
			external bodyTypeName{first} if second is null and templateParameters is empty and isVariable is false and mode is DEFAULT
			external bodyTypeName{ classwise classAsVariable {first} } if second is null and templateParameters is empty and isVariable is true and isGlobal is true and mode is DEFAULT
			external bodyTypeName{ classwise retrieveClass {first} } if second is null and templateParameters is empty and isVariable is true and isGlobal is true and mode is DEFAULT
			external bodyTypeName{first} if second is null and templateParameters is empty and mode is DEFAULT
			external bodyTypeName{classwise concat{first second}} if second is not null and mode is CONCAT and templateParameters is empty
			external bodyTypeName{external accessClass{first second}} if second is not null and mode is ACCESS_CLASS and templateParameters is empty
			external bodyTypeName{external accessMethod{first second}} if second is not null and mode is ACCESS_METHOD and templateParameters is empty
			external bodyTypeNameWithParameters{first templateParameters} if second is null and templateParameters is not empty and mode is DEFAULT
			external bodyTypeNameWithParameters{classwise concat{first second} templateParameters} if second is not null and mode is CONCAT and templateParameters is not empty
			external bodyTypeNameWithParameters{classwise accessClass{first second} templateParameters} if second is not null and mode is ACCESS_CLASS and templateParameters is not empty
			external bodyTypeNameWithParameters{classwise accessMethod{first second} templateParameters} if second is not null and mode is ACCESS_METHOD and templateParameters is not empty
		if parentContext is not null and second is null and templateParameters is empty and isVariable is true and mode is DEFAULT
			var firstBuilder
				new StringBuilder
			first get
				firstBuilder
			if parentContext does containsMethodBoundClass 'firstBuilder
				set isGlobal = false
entry e_operator uses innerable importable
	entry left = null
	entry right = null
	entry operator = null
	constructor takes iLeft as Entry
		
		set left = iLeft
		var leftAsImportable as importable = iLeft
		this addImports
			leftAsImportable getImportPackage
	constructor takes iLeft as Entry, iOperator, iRight as Entry
		set left as Entry = iLeft
		set right as Entry = iRight
		set operator = ``iOperator``
		var leftAsImport as importable = iLeft
		var rightAsImport as importable = iRight
		this addImports
			leftAsImport getImportPackage
		this addImports
			rightAsImport getImportPackage
	output
			external bodyName{left} if right is null
			external bodyOperator{operator left right} if right is not null
entry e_for_int_header uses innerable importable
	entry left = null
	entry variableName = null
	entry right = null
	entry operator = null
	constructor takes iLeft as Entry, iOperator, iRight as Entry
		set left as Entry = iLeft
		set right as Entry = iRight
		var leftAsVariable as e_variable = iLeft
		leftAsVariable setAssignment
			e_exact:\"0";
		set variableName
			leftAsVariable getName
		set operator = ``iOperator``
		var leftAsImport as importable = iLeft
		var rightAsImport as importable = iRight
		this addImports
			leftAsImport getImportPackage
		this addImports
			rightAsImport getImportPackage
	output
			external bodyForIntHeader{left operator variableName right variableName} if right is not null
entry e_braced uses innerable importable
	entry subject = null
	entry operator = null
	entry after = null
	constructor takes iSubject as Entry, iOperator as Entry, iAfterSubject as Entry
		set isInner = false
		set subject = iSubject
		set operator = iOperator
		set after = iAfterSubject
	output
			external bodyBracedStatement { subject } if subject is not null and after is null and operator is null
			external bodyCastedStatement { subject after } if subject is not null and after is not null and operator is null
			external bodyBracedOperatorStatement { subject operator after } if subject is not null and after is not null and operator is not null
entry e_call uses innerable importable
	entry subject = null
	entry methodName = null
	entry parameters = null
	entry array_parameters = null
	constructor takes iMethodName as Entry, iParameters as ListEntry, iArrayParameters as ListEntry
		set methodName = iMethodName
		set parameters = iParameters
		set array_parameters = iArrayParameters
		if iParameters is not null
			each e as Entry in iParameters
				var i as importable = e
				this addImports
					i getImportPackage
			parameters setDelimiter :",";
		if iArrayParameters is not null
			array_parameters setDelimiter :",";
	constructor takes iSubject as Entry, iMethodName as Entry, iParameters as ListEntry, iArrayParameters as ListEntry
		set subject = iSubject
		var subjectAsImporable as importable = iSubject
		set methodName = iMethodName
		set parameters = iParameters
		set array_parameters = iArrayParameters
		this addImports
			subjectAsImporable getImportPackage
		if iParameters is not null
			each e as Entry in iParameters
				var i as importable = e
				this addImports
					i getImportPackage
			parameters setDelimiter :",";
		if iArrayParameters is not null
			array_parameters setDelimiter :",";
	constructor takes iMethodName as Entry, iParameters as ListEntry
		set methodName = iMethodName
		set parameters = iParameters
		each e as Entry in iParameters
			var i as importable = e
			this addImports
				i getImportPackage
		parameters setDelimiter
			","
	constructor takes iSubject as Entry, iMethodName as Entry, iParameters as ListEntry
		set subject = iSubject
		var subjectAsImporable as importable = iSubject
		set methodName = iMethodName
		set parameters = iParameters
		this addImports
			subjectAsImporable getImportPackage
		each e as Entry in iParameters
			var i as importable = e
			this addImports
				i getImportPackage
		parameters setDelimiter 
			","
	constructor takes iMethodName as Entry
		set methodName = iMethodName
	constructor takes iSubject as Entry, iMethodName as Entry
		set subject = iSubject
		var subjectAsImporable as importable = iSubject
		set methodName = iMethodName
		this addImports
			subjectAsImporable getImportPackage
	output
			external bodyCallWithoutSubjectWithArray{methodName parameters array_parameters} if subject is null and parameters is not null and array_parameters is not null
			external bodyCallWithSubjectWithArray{subject methodName parameters array_parameters} if subject is not null and parameters is not null and array_parameters is not null
			external bodyAccessWithoutSubjectWithArray{methodName array_parameters} if subject is null and parameters is null and array_parameters is not null
			external bodyAccessWithSubjectWithArray{subject methodName array_parameters} if subject is not null and parameters is null and array_parameters is not null
			external bodyCallWithoutSubject{methodName parameters} if subject is null and parameters is not null and array_parameters is null
			external bodyCallWithSubject{subject methodName parameters} if subject is not null and parameters is not null and array_parameters is null
			external bodyAccessWithoutSubject{methodName} if subject is null and parameters is null and array_parameters is null
			external bodyAccessWithSubject{subject methodName} if subject is not null and parameters is null and array_parameters is null
entry e_new_obj uses innerable importable
	entry className = null
	entry parameters = null
	entry array_parameters = null
	constructor takes iClassName as Entry, iParameters as ListEntry
		set className = iClassName
		set parameters = iParameters
		each e as Entry in iParameters
			var i as importable = e
			this addImports
				i getImportPackage
		parameters setDelimiter 
			","
	constructor takes iClassName as Entry, iParameters as ListEntry, iArrayParameters as ListEntry
		set className = iClassName
		set parameters = iParameters
		set array_parameters = iArrayParameters
		if iParameters is not null
			each e as Entry in iParameters
				var i as importable = e
				this addImports
					i getImportPackage
			parameters setDelimiter 
				","
		if iArrayParameters is not null
			array_parameters setDelimiter :",";
	output
			external bodyNewObjPA{className parameters array_parameters} if parameters is not null and array_parameters is not null
			external bodyNewObjP{className parameters} if parameters is not null and array_parameters is null
			external bodyNewObjA{className array_parameters} if parameters is null and array_parameters is not null
			external bodyNewObj {className} if parameters is null and array_parameters is null
entry e_conditional uses innerable importable contextualizable
	entry name = null
	entry header = null
	entry conditionalBody = null
	entry asInnerCall = null
	constructor takes iName, iHeader as Entry, iBody as ListEntry, iContext as context
		set name = \iName
		set header = iHeader
		set conditionalBody = {}
		set context = iContext
		if header is not null
			var headerAsImportable as importable = iHeader
			this addImports
				headerAsImportable getImportPackage
		var bodyContext = context:iContext;
		var semicolon = ";"
		each e as Entry in iBody
			var i as importable = e
			this addImports
				i getImportPackage
			conditionalBody +=	e
		
		conditionalBody setDelimiter
			",\n/*BODY*/\t\t\t\t"
	constructor takes iName, iHeader as Entry, iBody as e_inner_call, iContext as context
		set name = \iName
		set header = iHeader
		set conditionalBody = {}
		set asInnerCall = iBody
		set context = iContext
		if header is not null
			var headerAsImportable as importable = iHeader
			this addImports
				headerAsImportable getImportPackage
		var bodyContext = context:iContext;
		var semicolon = ";"
	output
			(tabs external bodyConditional             {name header asInnerCall })                         if header is not null and asInnerCall is not null 
			(tabs external bodyConditionalWithoutHeader{name        asInnerCall })                         if header is     null and asInnerCall is not null
			(tabs external bodyConditional             {name header external bodyBody{ conditionalBody} }) if header is not null and asInnerCall is null
			(tabs external bodyConditionalWithoutHeader{name        external bodyBody{ conditionalBody} }) if header is null     and asInnerCall is null
		if context is null
			set tabs = 0
		else
			set tabs
				context getTab
		e_tabs set :'tabs;
entry e_case uses innerable importable contextualizable
	entry header = null
	entry caseBody = null
	entry asInnerCall = null
	constructor takes iHeader as Entry, iBody as ListEntry, iContext as context
		set header = iHeader
		set caseBody = {}
		set context = iContext
		if header is not null
			var headerAsImportable as importable = iHeader
			this addImports
				headerAsImportable getImportPackage
		var bodyContext = context:iContext;
		each e as Entry in iBody
			var i as importable = e
			this addImports
				i getImportPackage
			caseBody +=	e
		
		caseBody setDelimiter
			",\n/*BODY*/\t\t\t\t"
	constructor takes iHeader as Entry, iBody as e_inner_call, iContext as context
		set header = iHeader
		set caseBody = {}
		set asInnerCall = iBody
		set context = iContext
		if header is not null
			var headerAsImportable as importable = iHeader
			this addImports
				headerAsImportable getImportPackage
	output
			(tabs external bodyCase {header asInnerCall })                  if asInnerCall is not null
			(tabs external bodyCase {header external bodyBody{ caseBody} }) if asInnerCall is null
		if context is null
			set tabs = 0
		else
			set tabs
				context getTab
		e_tabs set :'tabs;
entry e_throw uses innerable importable contextualizable
	entry value = null
	constructor takes iValue as Entry, iContext as context
		set value = iValue
		set context = iContext
		var valueAsImportable as importable = iValue
		this addImports
			valueAsImportable getImportPackage
	output
			(tabs external bodyThrow{value}) if context is not null 
		if context is null
			set tabs = 0
		else
			set tabs
				context getTab
		e_tabs set :'tabs;
entry e_element uses innerable importable contextualizable
	entry preffix = null
	entry suffix = null
	entry value = null
	constructor takes iPreffix, iValue as Entry, iSuffix, iContext as context
		
		set preffix = ``iPreffix``
		set suffix = ``iSuffix``
		set value = iValue
		set context = iContext
		var valueAsImportable as importable = iValue
		this addImports
			valueAsImportable getImportPackage
	output
			(tabs external bodyElement{preffix suffix value}) if context is not null 
		if context is null
			set tabs = 0
		else
			set tabs
				context getTab
		e_tabs set :'tabs;
entry e_body uses innerable importable
	entry realBody = null
	constructor takes iBody as ListEntry
		
		set realBody = {}
		each e as Entry in iBody
			var i as importable = e
			this addImports
				i getImportPackage
			realBody +=	e
		
		realBody setDelimiter
			",\n/*BODY*/\t\t\t\t"
	output
			external bodyBody{realBody} if realBody is not null
entry e_variable uses innerable importable nameable finalizable statickable inlinelistable arraytypeable
	entry type = null
	entry assignment  = null
	var variableIndex = null
	constructor takes iType as Entry, iName as Entry, iAssignment as Entry, iIndex as Integer
		set variableIndex = 'iIndex
		set name = iName
		set type = iType
		var typeAsImportable as importable = iType
		set assignment = iAssignment
		this setIsFinal :true;
		this addImports
			typeAsImportable getImportPackage
	setAssignment takes newAssignment as Entry
		set assignment = newAssignment
		if assignment is not null
			var assignmentAsImportable as importable = assignment
			this addImports
				assignmentAsImportable getImportPackage
	output
			external declareVariableAsInlineList { type arrayType name } if isInlineList is true
			external declareVariableWithAssignmentFinal { type arrayType name assignment} if assignment is not null and isStatic is false and isFinal is true
			external declareVariableWithAssignmentNonFinal { type arrayType name assignment} if assignment is not null and isStatic is false and isFinal is false
			external declareVariableWithoutAssignmentFinal { type arrayType name } if assignment is null and isFinal is true and isStatic is false
			external declareVariableWithoutAssignmentNonFinal { type arrayType name } if assignment is null and isFinal is false and isStatic is false
			external declareStaticVariableWithAssignment { type arrayType name assignment} if assignment is not null and isStatic is true
			external declareStaticVariableWithoutAssignmentNonFinal { type arrayType name } if assignment is null and isFinal is false and isStatic is true
			external declareStaticVariableWithoutAssignmentFinal { type arrayType name } if assignment is null and isFinal is true and isStatic is true

entry e_method uses innerable importable contextualizable nameable interfaceable statickable arraytypeable
	entry type = null
	entry parameters  = null
	entry methodBody = null
	entry sThrows = null
	var pas = false
	var methodIndex = null
	constructor takes iType as Entry, iName as Entry, iParametersAreStatement as Boolean, iParameters as ListEntry, iThrows as ListEntry, iMethodBody as ListEntry, iContext as context, iIndex as Integer
		set methodIndex = 'iIndex
		set pas = iParametersAreStatement
		set name = iName
		set type = iType
		var typeAsImportable as importable = iType
		set parameters = iParameters
		set methodBody = {}
		set context = iContext
		this addImports
			typeAsImportable getImportPackage
		each e as Entry in iParameters
			var i as importable = e
			this addImports
				i getImportPackage
		if iThrows is not empty
			set sThrows as Entry = external throwsStatement {iThrows}
		else
			set sThrows as Entry = {}
		var methodBodyContext = context:iContext;
		var semicolon = ";"
		each e as Entry in iMethodBody
			var i as importable = e
			this addImports
				i getImportPackage
			methodBody += e
		parameters setDelimiter
			",\n/*PARAMS*/\t\t\t\t"
		methodBody setDelimiter
			",\n/*BODY*/\t\t\t\t"
	output
			external declareStaticMethod{e_tabs type arrayType name parameters sThrows external bodyBody{methodBody}} if isStatic is true and pas is true
			external declareInterfaceMethod{e_tabs type arrayType name parameters sThrows }                     if isInterface is true and pas is true
			external declareMethod{e_tabs type arrayType name parameters sThrows external bodyBody{methodBody}} if isInterface is false and pas is true
			external declareStaticMethod{e_tabs type arrayType name external bodyParameters{parameters} sThrows external bodyBody{methodBody}} if isStatic is true and pas is false
			external declareInterfaceMethod{e_tabs type arrayType name external bodyParameters{parameters} sThrows }                     if isInterface is true and pas is false
			external declareMethod{e_tabs type arrayType name external bodyParameters{parameters} sThrows external bodyBody{methodBody}} if isInterface is false and pas is false
		if context is null
			set tabs = 0
		else
			set tabs
				context getTab
		e_tabs set :'tabs;
entry e_class uses innerable nameable importable contextualizable fileable interfaceable globalizable
	var classIndex = null
	var packageName as Entry = null
	var externalPackageName as Entry = null
	entry asStatic = \""
	entry asFile = null
	entry asFileVariable = null
	entry asInternalFile = null
	entry asArgument = null
	entry classType = null
	var externalName as Entry = null
	var externalTemplateTypeName as Entry = null
	var externalParent as Entry = null
	var externalParentEntry as Entry = null
	var externalInterfaces as Entry = null
	var parent as Entry = null
	var interfaces as Entry = null
	entry internalVariables = {}
	entry externalVariables = {}
	entry internalMethods = {}
	entry externalMethods = {}
	entry internalSubClasses = {}
	entry externalSubClasses = {}
	entry externalConstructorVariableAddMethodCalls = {}
	entry externalConstructorMethodAddMethodCalls = {}
	entry externalConstructorSubClassAddMethodCalls = {}
	entry externalConstructorVariables = {}
	entry externalConstructorMethods = {}
	entry externalConstructorSubClass = {}
	entry externalInterfacesEntry = {}
	entry getHeader = null
	var isSubClass  = false
	var isWeak      = false
	var hasOutput   = false
	var completeUnsulliedName as ListEntry = {}
	constructor takes iPackageName as Entry, iType, sName, iName as Entry, templateTypeName as IToken, iParent as Entry, iInterfaces as ListEntry, iVariables as ListEntry, iMethods as ListEntry, iContext as context, iIndex as Integer
		set classIndex = 'iIndex
		set isInner = false
		set packageName = iPackageName
		set name = \sName
		set completeName = {classwise retrieveClass{\sName}}
		set completeUnsulliedName = {iName}
		completeName setDelimiter :".";
		completeUnsulliedName setDelimiter :".";
		var establishedImportable as importable
			classwise getType
				this getFullName
		set importPackage
			establishedImportable getImportPackage
		if packageName is not null
			importPackage addPackage
				packageName
				completeUnsulliedName
			set externalPackageName = external exactEntry { packageName }
		else
			set externalPackageName = \"null"
		importPackage setIsInner :false;
		set classType = \iType
		if iType does contains "interface"
			this setIsInterface :true;
		
		set externalName = external exact{iName}
		if templateTypeName is not null
			set externalTemplateTypeName = external asTemplate{\'templateTypeName}
		else
			set externalTemplateTypeName = external exact{``""``}
		if iParent is not null
			set parent = classwise extends{iParent}
			set externalParent = external extends { iParent }
			set externalParentEntry = iParent
			var iParentType as importable = iParent
			this addImports
				iParentType getImportPackage
		else
			set parent = {}
			set externalParent      = external exact{``""``}
			set externalParentEntry = \"null"
		if iInterfaces is not empty
			set interfaces = classwise implements{iInterfaces}
			entry extItrf = {} 
			each itrf as Entry in iInterfaces
				var iIntefaceType as importable = itrf
				this addImports
					iIntefaceType getImportPackage
				extItrf += itrf
			extItrf setDelimiter
				".get(builder);builder.append(\",\"); "
			set externalInterfaces = external implements {extItrf}
			
		else
			set interfaces = {}
			set externalInterfaces = external exact{``""``}
		set externalInterfacesEntry = external asEntryList{iInterfaces}
		each ev as Entry in iVariables
			var i as innerable = ev
			if i does getIsInner
				var niv as i_variable = ev
				this addVariable
					niv
			else
				var nev as e_variable = ev
				this addVariable
					nev
		each e as Entry in iMethods
			var i as innerable = e
			if i does getIsInner
				var niv as i_method = e
				this addMethod
					niv
			else
				var nev as e_method = e
				this addMethod
					nev
		set context = iContext
		var addMethodDelimiter
			""
		internalVariables setDelimiter :"";
		externalVariables setDelimiter :"";
		internalMethods setDelimiter :"";
		externalMethods setDelimiter :"";
		internalSubClasses setDelimiter :"";
		externalSubClasses setDelimiter :"";
		externalConstructorVariableAddMethodCalls setDelimiter :addMethodDelimiter;
		externalConstructorMethodAddMethodCalls setDelimiter :addMethodDelimiter;
		externalConstructorSubClassAddMethodCalls setDelimiter :addMethodDelimiter;
		externalConstructorVariables setDelimiter :"";
		externalConstructorMethods setDelimiter :"";
		externalConstructorSubClass setDelimiter :"";
		
		set getHeader = i_exact:(2 external getCompleteHeader{asStatic classType externalName externalTemplateTypeName});
		
		set asFile = i_exact:external declareClass{name name internalVariables internalMethods internalSubClasses externalSubClasses externalPackageName importPackage->EXTERNAL externalName ``iType`` externalParentEntry externalInterfacesEntry getHeader externalConstructorVariableAddMethodCalls externalConstructorMethodAddMethodCalls externalConstructorSubClassAddMethodCalls externalConstructorVariables externalConstructorMethods externalConstructorSubClass };
		var classwizeImports as Entry
			classwise getInternalImports
		set asInternalFile = i_exact:external declareOutputClass{classwizeImports name internalVariables internalMethods internalSubClasses externalSubClasses externalPackageName importPackage->EXTERNAL externalName ``iType`` externalParentEntry externalInterfacesEntry getHeader externalConstructorVariableAddMethodCalls externalConstructorMethodAddMethodCalls externalConstructorSubClassAddMethodCalls externalConstructorVariables externalConstructorMethods externalConstructorSubClass };
		set asFileVariable = i_exact: external declareNewClass { name } ;
		set asArgument = i_exact:external declareClassAsArgument{externalPackageName importPackage->EXTERNAL externalName ``iType`` externalParentEntry externalInterfacesEntry getHeader externalConstructorVariableAddMethodCalls externalConstructorMethodAddMethodCalls externalConstructorSubClassAddMethodCalls externalConstructorVariables externalConstructorMethods externalConstructorSubClass};
	addVariable takes i as i_variable
		internalVariables+=(2 internal declareMemberComplete{i})
		var iAssignment as Entry
			i getAssignment
		if iAssignment is null
			var iType as Entry
				i getType
			i setAssignment
				i_new_obj:iType {};
	addVariable takes e as e_variable
		var eName as Entry
			e getName
		var eAssignment as Entry
			e getAssignment
		if eAssignment is null
			var eType as Entry
				e getType
			e setAssignment
				e_new_obj:eType {};
		externalVariables+=(2 internal declareMemberClass{eName eName external declareMember{e_tabs e}})
		
		var eId as String
			e getVariableIndex
		externalConstructorVariableAddMethodCalls += external callVariableAddMethod {\eId}
		externalConstructorVariables += external declareVariableAddMethod {\eId e}
		this addImports
			e getImportPackage
	addMethod takes i as i_method
		internalMethods+=(1 |i|)
	addMethod takes e as e_method
		var eName as Entry
			e getName
		e setIsInterface :isInterface;
		externalMethods += (1 internal declareMemberMethod{eName e})
		var eId as String
			e getMethodIndex
		externalConstructorMethodAddMethodCalls += external callMethodAddMethod {\eId}
		externalConstructorMethods += external declareMethodAddMethod {\eId e}
		this addImports
			e getImportPackage
	addSubClass takes i as i_class
		internalSubClasses+=(1 |i|)
		i setIsSubClass :completeName true;
		var theirContext as context
			i getContext
		theirContext setParentContext:context;
		this addImports
			i getImportPackage
	addSubClass takes e as e_class
		var ePlainName as Entry
			e getName
		var eName
			classwise buildString
				e getName
				"Class"
		var eAsFile as Entry
			e getAsFile
		externalSubClasses+=(1 internal declareMemberClass{ePlainName ePlainName eAsFile})
		var eId as String
			e getClassIndex
		externalConstructorSubClassAddMethodCalls += external callSubClassAddMethod {\eId}
		externalConstructorSubClass += external declareSubClassAddMethod {\eId e}
		this addImports
			e getImportPackage
		e setIsSubClass : completeName completeUnsulliedName true;
		var theirContext as context
			e getContext
		theirContext setParentContext:context;
		
		var nameBuilder
			new StringBuilder
		ePlainName get
			nameBuilder
		clazz addDefinedClassName
			'nameBuilder
	setIsSubClass takes superCompleteName as Entry, superUnsulliedName as Entry, newStatus
		set isSubClass = newStatus
		if isSubClass is true and isWeak is not true
			asStatic set :"static";
		else
			asStatic set :"";
		completeName clear
		completeName +=	superCompleteName
		completeName += classwise classAsVariable{name}
		
		completeUnsulliedName clear
		completeUnsulliedName += superUnsulliedName
	setIsWeak takes newIsWeak as Boolean
		set isWeak = newIsWeak
		if isWeak is true
			asStatic set :"";
	output
			classwise retrieveClass { completeName } if name is not null and isGlobal is true
			|completeName| if name is not null and isGlobal is false
		if context is null
			set tabs = 0
		else
			set tabs
				context getTab
		e_tabs set :'tabs;
