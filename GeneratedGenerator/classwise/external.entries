uses ElementEntry
entry e_inner_call uses innerable importable
	entry value = null
	constructor takes iValue as ListEntry
		
		set value = iValue
		set isInner = true
		each v as Entry in iValue
			var valueAsImportable as importable = v
			this addImports
				valueAsImportable getImportPackage
	constructor takes iValue as Entry
		
		set value = iValue
		set isInner = true
		var valueAsImportable as importable = iValue
		this addImports
			valueAsImportable getImportPackage
	setValue takes newValue
		set value = newValue
	output
			external bodyInnerCall{value} if value is not null
entry e_quote uses innerable importable
	entry value = null
	constructor takes iValue as Entry
		
		set value = iValue
		set isInner = true
	setValue takes newValue
		set value = newValue
	output
			external bodyQuote{value} if value is not null
entry e_entry uses innerable importable
	entry value = null
	constructor takes iValue as Entry
		
		set value = iValue
		set isInner = true
	setValue takes newValue
		set value = newValue
	output
			external bodyEntry{value} if value is not null
entry e_exact uses innerable importable
	entry value = null
	constructor takes iValue as Entry
		
		set value = iValue
		set isInner = true
	setValue takes newValue
		set value = newValue
	output
			external bodyExact{value} if value is not null
entry e_name_var uses innerable importable
	entry first = null
	entry second = null
	var isConcat = false
	constructor takes iValue as Entry
		
		set first = iValue
	constructor takes iFirst as Entry, iSecond as Entry
		
		set first = iFirst
		set second = iSecond
	constructor takes iFirst as Entry, concat, iSecond as Entry
		
		set first = iFirst
		set second = iSecond
		set isConcat = true
	output
			external bodyName{first} if second is null
			external bodyName{external bodyConcat{first second}} if second is not null and isConcat is true
			external bodyName{classwise access{first second}} if second is not null and isConcat is false

entry e_type_var uses innerable importable canAddSubClass variablizable
	constant DEFAULT
		0
	constant CONCAT
		1
	constant ACCESS_CLASS
		2
	constant ACCESS_METHOD
		3
	entry first = null
	entry second = null
	var mode = DEFAULT
	entry templateParameters = {}
	constructor
		set isVariable = false
		set first = {}
		first setDelimiter :".";
	constructor takes iValue as Entry
		set isVariable = false
		set first = {iValue}
		first setDelimiter :".";
	constructor takes iValue as Entry, iTemplateParameters as ListEntry, importType as importable
		set isVariable = false
		set first = {iValue}
		set templateParameters = iTemplateParameters
		first setDelimiter :".";
		if importType is not null
			this addImports
				importType getImportPackage
		templateParameters setDelimiter
			","
	constructor takes iFirst as Entry, operator, iSecond as Entry
		set isVariable = false
		set first = {iFirst}
		set second = iSecond
		if operator is "+"
			set mode = CONCAT
		else
			if operator is ".*"
				set mode = ACCESS_METHOD
			else
				set mode = ACCESS_CLASS
		first setDelimiter :".";
	addSubClass takes newSubType as Entry
		first += newSubType
		var builder
			new StringBuilder
		first get
			builder
		var importType as importable
			classwise getType
				'builder
		this addImports
			importType getImportPackage
	output
			external bodyTypeName{first} if second is null and templateParameters is empty and isVariable is false and mode is DEFAULT
			external bodyTypeName{ classwise classAsVariable {first} } if second is null and templateParameters is empty and isVariable is true and mode is DEFAULT
			external bodyTypeName{first} if second is null and templateParameters is empty and mode is DEFAULT
			external bodyTypeName{classwise concat{first second}} if second is not null and mode is CONCAT and templateParameters is empty
			external bodyTypeName{external accessClass{first second}} if second is not null and mode is ACCESS_CLASS and templateParameters is empty
			external bodyTypeName{external accessMethod{first second}} if second is not null and mode is ACCESS_METHOD and templateParameters is empty
			external bodyTypeNameWithParameters{first templateParameters} if second is null and templateParameters is not empty and mode is DEFAULT
			external bodyTypeNameWithParameters{classwise concat{first second} templateParameters} if second is not null and mode is CONCAT and templateParameters is not empty
			external bodyTypeNameWithParameters{classwise accessClass{first second} templateParameters} if second is not null and mode is ACCESS_CLASS and templateParameters is not empty
			external bodyTypeNameWithParameters{classwise accessMethod{first second} templateParameters} if second is not null and mode is ACCESS_METHOD and templateParameters is not empty

entry e_operator uses innerable importable
	entry left = null
	entry right = null
	entry operator = null
	constructor takes iLeft as Entry
		
		set left = iLeft
		var leftAsImportable as importable = iLeft
		this addImports
			leftAsImportable getImportPackage
	constructor takes iLeft as Entry, iOperator, iRight as Entry
		set left as Entry = iLeft
		set right as Entry = iRight
		set operator = ``iOperator``
		var leftAsImport as importable = iLeft
		var rightAsImport as importable = iRight
		this addImports
			leftAsImport getImportPackage
		this addImports
			rightAsImport getImportPackage
	output
			external bodyName{left} if right is null
			external bodyOperator{operator left right} if right is not null
entry e_call uses innerable importable
	entry subject = null
	entry methodName = null
	entry parameters = null
	constructor takes iMethodName as Entry, iParameters as ListEntry
		set methodName = iMethodName
		set parameters = iParameters
		each e as Entry in iParameters
			var i as importable = e
			this addImports
				i getImportPackage
		parameters setDelimiter
			","
	constructor takes iSubject as Entry, iMethodName as Entry, iParameters as ListEntry
		set subject = iSubject
		var subjectAsImporable as importable = iSubject
		set methodName = iMethodName
		set parameters = iParameters
		this addImports
			subjectAsImporable getImportPackage
		each e as Entry in iParameters
			var i as importable = e
			this addImports
				i getImportPackage
		parameters setDelimiter 
			","
	constructor takes iMethodName as Entry
		set methodName = iMethodName
	constructor takes iSubject as Entry, iMethodName as Entry
		set subject = iSubject
		var subjectAsImporable as importable = iSubject
		set methodName = iMethodName
		this addImports
			subjectAsImporable getImportPackage
	output
			external bodyCallWithoutSubject{methodName parameters} if subject is null and parameters is not null
			external bodyCallWithSubject{subject methodName parameters} if subject is not null and parameters is not null
			external bodyAccessWithoutSubject{methodName} if subject is null and parameters is null
			external bodyAccessWithSubject{subject methodName} if subject is not null and parameters is null
entry e_new_obj uses innerable importable
	entry className = null
	entry parameters = null
	constructor takes iClassName as Entry, iParameters as ListEntry
		
		set className = iClassName
		set parameters = iParameters
		each e as Entry in iParameters
			var i as importable = e
			this addImports
				i getImportPackage
		parameters setDelimiter 
			","
	output
			external bodyNewObj{className parameters} if className is not null
entry e_conditional uses innerable importable contextualizable
	entry name = null
	entry header = null
	entry conditionalBody = null
	entry asInnerCall = null
	constructor takes iName, iHeader as Entry, iBody as ListEntry, iContext as context
		set name = \iName
		set header = iHeader
		set conditionalBody = {}
		set context = iContext
		if header is not null
			var headerAsImportable as importable = iHeader
			this addImports
				headerAsImportable getImportPackage
		var bodyContext = context:iContext;
		var semicolon = ";"
		each e as Entry in iBody
			var i as importable = e
			this addImports
				i getImportPackage
			conditionalBody +=	e
		
		conditionalBody setDelimiter
			",\n/*BODY*/\t\t\t\t"
	constructor takes iName, iHeader as Entry, iBody as e_inner_call, iContext as context
		set name = \iName
		set header = iHeader
		set conditionalBody = {}
		set asInnerCall = iBody
		set context = iContext
		if header is not null
			var headerAsImportable as importable = iHeader
			this addImports
				headerAsImportable getImportPackage
		var bodyContext = context:iContext;
		var semicolon = ";"
	output
			(tabs external bodyConditional             {name header asInnerCall })                         if header is not null and asInnerCall is not null 
			(tabs external bodyConditionalWithoutHeader{name        asInnerCall })                         if header is     null and asInnerCall is not null
			(tabs external bodyConditional             {name header external bodyBody{ conditionalBody} }) if header is not null and asInnerCall is null
			(tabs external bodyConditionalWithoutHeader{name        external bodyBody{ conditionalBody} }) if header is null     and asInnerCall is null
		if context is null
			set tabs = 0
		else
			set tabs
				context getTab
		e_tabs set :'tabs;
entry e_case uses innerable importable contextualizable
	entry header = null
	entry caseBody = null
	entry asInnerCall = null
	constructor takes iHeader as Entry, iBody as ListEntry, iContext as context
		set header = iHeader
		set caseBody = {}
		set context = iContext
		if header is not null
			var headerAsImportable as importable = iHeader
			this addImports
				headerAsImportable getImportPackage
		var bodyContext = context:iContext;
		each e as Entry in iBody
			var i as importable = e
			this addImports
				i getImportPackage
			caseBody +=	e
		
		caseBody setDelimiter
			",\n/*BODY*/\t\t\t\t"
	constructor takes iHeader as Entry, iBody as e_inner_call, iContext as context
		set header = iHeader
		set caseBody = {}
		set asInnerCall = iBody
		set context = iContext
		if header is not null
			var headerAsImportable as importable = iHeader
			this addImports
				headerAsImportable getImportPackage
	output
			(tabs external bodyCase {header asInnerCall })                  if asInnerCall is not null
			(tabs external bodyCase {header external bodyBody{ caseBody} }) if asInnerCall is null
		if context is null
			set tabs = 0
		else
			set tabs
				context getTab
		e_tabs set :'tabs;
entry e_throw uses innerable importable contextualizable
	entry value = null
	constructor takes iValue as Entry, iContext as context
		set value = iValue
		set context = iContext
		var valueAsImportable as importable = iValue
		this addImports
			valueAsImportable getImportPackage
	output
			(tabs external bodyThrow{value}) if context is not null 
		if context is null
			set tabs = 0
		else
			set tabs
				context getTab
		e_tabs set :'tabs;
entry e_element uses innerable importable contextualizable
	entry preffix = null
	entry suffix = null
	entry value = null
	constructor takes iPreffix, iValue as Entry, iSuffix, iContext as context
		
		set preffix = ``iPreffix``
		set suffix = ``iSuffix``
		set value = iValue
		set context = iContext
		var valueAsImportable as importable = iValue
		this addImports
			valueAsImportable getImportPackage
	output
			(tabs external bodyElement{preffix suffix value}) if context is not null 
		if context is null
			set tabs = 0
		else
			set tabs
				context getTab
		e_tabs set :'tabs;
entry e_body uses innerable importable
	entry realBody = null
	constructor takes iBody as ListEntry
		
		set realBody = {}
		each e as Entry in iBody
			var i as importable = e
			this addImports
				i getImportPackage
			realBody +=	e
		
		realBody setDelimiter
			",\n/*BODY*/\t\t\t\t"
	output
			external bodyBody{realBody} if realBody is not null
entry e_variable uses innerable importable nameable finalizable statickable inlinelistable
	entry type = null
	entry assignment  = null
	constructor takes iType as Entry, iName as Entry, iAssignment as Entry
		
		set name = iName
		set type = iType
		var typeAsImportable as importable = iType
		set assignment = iAssignment
		this addImports
			typeAsImportable getImportPackage
	setAssignment takes newAssignment as Entry
		set assignment = newAssignment
		if assignment is not null
			var assignmentAsImportable as importable = assignment
			this addImports
				assignmentAsImportable getImportPackage
	output
			external declareVariableAsInlineList { type name } if isInlineList is true
			external declareVariableWithAssignment { type name assignment} if assignment is not null and isStatic is false
			external declareVariableWithoutAssignmentNonFinal { type name } if assignment is null and isFinal is false and isStatic is false
			external declareVariableWithoutAssignmentFinal { type name } if assignment is null and isFinal is true and isStatic is false
			external declareStaticVariableWithAssignment { type name assignment} if assignment is not null and isStatic is true
			external declareStaticVariableWithoutAssignmentNonFinal { type name } if assignment is null and isFinal is false and isStatic is true
			external declareStaticVariableWithoutAssignmentFinal { type name } if assignment is null and isFinal is true and isStatic is true

entry e_method uses innerable importable contextualizable nameable interfaceable
	entry type = null
	entry parameters  = null
	entry methodBody = null
	constructor takes iType as Entry, iName as Entry, iParameters as ListEntry, iMethodBody as ListEntry, iContext as context
		
		set name = iName
		set type = iType
		var typeAsImportable as importable = iType
		set parameters = iParameters
		set methodBody = {}
		set context = iContext
		this addImports
			typeAsImportable getImportPackage
		each e as Entry in iParameters
			var i as importable = e
			this addImports
				i getImportPackage
		var methodBodyContext = context:iContext;
		var semicolon = ";"
		each e as Entry in iMethodBody
			var i as importable = e
			this addImports
				i getImportPackage
			methodBody += e
		parameters setDelimiter
			",\n/*PARAMS*/\t\t\t\t"
		methodBody setDelimiter
			",\n/*BODY*/\t\t\t\t"
	output
			external declareInterfaceMethod{e_tabs type name external bodyParameters{parameters} }                     if isInterface is true
			external declareMethod{e_tabs type name external bodyParameters{parameters} external bodyBody{methodBody}} if isInterface is false 
		if context is null
			set tabs = 0
		else
			set tabs
				context getTab
		e_tabs set :'tabs;
entry e_class uses innerable nameable importable contextualizable fileable interfaceable
	entry packageName = null
	entry asStatic = \""
	entry asFile = null
	entry asArgument = null
	entry classType = null
	var externalName as Entry = null
	var externalTemplateTypeName as Entry = null
	var externalParent as Entry = null
	var externalParentEntry as Entry = null
	var externalInterfaces as Entry = null
	var parent as Entry = null
	var interfaces as Entry = null
	entry internalVariables = {}
	entry externalVariables = {}
	entry internalMethods = {}
	entry externalMethods = {}
	entry internalSubClasses = {}
	entry externalSubClasses = {}
	entry externalConstructorVariables = {}
	entry externalConstructorMethods = {}
	entry externalConstructorSubClass = {}
	entry getHeader = null
	var isSubClass = false
	var hasOutput = false
	var completeUnsulliedName as ListEntry = {}
	constructor takes iPackageName as Entry, iType, sName, iName as Entry, templateTypeName as IToken, iParent as Entry, iInterfaces as ListEntry, iVariables as ListEntry, iMethods as ListEntry, iContext as context
		set isInner = false
		set packageName = iPackageName
		set name = \sName
		set completeName = {classwise classAsVariable{\sName}}
		set completeUnsulliedName = {\sName}
		completeName setDelimiter :".";
		completeUnsulliedName setDelimiter :".";
		var establishedImportable as importable
			classwise getType
				this getFullName
		set importPackage
			establishedImportable getImportPackage
		importPackage addPackage
			packageName
			completeUnsulliedName
		importPackage setIsInner :false;
		set classType = \iType
		if iType does contains "interface"
			this setIsInterface :true;
		
		set externalName = external exact{iName}
		if templateTypeName is not null
			set externalTemplateTypeName = external asTemplate{\'templateTypeName}
		else
			set externalTemplateTypeName = external exact{``""``}
		if iParent is not null
			set parent = classwise extends{iParent}
			set externalParent = external extends { iParent }
			set externalParentEntry = iParent
			var iParentType as importable = iParent
			this addImports
				iParentType getImportPackage
		else
			set parent = {}
			set externalParent      = external exact{``""``}
			set externalParentEntry = external exact{``""``}
		if iInterfaces is not empty
			set interfaces = classwise implements{iInterfaces}
			entry extItrf = {} 
			each itrf as Entry in iInterfaces
				var iIntefaceType as importable = itrf
				this addImports
					iIntefaceType getImportPackage
				extItrf += itrf
			set externalInterfaces = external implements {extItrf}
			
		else
			set interfaces = {}
			set externalInterfaces = external exact{``""``}
		each ev as Entry in iVariables
			var i as innerable = ev
			if i does getIsInner
				var niv as i_variable = ev
				this addVariable
					niv
			else
				var nev as e_variable = ev
				this addVariable
					nev
		each e as Entry in iMethods
			var i as innerable = e
			if i does getIsInner
				var niv as i_method = e
				this addMethod
					niv
			else
				var nev as e_method = e
				this addMethod
					nev
		set context = iContext
		internalVariables setDelimiter :"";
		externalVariables setDelimiter :"";
		internalMethods setDelimiter :"";
		externalMethods setDelimiter :"";
		internalSubClasses setDelimiter :"";
		externalSubClasses setDelimiter :"";
		externalConstructorVariables setDelimiter :",";
		externalConstructorMethods setDelimiter :",";
		externalConstructorSubClass setDelimiter :",";
		
		set getHeader = i_exact:(2 external getCompleteHeader{ asStatic classType externalName externalTemplateTypeName externalParent externalInterfaces});
		
		set asFile = i_exact:external declareClass{name name internalVariables internalMethods internalSubClasses externalSubClasses packageName importPackage->EXTERNAL externalName ``iType`` externalParentEntry getHeader externalConstructorVariables externalConstructorMethods externalConstructorSubClass };
		set asArgument = i_exact:external declareClassAsArgument{packageName importPackage->EXTERNAL externalName ``iType`` externalParentEntry getHeader externalConstructorVariables externalConstructorMethods externalConstructorSubClass};
	addVariable takes i as i_variable
		internalVariables+=(2 internal declareMemberComplete{i})
		var iAssignment as Entry
			i getAssignment
		if iAssignment is null
			var iType as Entry
				i getType
			i setAssignment
				i_new_obj:iType {};
	addVariable takes e as e_variable
		var eName as Entry
			e getName
		var eAssignment as Entry
			e getAssignment
		if eAssignment is null
			var eType as Entry
				e getType
			e setAssignment
				e_new_obj:eType {};
		externalVariables+=(2 internal declareMemberClass{eName eName external declareMember{e_tabs e}})
		externalConstructorVariables+= e
		this addImports
			e getImportPackage
	addMethod takes i as i_method
		internalMethods+=(1 |i|)
	addMethod takes e as e_method
		var eName as Entry
			e getName
		e setIsInterface :isInterface;
		externalMethods += (1 internal declareMemberMethod{eName e})
		externalConstructorMethods+= e
		this addImports
			e getImportPackage
	addSubClass takes i as i_class
		internalSubClasses+=(1 |i|)
		i setIsSubClass :completeName true;
		var theirContext as context
			i getContext
		theirContext setParentContext:context;
		this addImports
			i getImportPackage
	addSubClass takes e as e_class
		var ePlainName as Entry
			e getName
		var eName
			classwise buildString
				e getName
				"Class"
		var eAsFile as Entry
			e getAsFile
		externalSubClasses+=(1 internal declareMemberClass{ePlainName ePlainName eAsFile})
		externalConstructorSubClass+= e
		this addImports
			e getImportPackage
		e setIsSubClass : completeName completeUnsulliedName true;
		var theirContext as context
			e getContext
		theirContext setParentContext:context;
		
		var nameBuilder
			new StringBuilder
		ePlainName get
			nameBuilder
		clazz addDefinedClassName
			'nameBuilder
	setIsSubClass takes superCompleteName as Entry, superUnsulliedName as Entry, newStatus
		set isSubClass = newStatus
		if isSubClass is true
			asStatic set :"static";
		else
			asStatic set :"";
		completeName clear
		completeName +=	superCompleteName
		completeName += classwise classAsVariable{name}
		
		completeUnsulliedName clear
		completeUnsulliedName += superUnsulliedName
		
		getHeader setValue
			(2 external getSubHeader{asStatic classType externalName externalParent externalInterfaces})
	output
			|completeName| if name is not null
		if context is null
			set tabs = 0
		else
			set tabs
				context getTab
		e_tabs set :'tabs;
