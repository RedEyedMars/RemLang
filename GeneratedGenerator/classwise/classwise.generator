uses ClassNames Tokens Rules RegexParser
import "classwise.entries"
meta std
	var rootParser as IParser
		static Rules base
	var rules as List<IParser>
		static Rules parser
	var listnames as List<IParser>
		static Listnames parser
	var lazyNameParser as RegexParser
		static Tokens NAME
	assignListElementNames takes
			context as ParseContext
			root as IToken
		context retainList
			new ClassNames

classwise
	elements from "classwise.elements"
	var nxtPackageName
	var inrPackageName
	var inDir as File
	var nrDir as File
	var innerEntries
		new HashMap<String,Entry>
	var nextEntries
		new HashMap<String,Entry>
	var nextClasses
		new ArrayList<e_class>
	var importables
		new HashMap<String,importable>
	var addClassFileList = {}
	var setupClassList = {}
	var main_class as i_class
	aux setup takes data as ParseContext
		set inrPackageName
			"clgen"
		set nxtPackageName
			"clent"
		var fileName
			data getFileName
		var indexOfDot as Integer
			fileName lastIndexOf
				"."
		if indexOfDot>-1
			set fileName
				fileName substring
					0
					indexOfDot
		set inDir
			new File
				classwise buildString
					"../Generated"
					fileName
					"/src"
				inrPackageName
		set nrDir
			new File
				classwise buildString
					"../Generated"
					fileName
					"/src"
				nxtPackageName
		inDir mkdirs
		nrDir mkdirs
	generate all
		all imports to element
			generate all:;
		all IMPORT_CLASS to element
			generate all:;
		all anonymous_class to element
			entry packageName "." = {}
			var className =  'element->className
			var context = context :null;
			element packageName to atom
				atom name_var to quark
					packageName += generate name_var :true;
			importables put
				className
				importHolder: packageName \className ;
		
		all class_declaration to element
			var newCl as Entry = generate clazz declaration:false null;
			var newIn as innerable = newCl
			var newNa as nameable = newCl
			if newIn does getIsInner				
				innerEntries put
					newNa getFullName
					newCl
			else
				var newClass as e_class = newCl
				var className as Entry
					newClass getName
				main_class addClass
					newClass
				var classImport as import_list
					newClass getImportPackage
				var getPackageName as Entry
					classImport getMyPackages
				addClassFileList +=
					classwise addFile{getPackageName className className}
				setupClassList +=
					classwise setupClass{className}
		var methodContext = context:context:;;
		all method_declaration to element
			var newMt as i_method = generate method declaration:true methodContext;
			main_class addMethod
				newMt
		all variable_declaration to element
			var newVa as i_variable = generate variable declaration :true;
			main_class addVariable
				newVa
		return
			null
	aux generate takes data as ParseContext
		var semicolon = ";"
		var mainMethod = i_method :i_type_var:\"void"; i_name_var:\"main"; {i_variable:i_type_var:\"String[]"; i_name_var:\"args"; null;} {
			i_conditional:"if" i_exact:\"args.length==1"; {i_element:"" i_exact:\"new MainFlow().parse(args[0])"; semicolon context:;;} context:;;
			i_conditional:"else" null {i_element:"" i_exact:\"System.err.println(\"No filename provided!\")"; semicolon context:;;} context:;;} context:context:;;;
		mainMethod setIsStatic
			true
		set main_class = i_class: \inrPackageName "class" \"MainFlow" i_type_var:\"FlowController"; {} {} {
			mainMethod} context:;;
		classwise generateAll
			data getRoot
		var inKeySet as Set<String>
			innerEntries keySet
		each key in inKeySet
			classwise addFile
				inDir
				classwise buildString
					^key
					".java"
				innerEntries->key
		classwise addFile
			inDir
			classwise buildString
				"MainFlow.java"
			main_class
		each nextClass as e_class in nextClasses
			classwise addFile
				nrDir
				classwise buildString
					nextClass getFullName
					".java"
				nextClass
		addClassFileList setDelimiter :"\n\t\t\t\t";
		setupClassList setDelimiter :"\n\t\t";
		main_class addMethod
			i_method:i_type_var:\"Generator[]"; i_name_var:\"getGenerators"; {} {
				i_element:"" i_variable:i_type_var:\"MainFlow"; i_name_var:\"self"; i_exact:\"this";; semicolon context:;;
				i_element:"return " i_exact:classwise generators{addClassFileList setupClassList}; semicolon context:;;} context:context:;;;
	generate name_var takes isInner as Boolean
		name_var to element
			access
				var left as Entry = null
				var right as Entry = null
				element to atom
					name_var
						if left is null
							set left = generate name_var :isInner;
						else
							if right is null
								set right = generate name_var :isInner;
							else
								if isInner is true
									set left = i_name_var:left right;
								else
									set left = e_name_var:left right;
								set right = generate name_var :isInner;
				if isInner is true
					if element->CAMEL is not null
						return
							i_name_var: internal camelize {i_name_var:left right;} ;
					else
						return
							i_name_var:left right;
				else
					if element->CAMEL is not null
						return
							e_name_var: external camelize { e_name_var:left right;} ;
					else
						return
							e_name_var:left right;
			concat
				var left as Entry = null
				var right as Entry = null
				element to atom
					name_var
						if left is null
							set left = generate name_var :isInner;
						else
							if right is null
								set right = generate name_var :isInner;
							else
								if isInner is true
									set left = i_name_var:left "+" right;
								else
									set left = e_name_var:left "+" right;
								set right = generate name_var :isInner;
				if isInner is true
					if element->CAMEL is not null
						return
							i_name_var: internal camelize {i_name_var:left "+" right;} ;
					else
						return
							i_name_var:left "+" right;
				else
					if element->CAMEL is not null
						return
							e_name_var: external camelize { e_name_var:left "+" right; } ;
					else
						return
							e_name_var:left "+" right;
			
			as_method
				var subject as Entry
					body generateStatement
						element->body_statement
						true
				if isInner is true
					return
						i_exact:\"\"$AS METHOD NOT IMPLEMENTED FOR INNER$\"";
				else
					return
						e_inner_call: subject ;
			as_quote
				var subject as Entry
					body generateStatement
						element->body_statement
						true
				if isInner is true
					return
						i_exact:\"\"$AS QUOTE NOT IMPLEMENTED FOR INNER$\"";
				else
					return
						e_quote: i_call: subject \"toString" {};;
			as_string
				var subject as Entry
					body generateStatement
						element->body_statement
						true
				if isInner is true
					return
						i_call: subject \"toString" {};
				else
					return
						e_entry: i_call: subject \"toString" {};;
			exact
				entry value = null
				if isInner is true
					if element->WILD is not null
						if element->CAMEL is not null
							set value = ``^element->WILD``
						else
							set value = ``'element->WILD``
					else
						if element->variable_names is not null
							if element->CAMEL is not null
								return
									i_exact: internal camelize {\'element->variable_names};
							else
								set value = ``'element->variable_names``
						else
							if element->CAMEL is not null
								set value = \^element->NAME
							else
								set value = \'element->NAME
					return
						i_name_var:value;
				else
					if element->WILD is not null
						if element->CAMEL is not null
							set value = external exact{``^element->WILD``}
						else
							set value = external exact{``'element->WILD``}
					else
						if element->variable_names is not null
							if element->CAMEL is not null
								set value = external camelize{ \'element->variable_names}
							else
								set value = external exact{\'element->variable_names}
						else
							if element->CAMEL is not null
								set value = external exact{``^element->NAME``}
							else
								set value = external exact{``'element->NAME``}
					return
						e_name_var:value ;
			variable
				var value as Entry = null
				if isInner is true
					if element->CAMEL is not null
						if element->class_variable_names is not null
							set value = internal camelize {\'element->class_variable_names}
						else
							set value = internal camelize {\'element->variable_names}
					else
						if element->class_variable_names is not null
							set value = \'element->class_variable_names
						else
							set value = \'element->variable_names
					return
						i_name_var:value;
				else
					if element->CAMEL is not null
						if element->class_variable_names is not null
							set value = external camelize{ ``'element->class_variable_names`` }
						else
							set value = external camelize{ ``'element->variable_names`` }
					else
						if element->class_variable_names is not null
							set value = external exact{``'element->class_variable_names``}
						else
							set value = external exact{``'element->variable_names``}
					return
						e_name_var:value ;
		return
			null
	generate type_var takes isInner as Boolean, accessIndex as Integer
		type_var to element
			access_multi
				var ret as Entry = null
				element type_var to atom
					if accessIndex is 3
						if ret is null
							return
								generate type_var :isInner 3;
					else
						if ret is null
							set ret = generate type_var :isInner 0;
						else
							if isInner is true
								set ret = i_type_var:ret "." generate type_var :isInner 1; ;
							else
								set ret = e_type_var:ret "." generate type_var :isInner 1; ;
				element as_method to atom
					var methodName as Entry = null
					if isInner is true
						set methodName = i_exact:``"*"``;
					else
						set methodName = e_exact:``"*"``;
					atom name_var to quark
						set methodName = generate name_var :isInner;
					if isInner is true
						set ret = i_type_var:ret ".*"  methodName ;
					else
						set ret = e_type_var:ret ".*"  methodName ;
				if isInner is true
					if element->CAMEL is not null
						return
							i_type_var: internal camelize {ret} ;
					else
						return
							ret
				else
					if element->CAMEL is not null
						return
							e_type_var: external camelize {ret} ;
					else
						return
							ret
			access_method
				var ret as Entry = null
				element type_var to atom
					if accessIndex is 3
						if ret is null
							return
								generate type_var :isInner 3;
					else
						if ret is null
							set ret = generate type_var :isInner 0;
						else
							if isInner is true
								set ret = i_type_var:ret "." generate type_var :isInner 1; ;
							else
								set ret = e_type_var:ret "." generate type_var :isInner 1; ;
				var methodName as Entry = null
				if isInner is true
					set methodName = i_exact:``"*"``;
				else
					set methodName = e_exact:``"*"``;
				element name_var to atom
					set methodName = generate name_var :isInner;
				if isInner is true
					set ret = i_type_var:ret ".*"  methodName ;
				else
					set ret = e_type_var:ret ".*"  methodName ;
				if isInner is true
					if element->CAMEL is not null
						return
							i_type_var: internal camelize {ret} ;
					else
						return
							ret
				else
					if element->CAMEL is not null
						return
							e_type_var: external camelize {ret} ;
					else
						return
							ret
			concat
				entry left = null
				entry right = null
				element to atom
					type_var
						if accessIndex is 3
							if left is null
								set left = generate type_var :isInner 3;
							else
								set right = generate type_var :isInner 3;
						else
							if accessIndex is 2
								if left is null
									set left = generate type_var :isInner 2;
								else
									set right = generate type_var :isInner 2;
							else
								if left is null
									set left = generate type_var :isInner 1;
								else
									set right = generate type_var :isInner 1;
				
				if isInner is true
					if element->CAMEL is not null
						return
							i_type_var: internal camelize {i_type_var:left "+" right;} ;
					else
						return
							i_type_var:left "+" right;
				else
					if element->CAMEL is not null
						return
							e_type_var: external camelize {e_type_var:left "+" right;} ;
					else
						return
							e_type_var:left "+" right;
			as_method
				var subject as Entry
					body generateStatement
						element->body_statement
						true
				if isInner is true
					return
						i_type_var:i_exact:\"\"$AS METHOD NOT IMPLEMENTED FOR INNER$\"";;
				else
					return
						e_type_var:e_inner_call: subject ;;
			as_quote
				var subject as Entry
					body generateStatement
						element->body_statement
						true
				if isInner is true
					return
						i_type_var:i_exact:\"\"$AS QUOTE NOT IMPLEMENTED FOR INNER$\"";;
				else
					return
						e_type_var:e_quote: i_call: subject \"toString" {};;;
			as_string
				var subject as Entry
					body generateStatement
						element->body_statement
						true
				if isInner is true
					return
						i_type_var:i_call: subject \"toString" {};;
				else
					return
						e_type_var:e_entry: i_call: subject \"toString" {};;;
			exact
				entry templateParameters "," = {} 
				element template_parameters to atom
					atom template_parameter to quark
						templateParameters+=generate all_type:isInner;
				entry value = null
				
				var importType as importable
					classwise getType
						"void"
				if isInner is true
					if element->CAMEL is not null
						if element->NAME is not null
							set value = ``^element->NAME``
						else
							if accessIndex is 2
								set value = \^element->variable_names
							if accessIndex is 0
								set value = classwise classAsVariable {\^element->variable_names}
							if accessIndex is 1
								set value = \^element->variable_names
							if accessIndex is 3
								set value = \^element->variable_names	
					else
						if element->NAME is not null
							set value = ``'element->NAME``
						else
							if accessIndex is 2
								set value = \'element->variable_names
							if accessIndex is 0
								set value = classwise classAsVariable {\'element->variable_names}
							if accessIndex is 1
								set value = \'element->variable_names
							if accessIndex is 3
								set value = \'element->variable_names
					return
						i_type_var :value templateParameters importType;
				else
					if element->CAMEL is not null
						if element->NAME is not null
							set value = external exact{``^element->NAME``}
						else
							set value = external camelize{\'element->variable_names}
					else
						if element->NAME is not null
							set value = external exact{``'element->NAME``}
						else
							set value = external exact{\'element->variable_names}
					return
						e_type_var:value templateParameters importType;
			class
				entry templateParameters "," = {}
				element template_parameters to atom
					atom template_parameter to quark
						templateParameters+=generate all_type:isInner;
				entry value = null
				var importType as importable
				
				if isInner is true
					if element->CAMEL is not null
						if element->class_variable_names is not null
							set value = \^element->class_variable_names
						else
							if accessIndex is 3
								set value = \^element->class_names
							if accessIndex is 2
								set value = \^element->class_names
							if accessIndex is 0
								set value = classwise classAsVariable{\^element->class_names}
							if accessIndex is 1
								set value = ``^element->class_names``
							set importType
								classwise getType
									classwise buildString
										^element->class_names
										"Class"
					else
						if element->class_variable_names is not null
							set value = \'element->class_variable_names
						else
							if accessIndex is 3
								set value = \'element->class_names
							if accessIndex is 2
								set value = \'element->class_names
							if accessIndex is 0
								set value = classwise classAsVariable{\'element->class_names}
							if accessIndex is 1
								set value = ``'element->class_names``
							set importType
								classwise getType
									classwise buildString
										'element->class_names
										"Class"
					if accessIndex is 3 and element->class_names is not null
						var ret = i_type_var:value templateParameters importType;
						ret setIsVariable
							false
						return
							ret
					else
						return
							i_type_var:value templateParameters importType;
				else
					if element->CAMEL is not null
						if element->class_variable_names is not null
							set value = external getName {\^element->class_variable_names}
						else
							set value = external exact {``^element->class_names``}
						set importType
							classwise getType
								classwise buildString
										^element->class_names
										"Class"
					else
						if element->class_variable_names is not null
							set value = external getName {\'element->class_variable_names}
						else
							set value = external exact {``'element->class_names``}
							set importType
								classwise getType
									classwise buildString
										'element->class_names
										"Class"
					return
						e_type_var:value templateParameters importType;
		return
			null
	generate all_type takes isInner as Boolean
		all_type to element
			type_var
				return
					generate classwise type_var: isInner 2;
			CLASS_TYPE
				if isInner is true
					return
						i_type_var:i_exact:\"ExternalClassEntry";;
				else
					return
						e_type_var:e_exact:\"ExternalClassEntry";;
			METHOD_TYPE
				if isInner is true
					return
						i_type_var:i_exact:\"ExternalMethodEntry";;
				else
					return
						e_type_var:e_exact:\"ExternalMethodEntry";;
			VARIABLE_TYPE
				if isInner is true
					return
						i_type_var:i_exact:\"ExternalVariableEntry";;
				else
					return
						e_type_var:e_exact:\"ExternalVariableEntry";;
			BODY_TYPE
				if isInner is true
					return
						i_type_var:i_exact:\"ExternalStatement.Body";;
				else
					return
						e_type_var:e_exact:\"ExternalStatement.Body";;
			STATEMENT_TYPE
				if isInner is true
					return
						i_type_var:i_exact:\"ExternalStatement";;
				else
					return
						e_type_var:e_exact:\"ExternalStatement";;
			PARAMETERS_TYPE
				if isInner is true
					return
						i_type_var:i_exact:\"ExternalStatement.Parameters";;
				else
					return
						e_type_var:e_exact:\"ExternalStatement.Parameters";;
			CONTEXT_TYPE
				if isInner is true
					return
						i_type_var:i_exact:\"ExternalContext";;
				else
					return
						e_type_var:e_exact:\"ExternalContext";;
		return
			null
	aux getType takes className
		if importables->className is null
			importables put
				className
				importHolder :;
		return as importable
			importables->className
external
	elements from "external.elements"
internal
	elements from "internal.elements"
clazz
	var definedClassNames
		new HashSet<String>
	aux addDefinedClassName takes className
		definedClassNames += className
	generate declaration takes mustInner as Boolean, parentContext as context
		var isInner = false
		if mustInner is true
			set isInner = true
		else
			set isInner
				declaration->inner is not null
		entry packageName "." = {}
		entry methodBody "" = {}
		entry variableBody "" = {}
		entry parent = null
		entry interfaces = {}
		
		var subClasses = {}
		
		var context = context:parentContext;
		
		declaration variable_declaration to element
			variableBody+=
				generate variable declaration:isInner;
		declaration method_declaration to element
			methodBody+=
				generate method declaration:isInner context;
		declaration class_declaration to element
			subClasses+=
				generate clazz declaration:isInner context;
		
		declaration parentName to element
			element type_var to atom
				set parent = generate classwise type_var:isInner 2;
		declaration interfaceName to element  
			element type_var to atom
				interfaces += generate classwise type_var:isInner 2;
		declaration packageName to element
			element name_var to atom
				packageName += generate classwise name_var:isInner;
		if isInner is true
			var iret = i_class: packageName 'declaration->objectType \'declaration->className parent interfaces variableBody methodBody context;
			each e as Entry in subClasses
				var eAsInnerable as innerable = e
				if eAsInnerable does getIsInner
					var eAsIClass as i_class = e
					iret addSubClass
						eAsIClass
				else
					var eAsEClass as e_class = e
					iret addSubClass
						eAsEClass
			return
				iret
		else
			packageName setDelimiter
				".get(builder);\n\t\t\t\tbuilder.append(\".\");\n\t\t\t\t"
			var className as Entry
			var actualName
			if declaration->className->NAME is not null
				set className = ``'declaration->className->NAME``
				set actualName = 'declaration->className->NAME
			else
				if declaration->className->class_variable_names is not null
					set actualName
						clazz buildString
							'declaration->className->class_variable_names
							".getName()"
					set className = \actualName
				else
					set className = \'declaration->className->variable_names
					set actualName = 'declaration->className->variable_names
			var eret = e_class: packageName 'declaration->objectType actualName className declaration->templateTypeName parent interfaces variableBody methodBody context; 
			each e as Entry in subClasses
				var eAsInnerable as innerable = e
				if eAsInnerable does getIsInner
					var eAsIClass as i_class = e
					eret addSubClass
						eAsIClass
				else
					var eAsEClass as e_class = e
					eret addSubClass
						eAsEClass
			return
				eret

body
	generate element takes isInner as Boolean, parentContext as context
		var semicolon = ";"
		element to atom
			body_manipulate
				return
					generate manipulate :parentContext;
			body_line
				entry in = null
				atom to quark
					variable_declaration
						set in = generate variable declaration :isInner;
					variable_assignment
						set in = generate variable assignment :isInner;
					body_statement
						set in = generate statement :isInner;
				var inb as innerable = in
				if inb does getIsInner
					return
						i_element:"" in semicolon parentContext;
				else
					return
						e_element:"" in semicolon parentContext;
			body_return
				atom method_argument to quark
					if isInner is true or atom->inner is not null
						return
							i_element:"return " generate argument :true; semicolon parentContext;
					else
						return
							e_element:"return " generate argument :false; semicolon parentContext;
				if isInner is true or atom->inner is not null
					return
						i_element:"return " i_exact:\""; semicolon parentContext;
				else
					return
						e_element:"return " e_exact:\""; semicolon parentContext;
			body_throw
				if atom->inner is not null
					set isInner = true
				var statement as Entry
				atom body_statement to quark
					set statement = generate body statement :isInner;
				if isInner is true or atom->inner is not null
					return
						i_element:"throw " i_exact:classwise throw{statement}; semicolon parentContext;
				else
					return
						e_throw:statement parentContext;
			body_conditional
				if isInner is true or atom->inner is not null
					set isInner = true
				var conditionalContext
					context:parentContext;
				var conditionalName
					new StringBuilder
				var isCase = false
				atom conditional to quark
					quark * to quanta
						if 'quanta does contains "case"
							set isCase = true
						conditionalName append
							'quanta
						conditionalName append
							" "
				var statement as Entry = null
				atom body_statement to quark
					set statement = generate statement :isInner;
				atom variable_declaration to quark
					var operator = 'atom->OPERATOR
					if operator does contains ":"
						if isInner is true
							set statement = i_operator :generate variable declaration :isInner; operator statement;
						else
							set statement = e_operator :generate variable declaration :isInner; operator statement;
					else
						if isInner is true
							set statement = i_operator :\"CANNOT YET DO INTEGER FORS";
						else
							set statement = e_operator :\"CANNOT YET DO INTEGER FORS";
				var coloncolon = ":" 
				atom as_body to quark
					entry conditionalBody "" = {}
					quark body_element to quanta
						entry bodyElem = generate element :isInner conditionalContext;
						if bodyElem is not null
							conditionalBody add
								bodyElem 
					if isCase is true
						if isInner is true
							return
								i_conditional:'conditionalName i_element:"" statement coloncolon parentContext; conditionalBody parentContext;
						else
							return
								e_case: statement conditionalBody parentContext;
					else
						if isInner is true
							return
								i_conditional:'conditionalName statement conditionalBody parentContext;
						else
							return
								e_conditional:'conditionalName statement conditionalBody parentContext;			
				atom as_method to quark
					var subject as Entry
						body generateStatement
							quark->body_statement
							true
					if isCase is true
						return
							e_case:statement e_inner_call:subject; parentContext;
					else
						return
							e_conditional:'conditionalName statement e_inner_call:subject; parentContext;
		return
			null
	generate statement takes isInner as Boolean
		if isInner is false
			set isInner
				statement->inner is not null
		var operand as Entry = null
		var operator = null
		statement to element
			as_string
				var subject as Entry
					body generateStatement
						element->body_statement
						isInner
				var subjectAsInnerable as innerable = subject
				var subjectIsInner
					subjectAsInnerable getIsInner
				if isInner is true or subjectIsInner is true
					return
						i_call: subject \"toString" {};
				else
					return
						e_call: subject \"toString" {};
			body_call
				if operand is null
					if isInner is true
						set operand = i_operator:generate call:true;;
					else
						set operand = e_operator:generate call:false;;
				else
					if isInner is true
						set operand = i_operator:operand operator generate call:true;;
					else
						set operand = e_operator:operand operator generate call:false;;
			OPERATOR
				set operator = 'element
		return
			operand
	generate call takes isInner as Boolean
		if isInner is false
			if call->inner is not null
				set isInner = true
			else
				set isInner = false
		var ret as Entry = null
		call group to element
			entry parameters = {}
			var name_var as Entry = null
			if isInner is true
				
				if element->type_var is not null
					var tVar = i_type_var:;
					element type_var to atom
						if element->NEW is not null
							tVar addSubClass
								generate classwise type_var :isInner 2;
						else
							tVar addSubClass
								generate classwise type_var :true 2;
					set name_var = tVar
				else
					if element->typeName is not null
						var tVar = i_type_var:;
						element typeName to atom
							if element->NEW is not null
								tVar addSubClass
									generate classwise all_type :isInner;
							else
								tVar addSubClass
									generate classwise all_type :true;
						set name_var = tVar
					else
						element name_var to atom
							set name_var = generate classwise name_var :true;
						element NAME to atom
							set name_var = i_exact:\'atom;
				var containsParameters = false
				element parameters to quark
					set containsParameters = true
					quark method_argument to atom
						parameters+=generate argument :true;
				if element->NEW is not null
					set ret = i_new_obj :name_var parameters;
				else
					if ret is null
						if containsParameters is true
							set ret = i_call:name_var parameters;
						else
							set ret = i_call:name_var;
					else
						if containsParameters is true
							set ret = i_call:ret name_var parameters;
						else
							set ret = i_call:ret name_var;
			else
				if element->type_var is not null
					var tVar = e_type_var:;
					element type_var to atom
						tVar addSubClass
							generate classwise type_var :false 2;
					set name_var = tVar
				else
					if element->typeName is not null
						var tVar = e_type_var:;
							element typeName to atom
								tVar addSubClass
									generate classwise all_type :false;
						set name_var = tVar
					else
						element name_var to atom
							set name_var = generate classwise name_var :false;
						element NAME to atom
							set name_var = e_entry:``'atom``;
				var containsParameters = false
				element parameters to quark
					set containsParameters = true
					quark method_argument to atom
						parameters+=generate argument :false;
				if element->NEW is not null
					set ret = e_new_obj :name_var parameters;
				else
					if ret is null
						if containsParameters is true
							set ret = e_call:name_var parameters;
						else
							set ret = e_call:name_var;
					else
						if containsParameters is true
							set ret = e_call:ret name_var parameters;
						else
							set ret = e_call:ret name_var;
		return
			ret
	generate manipulate takes parentContext as context
		if manipulate->type_var is not null
			entry type = null
			entry realType = null
			var access as Entry = {}
			entry arguments = {}
			var importList as import_list
			manipulate type_var to element
				set type = generate classwise type_var:true 2;
				set realType = generate classwise type_var:true 3;
				var typeBuilder
					new StringBuilder
				type get
					typeBuilder
				var getType as importable
					classwise getType
						'typeBuilder
				set importList
					getType getImportPackage
				var typeAsVariablizable as variablizable = type
				typeAsVariablizable setIsVariable
					true
			manipulate name_var to element
				set access = generate classwise name_var:true;
			var arg_type = -1
			manipulate to atom
				class_declaration
					var aClass as e_class = generate clazz declaration :false context:; ;
					arguments +=
						aClass getAsArgument
					aClass setIsSubClass: type realType true;
					importList addImports
						aClass getImportPackage
					set arg_type = 0
				method_declaration
					var aMethod as Entry = generate method declaration :false context :context:;; ;
					arguments += aMethod
					set arg_type = 1
				variable_declaration
					var aVariable as Entry = generate variable declaration :false;
					arguments += aVariable
					set arg_type = 2
				body
					atom body_element to quark
						var bodyelem as Entry = generate element :false context:context:context:;;;;
						if bodyelem is not null 
							arguments += bodyelem 
					set arg_type = 3
			if 'manipulate->methodName is "+="
				if arg_type is 0
					return
						man_obj:type "addSubClass" arguments;
				if arg_type is 1
					return
						man_obj:type "addMethod" arguments;
				if arg_type is 2
					return
						man_obj:type "addVariable" arguments;
				if arg_type is 3
					return
						man_obj:type "appendToBody" arguments;
				return
					man_obj:type "add" arguments;
			else
				return
					man_obj:type 'manipulate->methodName arguments;
		else
			entry subject = null
			var elementName
			if manipulate->variableName is not null
				set elementName = 'manipulate->variableName  
			manipulate name_var to element
				set subject = generate classwise name_var:true;
			entry man_body "" = {}
			manipulate tokenInstance to element
				var tokenName = 'element->tokenName
				entry instance_body "" = {}
				entry bodyContext = context:parentContext;
				element body_element to atom
					var bodyElem as Entry = generate element:true bodyContext;
					if bodyElem is not null
						instance_body += bodyElem
				man_body += man_tok_inst:subject elementName tokenName instance_body bodyContext;
			return
				man_tok: subject elementName man_body parentContext;
	generate argument takes isInner as Boolean
		argument to element
			class_declaration
				return
					generate clazz declaration :false context:;;
			method_declaration
				return
					generate method declaration :false context:context:;;;
			variable_declaration
				return
					generate variable declaration :false;
			body_statement
				return
					generate statement :isInner;
			as_statement
				entry body = {}
				element body_element to atom
					entry bodyElem = generate element :false context:context:context:;;;; 
					if bodyElem is not null
						body += bodyElem
				element body_statement to atom
					return
						generate statement :false ;
				return
					e_inner_call:body;	
			body_entries
				entry elements "" = {}
				element body_element to atom
					var bodyelem as Entry = generate body element :false context:context:context:;;;;
					if bodyelem is not null
						elements += bodyelem
				return
					e_body :elements;
		return
			null
method
	generate declaration takes isInner as Boolean, parentContext as context
		declaration methodDefinition to element
			return
				generate definition :isInner parentContext;
		return
			null
	generate definition takes isInner as Boolean, parentContext as context
		if isInner is false
			set isInner
				definition->inner is not null
		var typeName as canAddSubClass = null
		if isInner is true
			set typeName = i_type_var :;
		else
			set typeName = e_type_var :;
		definition typeName to atom
			typeName addSubClass
				generate classwise all_type :isInner;
		entry methodBody "" = {} 
		entry parameters = {}
		entry bodyContext = context:parentContext;
		definition variable_declaration to element
			parameters += generate variable declaration :isInner;
		definition body_element to element
			entry bodyElem = generate body element:isInner bodyContext;
			if bodyElem is not null
				methodBody += bodyElem
		if definition->methodName->NAME is not null
			if isInner is true
				return
					i_method: typeName i_exact:\'definition->methodName; parameters methodBody parentContext;
			else
				var eMethod = e_method: typeName e_exact:\'definition->methodName; parameters methodBody parentContext;
				if definition->static is not null
					eMethod setIsStatic : true;
				return
					eMethod
		else
			var vName as Entry
				classwise generateNameVar
					definition->methodName->name_var
					isInner
			if isInner is true
				return
					i_method: typeName vName parameters methodBody parentContext;
			else
				var eMethod = e_method: typeName vName parameters methodBody parentContext;
				if definition->static is not null
					eMethod setIsStatic : true;
				return
					eMethod
variable
	generate declaration takes isInner as Boolean
		if isInner is false
			set isInner
				declaration->inner is not null
		var typeName as canAddSubClass = null
		if isInner is true
			set typeName = i_type_var :;
		else
			set typeName = e_type_var :;
		declaration typeName to atom
			typeName addSubClass
				generate classwise all_type :isInner;
		entry assignment = null
		declaration method_argument to atom
			set assignment = generate body argument:isInner;
		var ret as Entry
		if declaration->variableName->NAME is not null
			if isInner is true
				set ret = i_variable: typeName i_exact:\'declaration->variableName; assignment;
			else
				set ret = e_variable: typeName e_exact:``'declaration->variableName``; assignment;
		else
			var vName as Entry
				classwise generateNameVar
					declaration->variableName->name_var
					isInner
			if isInner is true
				set ret = i_variable: typeName vName assignment;
			else
				set ret = e_variable: typeName vName assignment;
		if declaration->WEAK is not null
			var retAsFinalizable as finalizable = ret
			retAsFinalizable setIsFinal :false;
		if declaration->static is not null
			var retAsStatickable as statickable = ret
			retAsStatickable setIsStatic :true;
		if declaration->INLINE_LIST is not null
			var retAsInlineListable as inlinelistable = ret
			retAsInlineListable setIsInlineList :true;
		return
			ret
	generate assignment takes isInner as Boolean
		if isInner is false
			set isInner
				assignment->inner is not null
		entry assignmentVar = null
		assignment method_argument to atom
			set assignmentVar = generate body argument:isInner;
		var vName as Entry
			classwise generateNameVar
				assignment->name_var
				isInner
		if isInner is true
			return
				i_operator: vName "=" assignmentVar;
		else
			return
				e_operator: vName "=" assignmentVar;