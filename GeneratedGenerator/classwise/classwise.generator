uses ClassNames Tokens Rules RegexParser
import "classwise.entries"
meta std
	var rootParser as IParser
		static Rules base
	var rules as List<IParser>
		static Rules parser
	var listnames as List<IParser>
		static Listnames parser
	var lazyNameParser as RegexParser
		static Tokens NAME
	assignListElementNames takes
			context as ParseContext
			root as IToken
		context retainList
			new ClassNames

classwise
	elements from "classwise.elements"
	var nxtPackageName
	var inrPackageName
	var inDir as File
	var nrDir as File
	var innerEntries
		new HashMap<String,Entry>
	var nextEntries
		new HashMap<String,Entry>
	var nextClasses
		new ArrayList<e_class>
	var importables
		new HashMap<String,importable>
	var addClassFileList = {}
	var main_class as i_class
	aux setup takes data as ParseContext
		set inrPackageName
			"clgen"
		set nxtPackageName
			"clent"
		var fileName
			data getFileName
		var indexOfDot as Integer
			fileName lastIndexOf
				"."
		if indexOfDot>-1
			set fileName
				fileName substring
					0
					indexOfDot
		set inDir
			new File
				classwise buildString
					"../Generated"
					fileName
					"/src"
				inrPackageName
		set nrDir
			new File
				classwise buildString
					"../Generated"
					fileName
					"/src"
				nxtPackageName
		inDir mkdirs
		nrDir mkdirs
	generate all
		all imports to element
			generate all:;
		all IMPORT_CLASS to element
			generate all:;
		all anonymous_class to element
			entry packageName "." = {}
			var className =  'element->className
			var context = context :null;
			element packageName to atom
				atom name_var to quark
					packageName += generate name_var :true;
			importables put
				className
				i_class: packageName "class" \className null {}{}{} context;
		
		all class_declaration to element
			var newCl as Entry = generate clazz declaration:false null;
			var newIn as innerable = newCl
			var newNa as nameable = newCl
			if newIn does getIsInner				
				innerEntries put
					newNa getFullName
					newCl
			else
				var newClass as e_class = newCl
				var className as Entry
					newClass getName
				main_class addClass
					newClass
				var classImport as import
					newClass getImportPackage
				var getPackageName as Entry
					classImport getPackageName
				addClassFileList +=
					classwise addFile{getPackageName className className}
		var methodContext = context:context:;;
		all method_declaration to element
			var newMt as i_method = generate method declaration:true methodContext;
			main_class addMethod
				newMt
		all variable_declaration to element
			var newVa as i_variable = generate variable declaration :true;
			main_class addVariable
				newVa
		return
			null
	aux generate takes data as ParseContext
		var semicolon = ";"
		var mainMethod = i_method :i_type_var:\"void"; i_name_var:\"main"; {i_variable:i_type_var:\"String[]"; i_name_var:\"args"; null;} {
			i_conditional:"if" i_exact:\"args.length==1"; {i_element:"" i_exact:\"new MainFlow().parse(args[0])"; semicolon context:;;} context:;;
			i_conditional:"else" null {i_element:"" i_exact:\"System.err.println(\"No filename provided!\")"; semicolon context:;;} context:;;} context:context:;;;
		mainMethod setIsStatic
			true
		set main_class = i_class: \inrPackageName "class" \"MainFlow" i_type_var:\"FlowController"; {} {} {
			mainMethod} context:;;
		classwise generateAll
			data getRoot
		var inKeySet as Set<String>
			innerEntries keySet
		each key in inKeySet
			classwise addFile
				inDir
				classwise buildString
					^key
					".java"
				innerEntries->key
		classwise addFile
			inDir
			classwise buildString
				"MainFlow.java"
			main_class
		classwise addFile
			nrDir
			classwise buildString
				"ExternalImportEntry.java"
			external declareExternalImportClass{}
		classwise addFile
			nrDir
			classwise buildString
				"ExternalBodyEntry.java"
			external declareExternalBodyClass{}
		classwise addFile
			nrDir
			classwise buildString
				"ExternalVariableEntry.java"
			external declareExternalVariableClass{}
		classwise addFile
			nrDir
			classwise buildString
				"ExternalMethodEntry.java"
			external declareExternalMethodClass{}
		classwise addFile
			nrDir
			classwise buildString
				"ExternalClassEntry.java"
			external declareExternalClassClass{}
		each nextClass as e_class in nextClasses
			classwise addFile
				nrDir
				classwise buildString
					nextClass getFullName
					".java"
				nextClass
		addClassFileList setDelimiter :"\n\t\t\t\t";
		main_class addMethod
			i_method:i_type_var:\"Generator[]"; i_name_var:\"getGenerators"; {} {
				i_element:"" i_variable:i_type_var:\"MainFlow"; i_name_var:\"self"; i_exact:\"this";; semicolon context:;;
				i_element:"return " i_exact:classwise generators{addClassFileList}; semicolon context:;;} context:context:;;;
	generate name_var takes isInner as Boolean
		name_var to element
			access
				entry left = null
				entry right = null
				element to atom
					name_var
						if left is null
							set left = generate name_var :isInner;
						else
							set right = generate name_var :isInner;
				if isInner is true
					return
						i_name_var:left right;
				else
					return
						e_name_var:left right;
			concat
				entry left = null
				entry right = null
				element to atom
					name_var
						if left is null
							set left = generate name_var :isInner;
						else
							set right = generate name_var :isInner;
				if isInner is true
					return
						i_name_var:left "+" right;
				else
					return
						e_name_var:left "+" right;
			as_string
				var subject as Entry
					body generateStatement
						element->body_statement
						true
				if isInner is true
					return
						i_call: subject \"toString" {};
				else
					return
						e_entry: i_call: subject \"toString" {};;
			exact
				entry value = null
				if isInner is true
					if element->WILD is not null
						if element->CAMEL is not null
							set value = ``^element->WILD``
						else
							set value = ``'element->WILD``
					else
						if element->variable_names is not null
							if element->CAMEL is not null
								return
									i_exact: internal camelize {\'element->variable_names};
							else
								set value = ``'element->variable_names``
						else
							if element->CAMEL is not null
								set value = \^element->NAME
							else
								set value = \'element->NAME
					return
						i_name_var:value;
				else
					if element->WILD is not null
						if element->CAMEL is not null
							set value = external exact{``^element->WILD``}
						else
							set value = external exact{``'element->WILD``}
					else
						if element->variable_names is not null
							if element->CAMEL is not null
								set value = external camelize{ \'element->variable_names}
							else
								set value = external exact{\'element->variable_names}
						else
							if element->CAMEL is not null
								set value = external exact{``^element->NAME``}
							else
								set value = external exact{``'element->NAME``}
					return
						e_name_var:value ;
			variable
				entry value = null
				if isInner is true
					if element->CAMEL is not null
						set value = \^element->variable_names
					else
						set value = \'element->variable_names
					return
						i_name_var:value;
				else
					if element->CAMEL is not null
						set value = external camelize{ \'element->variable_names}
					else
						set value = external exact{\'element->variable_names}
					return
						e_name_var:value ;
		return
			null
	generate type_var takes isInner as Boolean
		type_var to element
			access
				entry left = null
				entry right = null
				element to atom
					type_var
						if left is null
							set left = generate type_var :isInner;
						else
							set right = generate type_var :isInner;
				if isInner is true
					return
						i_type_var:left "." right;
				else
					return
						e_type_var:left "." right;
			concat
				entry left = null
				entry right = null
				element to atom
					name_var
						if left is null
							set left = generate type_var :isInner;
						else
							set right = generate type_var :isInner;
				if isInner is true
					return
						i_type_var:left "+" right;
				else
					return
						e_type_var:left "+" right;
			as_string
				var subject as Entry
					body generateStatement
						element->body_statement
						true
				if isInner is true
					return
						i_call: subject \"toString" {};
				else
					return
						e_entry: i_call: subject \"toString" {};;
			exact
				entry templateParameters "," = {} 
				element template_parameters to atom
					atom type_var to quark
						templateParameters+=generate type_var:isInner;
				entry value = null
				
				var importType as importable
					classwise getType
						"void"
				if isInner is true
					if element->CAMEL is not null
						if element->NAME is not null
							set value = ``^element->NAME``
						else
							set value = \^element->variable_names
					else
						if element->NAME is not null
							set value = ``'element->NAME``
						else
							set value = \'element->variable_names
					return
						i_type_var :value templateParameters importType;
				else
					if element->CAMEL is not null
						if element->NAME is not null
							set value = external exact{``^element->NAME``}
						else
							set value = external camelize{\'element->variable_names}
					else
						if element->NAME is not null
							set value = external exact{``'element->NAME``}
						else
							set value = external exact{\'element->variable_names}
					return
						e_type_var:value templateParameters importType;
			class
				entry templateParameters "," = {} 
				element template_parameters to atom
					atom type_var to quark
						templateParameters+=generate type_var:isInner;
				entry value = null
				var importType as importable
				
				if isInner is true
					if element->CAMEL is not null
						set value = \^element->class_names
						set importType
							classwise getType
								^element->class_names
					else
						set value = \'element->class_names
						set importType
							classwise getType
								'element->class_names
					return
						i_type_var:value templateParameters importType;
				else
					if element->CAMEL is not null
						set value = external exact {``^element->class_names``}
						set importType
							classwise getType
								^element->class_names
					else
						set value = external exact {``'element->class_names``}
						set importType
							classwise getType
								'element->class_names
					return
						e_type_var:value templateParameters importType;
		return
			null
	aux getType takes className
		if importables->className is null
			importables put
				className
				importHolder:;
		return as importable
			importables->className
external
	elements from "external.elements"
	
	elements from "predefined.elements"
internal
	elements from "internal.elements"
clazz
	generate declaration takes mustInner as Boolean, parentContext as context
		var isInner = false
			
		if mustInner is true
			set isInner = true
		else
			set isInner
				declaration->inner is not null
		entry packageName "." = {}
		entry methodBody "" = {}
		entry variableBody "" = {}
		entry parent = null
		entry interfaces = {}
		
		var context = context:parentContext;
		
		declaration variable_declaration to element
			variableBody+=
				generate variable declaration:isInner;
		declaration method_declaration to element
			methodBody+=
				generate method declaration:isInner context;
		
		declaration parentName to element
			element type_var to atom
				set parent = generate classwise type_var:isInner;
		declaration interfaceName to element  
			element type_var to atom
				interfaces += generate classwise type_var:isInner;
		declaration packageName to element
			element name_var to atom
				packageName += generate classwise name_var:isInner;
		if isInner is true
			return
				i_class: packageName 'declaration->objectType \'declaration->className parent interfaces variableBody methodBody context;
		else
			packageName setDelimiter
				".get(builder);\n\t\t\t\tbuilder.append(\".\");\n\t\t\t\t"
			var className as Entry
			var actualName
			if declaration->className->NAME is not null
				set className = ``'declaration->className->NAME``
				set actualName = 'declaration->className->NAME
			else
				set className = \'declaration->className->variable_names
				set actualName = 'declaration->className->variable_names
			return
				e_class: packageName 'declaration->objectType actualName className parent interfaces variableBody methodBody context;

body
	generate element takes isInner as Boolean, parentContext as context
		var semicolon = ";"
		element to atom
			body_manipulate
				return
					generate manipulate :parentContext;
			body_line
				entry in = null
				atom to quark
					variable_declaration
						set in = generate variable declaration :isInner;
					body_statement
						set in = generate statement :isInner;
				var inb as innerable = in
				if inb does getIsInner
					return
						i_element:"" in semicolon parentContext;
				else
					return
						e_element:"" in semicolon parentContext;
			body_return
				atom method_argument to quark
					if isInner is true or atom->inner is not null
						return
							i_element:"return " generate argument :true; semicolon parentContext;
					else
						return
							e_element:"return " generate argument :false; semicolon parentContext;
			body_conditional
				if isInner is true or atom->inner is not null
					set isInner = true
				var conditionalContext
					context:parentContext;
				entry conditionalBody "" = {}
				var statement as Entry = null
				atom body_statement to quark
					set statement = generate statement :isInner;
				atom variable_declaration to quark
					var operator = 'atom->OPERATOR
					if operator is ":"
						if isInner is true
							set statement = i_operator :generate variable declaration :isInner; operator statement;
						else
							set statement = e_operator :generate variable declaration :isInner; operator statement;
					else
						if isInner is true
							set statement = i_operator :\"CANNOT YET DO INTEGER FORS";
						else
							set statement = e_operator :\"CANNOT YET DO INTEGER FORS";
				atom body_element to quark
					entry bodyElem = generate element :false conditionalContext;
					if bodyElem is not null
						conditionalBody += bodyElem 
				if isInner is true
					return
						i_conditional:'atom->conditional statement conditionalBody parentContext;
				else
					return
						e_conditional:'atom->conditional statement conditionalBody parentContext;
		return
			null
	generate statement takes isInner as Boolean
		if isInner is false
			set isInner
				statement->inner is not null
		var operand as Entry = null
		var operator = null
		statement to element
			as_string
				var subject as Entry
					body generateStatement
						element->body_statement
						isInner
				var subjectAsInnerable as innerable = subject
				var subjectIsInner
					subjectAsInnerable getIsInner
				if isInner is true or subjectIsInner is true
					return
						i_call: subject \"toString" {};
				else
					return
						e_call: subject \"toString" {};
			body_call
				if operand is null
					if isInner is true
						set operand = i_operator:generate call:true;;
					else
						set operand = e_operator:generate call:false;;
				else
					if isInner is true
						set operand = i_operator:operand operator generate call:true;;
					else
						set operand = e_operator:operand operator generate call:false;;
			OPERATOR
				set operator = 'element
		return
			operand
	generate call takes isInner as Boolean
		if isInner is false
			if call->inner is not null
				set isInner = true
			else
				set isInner = false
		var ret as Entry = null
		call group to element
			entry parameters = {}
			var name_var as Entry = null
			if isInner is true
				
				if element->type_var is not null
					var tVar = i_type_var:;
					element type_var to atom
						tVar addSubClass
							generate classwise type_var :true;
					set name_var = tVar
				else
					element name_var to atom
						set name_var = generate classwise name_var :true;
					element NAME to atom
						set name_var = i_exact:\'atom;
				var containsParameters = false
				element parameters to quark
					set containsParameters = true
					quark method_argument to atom
						parameters+=generate argument :true;
				if element->NEW is not null
					set ret = i_new_obj :name_var parameters;
				else
					if ret is null
						if containsParameters is true
							set ret = i_call:name_var parameters;
						else
							set ret = i_call:name_var;
					else
						if containsParameters is true
							set ret = i_call:ret name_var parameters;
						else
							set ret = i_call:ret name_var;
			else
				if element->type_var is not null
					var tVar = e_type_var:;
					element type_var to atom
						tVar addSubClass
							generate classwise type_var :false;
					set name_var = tVar
				else
					element name_var to atom
						set name_var = generate classwise name_var :false;
					element NAME to atom
						set name_var = i_exact:\"new StringEntry(\"'atom\")";
				var containsParameters = false
				element parameters to quark
					set containsParameters = true
					quark method_argument to atom
						parameters+=generate argument :false;
				if element->NEW is not null
					set ret = e_new_obj :name_var parameters;
				else
					if ret is null
						if containsParameters is true
							set ret = e_call:name_var parameters;
						else
							set ret = e_call:name_var;
					else
						if containsParameters is true
							set ret = e_call:ret name_var parameters;
						else
							set ret = e_call:ret name_var;
		return
			ret
	generate manipulate takes parentContext as context
		if manipulate->type_var is not null
			entry type = null
			var access as Entry = {}
			entry arguments = {}
			var importList = []
			manipulate type_var to element
				set type = generate classwise type_var:true;
				var typeBuilder
					new StringBuilder
				type get
					typeBuilder
				var getType as importable
					classwise getType
						'typeBuilder
				set importList
					getType getExternalImportList
				var typeAsVariablizable as variablizable = type
				typeAsVariablizable setIsVariable
					true
			manipulate name_var to element
				set access = generate classwise name_var:true;
			var arg_type = -1
			manipulate to atom
				class_declaration
					var aClass as e_class = generate clazz declaration :false context:; ;
					arguments +=
						aClass getAsArgument
					aClass setIsSubClass: type true;
					importList +=
						aClass getExternalImportList
					set arg_type = 0
				method_declaration
					var aMethod as Entry = generate method declaration :false context :context:;; ;
					arguments += aMethod
					set arg_type = 1
				variable_declaration
					var aVariable as Entry = generate variable declaration :false;
					arguments += aVariable
					set arg_type = 2
				body
					atom body_element to quark
						arguments += generate element :false context:context:context:;;;;
					set arg_type = 3
			if 'manipulate->methodName is "+="
				if arg_type is 0
					return
						man_obj:type "addSubClass" arguments;
				if arg_type is 1
					return
						man_obj:type "addMethod" arguments;
				if arg_type is 2
					return
						man_obj:type "addVariable" arguments;
				return
					man_obj:type "add" arguments;
			else
				return
					man_obj:type 'manipulate->methodName arguments;
		else
			entry subject = null
			manipulate name_var to element
				set subject = generate classwise name_var:true;
			manipulate tokenInstance to element
				var tokenName = 'element->tokenName
				entry man_body "" = {}
				entry bodyContext = context:parentContext;
				element body_element to atom
					var bodyElem as Entry = generate element:false bodyContext;
					if bodyElem is not null
						man_body += bodyElem 
				if element->variableName is not null
					return
						man_tok: subject tokenName 'element->variableName man_body parentContext;
				else
					return
						man_tok: subject tokenName tokenName man_body parentContext;
		return
			null
	generate argument takes isInner as Boolean
		argument to element
			class_declaration
				return
					generate clazz declaration :false context:;;
			method_declaration
				return
					generate method declaration :false context:context:;;;
			variable_declaration
				return
					generate variable declaration :false;
			body_statement
				return
					generate statement :isInner;
		return
			null
method
	generate declaration takes isInner as Boolean, parentContext as context
		if isInner is false
			set isInner
				declaration->inner is not null
		entry typeName = null
		declaration type_var to atom
			set typeName = generate classwise type_var: isInner;
		entry methodBody "" = {} 
		entry parameters = {}
		entry bodyContext = context:parentContext;
		declaration variable_declaration to element
			parameters += generate variable declaration :isInner;
		declaration body_element to element
			entry bodyElem = generate body element:isInner bodyContext;
			if bodyElem is not null
				methodBody += bodyElem
		if declaration->methodName->NAME is not null
			if isInner is true
				return
					i_method: typeName i_exact:\'declaration->methodName; parameters methodBody parentContext;
			else
				return
					e_method: typeName e_exact:\'declaration->methodName; parameters methodBody parentContext;
		else
			var vName as Entry
				classwise generateNameVar
					declaration->methodName->name_var
					isInner
			if isInner is true
				return
					i_method: typeName vName parameters methodBody parentContext;
			else
				return
					e_method: typeName vName parameters methodBody parentContext;
variable
	generate declaration takes isInner as Boolean
		if isInner is false
			set isInner
				declaration->inner is not null
		var typeName as canAddSubClass = null
		if isInner is true
			set typeName = i_type_var :;
		else
			set typeName = e_type_var :;
		declaration type_var to atom
			typeName addSubClass
				generate classwise type_var: isInner;
		entry assignment = null
		declaration method_argument to atom
			set assignment = generate body argument:isInner;
		if declaration->variableName->NAME is not null
			if isInner is true
				return
					i_variable: typeName i_exact:\'declaration->variableName; assignment;
			else
				return
					e_variable: typeName e_exact:\'declaration->variableName; assignment;
		else
			var vName as Entry
				classwise generateNameVar
					declaration->variableName->name_var
					isInner
			if isInner is true
				return
					i_variable: typeName vName assignment;
			else
				return
					e_variable: typeName vName assignment;