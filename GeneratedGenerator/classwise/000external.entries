
entry e_variable uses innerable, nameable
entry e_method uses innerable, nameable
entry e_class uses innerable, nameable
	var packageName
	var asStatic = ""
	entry importList = [(0 \"import com.rem.generation.*")]
	entry classType = null
	entry parent = null
	entry interfaces = null
	entry internalVariables = {}
	entry externalVariables = {}
	entry internalMethods = {}
	entry externalMethods = {}
	entry internalSubClasses = {}
	entry externalSubClasses = {}
	entry getCompleteBody = {}
	entry getSubBody = {}
	entry context = null
	var isSubClass = false
	var tabs = 0
	entry e_tabs = \"0"
	var hasOutput = false
	constructor takes iPackageName, iType, iName, iParent, iInterfaces as ListEntry, iVariables as ListEntry, iMethods as ListEntry, iContext
		set isInner = false
		set packageName = iPackageName
		set importPackage = \iPackageName
		set classType = \iType
		set name = iName
		if iParent is not null
			set parent = classwise extends{\iParent}
		else
			set parent = {}
		if iInterfaces is not empty
			set interfaces = classwise implements{\iInterfaces}
		else
			set interfaces = {}
		
		
		getCompleteBody +=
			i_exact: getCompleteHeader{packageName importList asStatic \name parent interfaces};
		getSubBody +=
			i_exact: getSubHeader{e_tabs asStatic \name parent interfaces};
		
		each e as Entry in iVariables
			var i as innerable = e
			if i does getIsInner
				this addVariable
					e as i_variable
			else
				this addVariable
					e as e_variable
		each e as Entry in iMethods
			var i as innerable = e
			if i does getIsInner
				this addMethod
					e as i_variable
			else
				this addMethod
					e as e_variable
		set context = iContext
		importlist setDelimiter :"";
		internalVariables setDelimiter :"";
		externalVariables setDelimiter :"";
		internalMethods setDelimiter :"";
		externalMethods setDelimiter :"";
		getCompleteBody setDelimiter :"";
		getSubBody setDelimiter :"";
		
		addVariable:i_variable :"ExtImport" "packageName"; ;
		addVariable:i_variable :"SetEntry" "importList"; ;
		addVariable:i_variable :"String" "name"; ;
		addVariable:i_variable :"Boolean" "isSubClass" i_exact:"false";; ;
		addVariable:i_variable :"StringEntry" "classAccess" i_new_obj:"StringEntry" {i_exact:\"\"\"";};; ;
		addVariable:i_variable :"ExtClass" "parentClass"; ;
		addVariable:i_variable :"ListEntry" "interfaces"; ;
		addVariable:i_variable :"ListEntry" "variables"; ;
		addVariable:i_variable :"ListEntry" "methods"; ;
		addVariable:i_variable :"ListEntry" "subClasses"; ;
		addVariable:i_variable :"HashMap<String,ExtVariable>" "variableMap"; ;
		addVariable:i_variable :"HashMap<String,ExtMethod>" "methodMap"; ;
		addVariable:i_variable :"HashMap<String,ExtClass>" "subClassMap"; ;
		addMethod  :i_method   :"void" "get" {i_variable:"StringBuilder" "builder;} {
			i_conditional:"if" i_exact:\"isSubClass"; {getSubBody} parentContext;
			i_conditional:"else" null {getCompleteBody} parentContext;} parentContext ; ;
		
		addMethod  :i_method   :"void" "addVariable" {i_variable:"ExtVariable" "newVariable";} {
			i_call:i_exact:\"importList"; \"add" {i_call:i_call:i_exact:\"newVariable"; \"getType" {}; \"getImportPackage" {};};
			i_call:i_exact:\"variables" \"add" {i_exact:\"newVariable";};
			} ; ;
		addMethod  :i_method   :"void" "addMethod" {i_variable:"ExtMethod" "newMethod";} {
			i_call:i_exact:\"importList"; \"add" {i_call:i_exact:\"newMethod"; \"getImportList" {};};
			i_call:i_exact:\"methods" \"add" {i_exact:\"newMethod";};
			} ; ;
		addMethod  :i_method   :"void" "addSubClass" {i_variable:"ExtClass" "newSubClass";} {
			i_call:i_exact:\"importList"; \"add" {i_call:i_exact:\"newSubClass"; \"getImportPackage" {};};
			i_call:i_exact:\"subClasses" \"add" {i_exact:\"newSubClass";};
			i_call:i_exact:\"newSubClass" \"setSuperClass" {i_exact:\"this";};
			} ; ;
		addMethod  :i_method   :"void" "setSuperClass" {i_variable:"ExtClass" "newSuperClass";} {
			i_call:i_exact:\"importList"; \"add" {i_call:i_exact:\"newSubClass"; \"getImportPackage" {};};
			i_call:i_exact:\"subClasses" \"add" {i_exact:\"newSubClass";};
			i_call:i_exact:\"newSubClass" \"setSuperClass" {i_exact:\"this";};
			} ; ;
		
	addVariable takes i as i_variable
		internalVariables+=i
	addVariable takes e as e_variable
		externalVariables+=e
		var eName
			classwise buildString
				e getName
				"Variable"
		getCompleteBody +=
			i_call:\eName \"get" {i_exact:\"builder";};
		getSubBody +=
			i_call:\eName \"get" {i_exact:\"builder";};
	addMethod takes i as i_method
		internalMethods+=i
	addMethod takes e as e_method
		externalMethods += e
		var eName
			classwise buildString
				e getName
				"Method"
		getCompleteBody +=
			i_call:\eName \"get" {i_exact:\"builder";};
		getSubBody +=
			i_call:\eName \"get" {i_exact:\"builder";};
	addSubClass takes i as i_class
		internalSubClasses+=i
		i setIsSubClass :true;
		var theirContext
			i getContext
		theirContext setParentContext:context;
	addSubClass takes e as e_class
		externalSubClasses+=e
		e setIsSubClass :true;
		var theirContext
			e getContext
		theirContext setParentContext:context;
		var eName
			classwise buildString
				e getName
				"Class"
		getCompleteBody +=
			i_call:\eName \"get" {i_exact:\"builder";};
		getSubBody +=
			i_call:\eName \"get" {i_exact:\"builder";};
	setIsSubClass takes newStatus
		set isSubClass = newStatus
		if isSubClass is true
			asStatic set :"static";
		else
			asStatic set :"";
	output
			classwise declareClass{\packageName importList \asStatic classType \name parent interfaces externalVariables externalMethods externalSubClasses internalVariables internalMethods internalSubClasses } if isSubClass is false
			(tabs classwise declareSubClass{\asStatic classType \name parent interfaces externalVariables externalMethods externalSubClasses internalVariables internalMethods internalSubClasses } if isSubClass is true
			(tabs \"}") if isSubClass is true
		if context is null
			set tabs = 0
		else
			set tabs
				context getTab
		e_tabs set :'tabs;
