uses StringEntry

import "external.entries"
import "internal.entries"
property innerable
	var isInner = false
	setIsInner takes newInner as Boolean
		set isInner = newInner
property fileable
	asFile as Entry
		return
			null
property nameable
	var name as Entry = \""
	var completeName as ListEntry = {}
	getFullName
		var builder
			new StringBuilder
		completeName get
			builder
		return
			'builder

property importable
	var importPackage as import_list = import_list:;
	setPackage takes newPackage, newName
		importPackage addPackage :newPackage newName;
	addImports takes newImport as import_list
		importPackage addImports
			newImport
property canAddSubClass
	addSubClass takes newSubClass as Entry
		var x = "x"
property contextualizable
	var context as context = null
	var tabs = 0
	var e_tabs as StringEntry = \"0"
	setContext takes newContext
		set context = newContext
property variablizable
	var isVariable = true
	setIsVariable takes newIsVariable as Boolean
		set isVariable = newIsVariable
property finalizable
	var isFinal = false
	setIsFinal takes newIsFinal as Boolean
		set isFinal = newIsFinal
property statickable
	var isStatic = false
	setIsStatic takes newIsStatic as Boolean
		set isStatic = newIsStatic
property inlinelistable
	var isInlineList = false
	setIsInlineList takes newIsInlineList as Boolean
		set isInlineList = newIsInlineList
property staticable
	var isStatic = false
	var asStatic = \""
	setIsStatic takes newIsStatic as Boolean
		set isStatic = newIsStatic
		if isStatic is true
			asStatic set :"static ";
		else
			asStatic set :"";
property interfaceable
	var isInterface = false
	setIsInterface takes newIsInterface as Boolean
		set newIsInterface = newIsInterface
entry importHolder uses importable
	constructor
		importPackage setIsAnon :false;
	constructor takes iPackageName as Entry, iName as Entry
		importPackage addPackage
			i_single_import: {iPackageName} {iName};
		importPackage addPackage
			e_single_import: {external bodyExact{iPackageName}} {iName};
		importPackage setIsAnon :true;

entry i_single_import
	var myName as ListEntry = null
	var myPackage as ListEntry = null
	constructor takes iPackage as ListEntry, iName as ListEntry
		set myPackage = iPackage
		set myName = iName
	output
			(0 classwise asImport{myPackage myName}) if myPackage is not null and myPackage is not empty
			{} otherwise
entry e_single_import
	var myName as ListEntry = null
	var myPackage as ListEntry = null
	constructor takes iPackage as ListEntry, iName as ListEntry
		set myPackage = iPackage
		set myName = iName
	output
			(0 classwise asExternalImport{myPackage myName}) if myPackage is not null and myPackage is not empty
			{} otherwise
entry import_list uses innerable
	constant EXTERNAL
		0
	constant INTERNAL
		1
	entry myPackages = {}
	entry myNames = {}
	entry myInternal = []
	entry myExternal = []
	var mode = 0
	var isAnonymous = false
	setIsAnon takes newAnon as Boolean
		set isAnonymous = newAnon
	constructor
		var x = "x"
	constructor takes myPackage, myName
		myPackages += \myPackage
		myNames    += \myName 
	clear
		myInternal clear
		myExternal clear
	addImports takes newImports as import_list
		var newPackages as ListEntry
			newImports getMyPackages
		var newNames as ListEntry
			newImports getMyNames
		if newImports does not getIsAnonymous
			if newImports does getIsInner
				myInternal +=
					i_single_import:newPackages newNames;
			if newImports does not getIsInner
				myExternal +=
					e_single_import:newPackages newNames;
		else
			myExternal +=
				e_single_import:newPackages newNames;
		myInternal +=
			newImports getMyInternal
		myExternal +=
			newImports getMyExternal
	addPackage takes newPackage as i_single_import
		myInternal += newPackage
	addPackage takes newPackage as e_single_import
		myExternal += newPackage
	addPackage takes packageName, nameName
		myPackages clear
		myNames clear
		myPackages += \packageName
		myNames    += \nameName
	addPackage takes packageName as Entry, nameName as Entry
		myPackages clear
		myNames clear
		myPackages += packageName
		myNames    += nameName
	setMode takes newMode as Integer
		set mode = newMode
	get as Entry takes option
		var newSelf = import_list :;
		newSelf addImports
			this getSelf
		if option is "EXTERNAL"
			newSelf setMode :EXTERNAL;
		else
			newSelf setMode :INTERNAL;
		return
			newSelf
	
	output
			myInternal if mode is INTERNAL
			myExternal if mode is EXTERNAL
entry context
	var parentContext as context
	constructor takes iParent as context
		set parentContext = iParent
	constructor
		set parentContext = null
	getTab as Integer
		if parentContext is not null
			var tab
				parentContext getTab
			return
				tab+1
		else
			return
				0
	setParentContext takes newParent
		set parentContext = newParent
