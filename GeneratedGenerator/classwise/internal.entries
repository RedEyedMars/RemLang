

entry man_obj uses innerable importable contextualizable
	entry className = null
	entry methodName = null
	var parameters as Entry = null
	constructor takes iClassName as Entry, iMethodName, iParameters as ListEntry
		
		set isInner = true
		set className = iClassName
		set methodName = \iMethodName
		iParameters setDelimiter :",";
		set parameters = iParameters
		if iMethodName is "appendToBody"
			set parameters = internal newBody {parameters}
	output
			(tabs internal manipulateObject{className methodName parameters}) if className is not null
entry man_tok_inst uses innerable importable contextualizable
	constant SOLO
		0
	constant MULTI
		1
	var mode = MULTI
	entry subject = null
	entry body = null
	var tokenName
	var elementName
	var tabs = 0
	constructor takes iSubject as Entry, iElementName, iTokenName, iBody as ListEntry, iContext as context
		set isInner = true
		set subject = iSubject
		set tokenName = iTokenName
		set elementName = iElementName
		set context = iContext
		var bodyContext = context:iContext;
		var semicolon = ";"
		set body = {}
		each e as Entry in iBody
			var i as importable = e
			var c as contextualizable = e
			c setContext
				bodyContext
			this addImports
				i getImportPackage
			body +=	e
		body setDelimiter :"";
	setMode takes newMode as Integer
		set mode = newMode
	output
			body if mode is SOLO
			(tabs internal manipulateOneMultiToken{\elementName \tokenName \elementName subject \elementName body}) if mode is MULTI
			+
			(tabs \"}") if mode is MULTI 
		if context is null
			set tabs = 0
		else
			set tabs
				context getTab
entry man_tok uses innerable importable contextualizable
	entry subject = null
	entry body = null
	var tokenName
	var elementName
	var tabs = 0
	constructor takes iSubject as Entry, iElementName, iBody as ListEntry, iContext as context
		set isInner = true
		set subject = iSubject
		var subjectAsImportable as importable = iSubject
		this addImports
			subjectAsImportable getImportPackage
		var iBodySize as Integer
			iBody size
		if iBodySize is 1
			var firstInBody as man_tok_inst
				iBody get :0;
			set tokenName
				firstInBody getTokenName
			firstInBody setMode
				static man_tok_inst SOLO
		set elementName = iElementName
		set context = iContext
		var bodyContext = context:iContext;
		var semicolon = ";"
		set body = {}
		each e as Entry in iBody
			var i as importable = e
			var c as contextualizable = e
			c setContext
				bodyContext
			this addImports
				i getImportPackage
			body +=	e
		body setDelimiter :"";
	output
			(tabs internal manipulateSoloToken{\elementName subject \tokenName body}) if tokenName is not null
			(tabs internal manipulateMultiToken{\elementName subject body}) if tokenName is null
			+
			(tabs \"}") if context is not null 
		if context is null
			set tabs = 0
		else
			set tabs
				context getTab
entry i_exact uses innerable importable
	entry value = null
	constructor takes iValue as Entry
		
		set value = iValue
		set isInner = true
	setValue takes newValue
		set value = newValue
	output
			value if value is not null
entry i_name_var uses innerable importable
	entry first = null
	entry second = null
	var isConcat = false
	constructor takes iValue as Entry
		
		set first = iValue
		set isInner = true
	constructor takes iFirst as Entry, iSecond as Entry
		
		set first = iFirst
		set second = iSecond
		set isInner = true
	constructor takes iFirst as Entry, concat, iSecond as Entry
		
		set first = iFirst
		set second = iSecond
		set isConcat = true
		set isInner = true
	output
			first if second is null
			classwise concat{first second} if second is not null and isConcat is true
			classwise access{first second} if second is not null and isConcat is false
entry i_type_var uses innerable importable canAddSubClass variablizable
	constant DEFAULT
		0
	constant CONCAT
		1
	constant ACCESS_CLASS
		2
	constant ACCESS_METHOD
		3
	constant ACCESS_DEFAULT
		4
	entry sansTemp = {}
	entry first = null
	entry second = null
	var mode = DEFAULT
	entry templateParameters = {}
	constructor
		set isInner = true
		
		set first = {}
		first setDelimiter :".";
		sansTemp setDelimiter :".";
	constructor takes iValue as Entry
		set isInner = true
		
		set first = {iValue}
		set sansTemp = {iValue}
		first setDelimiter :".";
		sansTemp setDelimiter :".";
	constructor takes iValue as Entry, iTemplateParameters as ListEntry, importType as importable
		set isInner = true
		set first = {iValue}
		set sansTemp = {iValue}
		if importType is not null
			this addImports
				importType getImportPackage
		set templateParameters = iTemplateParameters
		
		first setDelimiter :".";
		sansTemp setDelimiter :".";
		
	constructor takes iFirst as Entry, operator, iSecond as Entry
		set isInner = true
		var firstAsImportable as importable = iFirst
		var secondAsImportable as importable = iSecond
		this addImports
			firstAsImportable getImportPackage
		this addImports
			secondAsImportable getImportPackage
		set first = {iFirst}
		set sansTemp = {iFirst}
		set second = iSecond
		if operator is "+"
			set mode = CONCAT
		else
			if operator is ".*"
				set mode = ACCESS_METHOD
			else
				if operator is "."
					set mode = ACCESS_CLASS
				if operator is ".."
					set mode = ACCESS_DEFAULT
		first setDelimiter :".";
		sansTemp setDelimiter :".";
	addSubClass takes newSubType as Entry
		var newTypeVar as i_type_var = newSubType
		sansTemp +=
			newTypeVar getSansTemp
		var builder
			new StringBuilder
		sansTemp get
			builder
		var importType as importable
			classwise getType
				'builder
		this addImports
			importType getImportPackage
		first += newSubType
	output
			internal bodyName{first} if second is null and templateParameters is empty and isVariable is false and mode is DEFAULT
			internal bodyName{classwise accessDefault{first second}} if second is null and templateParameters is empty and isVariable is false and mode is ACCESS_DEFAULT
			internal bodyName{classwise classAsVariable {first} } if second is null and templateParameters is empty and isVariable is true and mode is DEFAULT
			internal bodyName{classwise concat{first second}} if second is not null and mode is CONCAT and templateParameters is empty 
			internal bodyName{classwise accessClass {first second}} if second is not null and mode is ACCESS_CLASS and templateParameters is empty
			internal bodyName{classwise accessMethod{first second}} if second is not null and mode is ACCESS_METHOD and templateParameters is empty
			internal bodyNameWithParameters{first templateParameters} if second is null and templateParameters is not empty and mode is DEFAULT
			internal bodyNameWithParameters{classwise concat{first second} templateParameters} if second is not null and templateParameters is not empty and mode is CONCAT
			internal bodyNameWithParameters{classwise accessClass{first second} templateParameters} if second is not null and templateParameters is not empty and mode is ACCESS_CLASS
			internal bodyNameWithParameters{classwise accessMethod{first second} templateParameters} if second is not null and templateParameters is not empty and mode is ACCESS_CLASS
		if isVariable is true
			set isVariable = false
			var checkBuilder
				new StringBuilder
			this get
				checkBuilder
			var definedClassNames as Set<String>
				clazz getDefinedClassNames
			if definedClassNames does contains 'checkBuilder
				set isVariable = true
entry i_operator uses innerable importable
	entry left = null
	entry right = null
	entry operator = null
	constructor takes iLeft as Entry
		set isInner = true
		set left = iLeft
		var leftAsImportable as importable = iLeft
		this addImports
			leftAsImportable getImportPackage
	constructor takes iLeft as Entry, iOperator, iRight as Entry
		set isInner = true
		set left = iLeft
		set right = iRight
		set operator = \iOperator
		var leftAsImportable as importable = iLeft
		var rightAsImportable as importable = iRight
		this addImports
			leftAsImportable getImportPackage
		this addImports
			rightAsImportable getImportPackage
	output
			internal bodyEntry{left} if right is null
			internal bodyOperator{left operator right} if right is not null

entry i_for_int_header uses innerable importable
	entry left = null
	entry variableName = null
	entry right = null
	entry operator = null
	constructor takes iLeft as Entry, iOperator, iRight as Entry
		set left as Entry = iLeft
		set right as Entry = iRight
		var leftAsVariable as i_variable = iLeft
		leftAsVariable setIsFinal :false;
		leftAsVariable setAssignment
			i_exact:\"0";
		set variableName
			leftAsVariable getName
		set operator = \iOperator
		var leftAsImport as importable = iLeft
		var rightAsImport as importable = iRight
		this addImports
			leftAsImport getImportPackage
		this addImports
			rightAsImport getImportPackage
	output
			internal bodyForIntHeader{left variableName operator right variableName} if right is not null
entry i_call uses innerable importable
	entry subject = null
	entry methodName = null
	entry parameters = null
	constructor takes iMethodName as Entry, iParameters as ListEntry
		set isInner = true
		set methodName = iMethodName
		set parameters = iParameters
		each e as Entry in iParameters
			var i as importable = e
			this addImports
				i getImportPackage
		parameters setDelimiter :",";
	constructor takes iSubject as Entry, iMethodName as Entry, iParameters as ListEntry
		set subject = iSubject
		var subjectAsImportable as importable = iSubject
		set methodName = iMethodName
		set parameters = iParameters
		this addImports
			subjectAsImportable getImportPackage
		each e as Entry in iParameters
			var i as importable = e
			this addImports
				i getImportPackage
		parameters setDelimiter :",";
	constructor takes iMethodName as Entry
		set methodName = iMethodName
		var subjectAsImporable as importable = iMethodName
		this addImports
			subjectAsImporable getImportPackage
	constructor takes iSubject as Entry, iMethodName as Entry
		set subject = iSubject
		var subjectAsImporable as importable = iSubject
		set methodName = iMethodName
		this addImports
			subjectAsImporable getImportPackage
	output
			internal bodyCallWithoutSubject{methodName parameters} if subject is null and parameters is not null
			internal bodyCallWithSubject{subject methodName parameters} if subject is not null and parameters is not null
			internal bodyAccessWithoutSubject{methodName} if subject is null and parameters is null
			internal bodyAccessWithSubject{subject methodName} if subject is not null and parameters is null
entry i_new_obj uses innerable importable
	entry className = null
	entry parameters = null
	constructor takes iClassName as Entry, iParameters as ListEntry
		set isInner = true
		set className = iClassName
		set parameters = iParameters
		var classNameAsImportable as importable = className
		this addImports
			classNameAsImportable getImportPackage
		each e as Entry in iParameters
			var i as importable = e
			this addImports
				i getImportPackage
		parameters setDelimiter :",";
	output
			internal bodyNewObj{className parameters} if className is not null
entry i_body uses innerable importable contextualizable
	entry body = null
	constructor takes iBody as ListEntry, iContext as context
		set isInner = true
		set body = {}
		set context = iContext
		var semicolon = ";"
		each e as Entry in iBody
			var i as importable = e
			var c as contextualizable = e
			c setContext
				context
			this addImports
				i getImportPackage
			body +=	e
		
		body setDelimiter :"";
	output
			(tabs body) if context is not null
		if context is null
			set tabs = 0
		else
			set tabs
				context getTab
		e_tabs set :'tabs;
entry i_conditional uses innerable importable contextualizable
	entry name = null
	entry header = null
	entry body = null
	constructor takes iName, iHeader as Entry, iBody as ListEntry, iContext as context
		set isInner = true
		set name = \iName
		set header = iHeader
		
		set body = {}
		set context = iContext
		if header is not null
			var headerAsImportable as importable = iHeader
			this addImports
				headerAsImportable getImportPackage
		var bodyContext = context:iContext;
		var semicolon = ";"
		each e as Entry in iBody
			var i as importable = e
			var c as contextualizable = e
			c setContext
				bodyContext
			this addImports
				i getImportPackage
			body +=	e
		
		body setDelimiter :"";
	output
			(tabs internal bodyConditional{name header body }) if header is not null
			(tabs internal bodyConditionalWithoutHeader{name body}) if header is null 
			+
			(tabs \"}") if context is not null 
		if context is null
			set tabs = 0
		else
			set tabs
				context getTab
		e_tabs set :'tabs;
entry i_element uses innerable importable contextualizable
	entry prefix = null
	entry suffix = null
	entry value = null
	constructor takes iPrefix, iValue as Entry, iSuffix, iContext as context
		set isInner = true
		set prefix = \iPrefix
		set suffix = \iSuffix
		set value = iValue
		set context = iContext
		var valueAsImportable as importable = iValue
		this addImports
			valueAsImportable getImportPackage
	output
			(tabs internal bodyElement{prefix value suffix}) if context is not null 
		if context is null
			set tabs = 0
		else
			set tabs
				context getTab
		e_tabs set :'tabs;
entry i_variable uses innerable importable nameable finalizable statickable inlinelistable
	entry type = null
	entry assignment  = null
	constructor takes iType as Entry, iName as Entry, iAssignment as Entry
		set isInner = true
		set name = iName
		set type  = iType
		set isFinal = true
		this setAssignment
			iAssignment
	setAssignment takes newAssignment as Entry
		importPackage clear
		var typeAsImportable as importable  = type
		set assignment = newAssignment
		this addImports
			typeAsImportable getImportPackage
		if assignment is not null
			var assignmentAsImportable as importable = assignment
			this addImports
				assignmentAsImportable getImportPackage
	output
			internal declareVariableWithAssignmentNonFinal    { type name assignment} if assignment is not null and isFinal is false and isStatic is false
			internal declareVariableWithAssignmentFinal       { type name assignment} if assignment is not null and isFinal is true and isStatic is false
			internal declareVariableWithoutAssignmentNonFinal { type name} if assignment is null and isFinal is false and isStatic is false
			internal declareVariableWithoutAssignmentFinal    { type name} if assignment is null  and isFinal is true and isStatic is false
			internal declareStaticVariableWithAssignmentNonFinal    { type name assignment} if assignment is not null and isFinal is false and isStatic is true
			internal declareStaticVariableWithAssignmentFinal       { type name assignment} if assignment is not null and isFinal is true and isStatic is true
			internal declareStaticVariableWithoutAssignmentNonFinal { type name} if assignment is null and isFinal is false and isStatic is true
			internal declareStaticVariableWithoutAssignmentFinal    { type name} if assignment is null  and isFinal is true and isStatic is true
entry i_method uses innerable importable contextualizable nameable staticable
	entry type = null
	entry parameters  = null
	entry methodBody = null
	constructor takes iType as Entry, iName as Entry, iParameters as ListEntry, iMethodBody as ListEntry, iContext as context
		
		set isInner = true
		set name = iName
		set type = iType
		var typeAsImportable as importable = iType
		set parameters = iParameters
		set methodBody = {}
		set context = iContext
		this addImports
			typeAsImportable getImportPackage
		each e as Entry in iParameters
			var i as importable = e
			this addImports
				i getImportPackage
			var f as finalizable = e
			f setIsFinal
				true
		var methodBodyContext = context:iContext;
		var semicolon = ";"
		each e as Entry in iMethodBody
			var i as importable = e
			var c as contextualizable = e
			c setContext
				methodBodyContext
			this addImports
				i getImportPackage
			methodBody += e
		parameters setDelimiter :",";
		methodBody setDelimiter :"";
	output
			(tabs internal declareMethod{asStatic type name parameters methodBody }) if context is not null
			+
			(tabs \"}") if context is not null 
		if context is null
			set tabs = 0
		else
			set tabs
				context getTab
		e_tabs set :'tabs;

entry i_class uses innerable nameable importable contextualizable fileable staticable
	entry packageName = null
	entry classType = null
	var parent as Entry = null
	var interfaces as Entry = null
	entry internalVariables = {}
	entry externalVariables = {}
	entry internalMethods = {}
	entry externalMethods = {}
	entry internalSubClasses = {}
	entry externalSubClasses = {}
	var isSubClass = false
	var hasOutput = false
	constructor takes iPackageName as Entry, iType, iName as Entry, iParent as Entry, iInterfaces as ListEntry, iVariables as ListEntry, iMethods as ListEntry, iContext as context
		set isInner = false
		set packageName = iPackageName
		set name = iName
		completeName += name
		completeName setDelimiter :".";
		var establishedImportable as importable
			classwise getType
				this getFullName
		set importPackage
			establishedImportable getImportPackage
		importPackage addPackage
			i_single_import :{\"com.rem.parser.generation"} {\"*"};
		importPackage addPackage
			i_single_import :{\"com.rem.parser.generation.classwise"} {\"*"};
		importPackage addPackage
			i_single_import :{\"clent"} {\"*"};
		importPackage addPackage
			i_single_import :{\"java.util"} {\"*"};
		importPackage addPackage
			i_single_import :{\"java.io"} {\"*"};
		importPackage addPackage
			i_single_import :{\"java.nio"} {\"*"};
		importPackage addPackage
			packageName
			iName
		importPackage setIsInner :true;
		set classType = \iType
		if iParent is not null
			set parent = classwise extends{iParent}
			var iParentType as importable = iParent
			this addImports
				iParentType getImportPackage
		else
			set parent = {}
		if iInterfaces is not empty
			set interfaces = classwise implements{iInterfaces}
			each itrf as Entry in iInterfaces
				var iIntefaceType as importable = itrf
				this addImports
					iIntefaceType getImportPackage
		else
			set interfaces = {}
		
		each e as Entry in iVariables
			var i as innerable = e
			if i does getIsInner
				var niv as i_variable = e
				this addVariable
					niv
			else
				var nev as e_variable = e
				this addVariable
					nev
		each e as Entry in iMethods
			var i as innerable = e
			if i does getIsInner
				var niv as i_method = e
				this addMethod
					niv
			else
				var nev as e_method = e
				this addMethod
					nev
		set context = iContext
		internalVariables setDelimiter :"";
		externalVariables setDelimiter :"";
		internalMethods setDelimiter :"";
		externalMethods setDelimiter :"";
		internalSubClasses setDelimiter :"";
		externalSubClasses setDelimiter :"";
	getFullName
		var builder
			new StringBuilder
		completeName get
			builder
		return
			'builder
	addVariable takes i as i_variable
		var semicolon = ";"
		var variableContext = context:context;
		internalVariables+=i_element:"protected " i semicolon variableContext;
		this addImports
			i getImportPackage
		var iAssignment as Entry
			i getAssignment
		var iType as Entry
			i getType
		var iName as Entry
			i getName
		var cBuilder
			new StringBuilder
		iName get
			cBuilder
		if iAssignment is null
			i setAssignment
				i_new_obj:iType {};
		this addMethod
			i_method:iType i_exact:internal getMethodName{\^cBuilder}; {} {i_element:"return " iName semicolon context:;;} context:context:;;;
	addVariable takes e as e_variable
		var eName as Entry
			e getName
		var eAssignment as Entry
			e getAssignment
		if eAssignment is null
			var eType as Entry
				e getType
			e setAssignment
				e_new_obj:eType {};
		externalVariables+=(2 internal declareMemberVariable{eName external declareMember{e_tabs e}})
		this addImports
			e getImportPackage
	addMethod takes i as i_method
		internalMethods+= i
		this addImports
			i getImportPackage
	addMethod takes e as e_method
		var eName as Entry
			e getName
		externalMethods += (1 internal declareMemberMethod{eName e})
		this addImports
			e getImportPackage
	addSubClass takes i as i_class
		internalSubClasses+=(1 |i|)
		i setIsSubClass :completeName true;
		var theirContext as context
			i getContext
		this addImports
			i getImportPackage
		theirContext setParentContext:context;
	addSubClass takes e as e_class
		var eName as Entry
			e getName
		var eAsFile as Entry
			e getAsFile
		externalSubClasses+=(1 internal declareMemberClass{eName eName eAsFile})
		this addImports
			e getImportPackage
		e setIsSubClass : completeName completeName true;
		var theirContext as context
			e getContext
		theirContext setParentContext:context;
		var nameBuilder
			new StringBuilder
		eName get
			nameBuilder
		clazz addDefinedClassName
			'nameBuilder
	addClass takes e as e_class
		var eName as Entry
			e getName
		var eAsFile as Entry
			e getAsFile
		externalSubClasses+=(1 internal declareMemberClass{eName eName eAsFile})
		this addImports
			e getImportPackage
		var nameBuilder
			new StringBuilder
		eName get
			nameBuilder
		clazz addDefinedClassName
			'nameBuilder
	setIsSubClass takes superCompleteName as Entry, newStatus as Boolean
		this setIsStatic
			newStatus
		set isSubClass
			newStatus
		completeName clear
		completeName += superCompleteName
		completeName += name
	output
			internal declareClass{packageName importPackage->INTERNAL asStatic classType name parent interfaces externalVariables externalMethods externalSubClasses internalVariables internalMethods internalSubClasses } if isSubClass is false
			(tabs internal declareSubClass{asStatic classType name parent interfaces externalVariables externalMethods externalSubClasses internalVariables internalMethods internalSubClasses }) if isSubClass is true
			+
			(tabs \"}") if isSubClass is true
		if context is null
			set tabs = 0
		else
			set tabs
				context getTab