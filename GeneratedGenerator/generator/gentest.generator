uses Listnames Tokens
import "generator/meta.generator"
import "generator/gentries.generator"
import "generator/check.generator"
import "generator/entryClass.generator"


generator
	
	constant DEFAULT_TOKEN
		"$token"
	constant NO_DEFAULT_TOKEN
		variable:;
	constant LOCAL_CONTEXT
		"$LOCAL"
	
	var truth
		true
	var directory as File
		null
	var classNames as Set<String>
		new HashSet<String>
	var generatorNames as List<String>
		new ArrayList<String>
	var contexts as Map<String,Map<String,Map<String,variable>>>
		new HashMap<String,Map<String,Map<String,variable>>>
	var methodParameters as Map<String,Map<String,List<type_listener>>>
		new HashMap<String,Map<String,List<type_listener>>>
	var elementBodies as Map<String,ListEntry>
		new HashMap<String,ListEntry>
	var constructorBodies as Map<String,ListEntry>
		new HashMap<String,ListEntry>
	var ifIndex
		0
	var generatorName
		""
	var new_method = \""
	elements from "generator/generator.elements"
	
	
	
	generate root
		set new_method
			static method NEW_METHOD
		
		var className
			"$"
		entry variableDeclarations "\n\t" = {}
		entry methodDeclarations "\n" = {}
		entry variableMethods "\n" = {}
		entry classElements "\n" = {
			variableDeclarations
			\""
			methodDeclarations
			variableMethods }
		
		var newContext
			new HashMap<String,Map<String,variable>>
		root to classElement
			className
				var genName
					'classElement
				set generatorName
					genName
				set className
					generator camelize
						genName
				classNames add
					className
				generatorNames add
					genName
				contexts put
					className
					newContext
				entry elementBody "" = {}
				entry constructorBody "" = {}
				elementBodies put
					className
					elementBody
				constructorBodies put
					className
					constructorBody
				methodParameters put
					className
					new HashMap<String,List<type_listener>>
				var varMap
					new HashMap<String,variable>
				varMap put
					DEFAULT_TOKEN
					variable: "root" "IToken" null; 
				newContext put
					LOCAL_CONTEXT
					varMap
				methodDeclarations add
					elementBodies get
						className
				methodDeclarations add
					constructor {\className constructorBody}
			
			auxillary_declaration
				methodDeclarations add
					generate auxillaryDeclaration: className LOCAL_CONTEXT true;
			
			variable_declaration
				var newVariable as variable
					generate variableDeclaration: className LOCAL_CONTEXT;
				newVariable setAccess
					static variable PRIVATE_ACCESS
				variableDeclarations add
					newVariable
				
				var variableName
					generator camelize
						newVariable getName
				var memberName
					newVariable getName
				entry type = type: newVariable;
				variableMethods add
					(1 getMethodDeclaration {type \variableName \memberName } )
			
			constant_declaration
				var newVariable as variable
					generate variableDeclaration: className LOCAL_CONTEXT;
				newVariable setAccess
					static variable PUBLIC_ACCESS
				newVariable setStatic
					true
				newVariable setFinal
					true
				variableDeclarations add
					newVariable
			element_declaration
				generate elementDeclaration: className LOCAL_CONTEXT;
			
			generation_declaration
				methodDeclarations add
					generate generationDeclaration: className LOCAL_CONTEXT;
		
		classElements add
			(1 getMethodDeclaration { \"String" \"Name" ``className`` } )
		
		if newContext does not containsKey "generateRoot"
			classElements add
				(1 methodDeclaration { \"void"  \"generateRoot" \"IToken root" {} } )
		
		if newContext does not containsKey "generate"
			classElements add
				(1 methodDeclaration {\"void" \"generate" \"ParseContext data" {} } )
			
		if newContext does not containsKey "setup"
			classElements add
				(1 methodDeclaration {\"void" \"setup" \"ParseContext context" {} } )
		
		var local_context as Map<String,variable>
			newContext get
				LOCAL_CONTEXT
		if local_context does not containsKey "lazyNameParser"
			classElements add
				(1 getMethodDeclaration { \"IParser" \"LazyNameParser" \"null" } )
		
		var javaClassName
			generator buildString
				className
				"Generator"
		var fileName
			generator buildString
				javaClassName
				".java"
		generator addFile
			directory
			fileName
			{\javaClassName \"Generator"}
		generator addEntry
			directory
			fileName
			"celements"
			{classElements}
	
	generate auxillaryDeclaration takes contextName, contextSubName, addSuper
		entry ret = null
		var methodName
			""
		entry parameters = {}
		entry body "" = {}
		entry type = type:;
		type setDefaultType
			"void"
		
		auxillaryDeclaration to auxillaryElement
			methodName
				var auxillaryName
					'auxillaryElement
				set methodName
					auxillaryName
				generator addContext
					contextName
					contextSubName
					methodName
					NO_DEFAULT_TOKEN
				
				set ret
					methodDeclaration { type \methodName parameters body }
				if addSuper is true and methodName is "setup"
					body add
						(2 semicoloned {method: \"this" "addPage" {} ;})
			
			parameter
				var var as variable
					generator getParameter
						auxillaryElement
						contextName
						contextSubName
						methodName
				parameters add
					var
			
			entry_declaration
				body add
					generate entryDeclaration: 2 contextName methodName;
			
			body_element
				body add
					generate bodyElement: 2 contextName methodName type;
		
		return
			ret
	
	generate elementDeclaration takes contextName, contextSubName
		if elementDeclaration->ELEMENT_IMPORT is not null
			set elementDeclaration = elementDeclaration->ELEMENT_IMPORT
		elementDeclaration to element
			element_definition
				var elementName = "NO_NAME"
				entry elementParameters = {}
				entry entryDef = null
				element to atom
					elementName
						set elementName = 'atom
					element_entry
						entry entryD "" = {}
						if entryDef is not null
							entryD += \"/*"
							entryD += entryDef
							entryD += \"*/"
							set entryDef = null
						entry entry "+\n\t\t\t" = {}
						atom to quark						
							entry
								entry += ``'quark``
						elementParameters += exactDuoCall { entryD entry }
					
					entry
						var entryName
							new StringBuilder
						var space = ""
						atom to quark
							NAME
								entryName append
									space
								entryName append
									'quark
								set space = " "
						var entryFinishedName
							entryName toString
						set entryDef = \entryFinishedName
				
				var constructorBody as ListEntry
					constructorBodies get
						contextName
				var elementBody as ListEntry
					elementBodies get
						contextName
				constructorBody += (2 semicoloned  { noSubjectCall { \"addElement" {``elementName`` exactDuoCall [elementName "Element"] }}})
				elementBody += (1 publicStaticFinalVariableDeclaration {
					\"Element"
					exactDuoCall [elementName "Element"]
					{ newObjectCall {\"Element" { ``elementName`` newStringListCall { elementParameters }}}}})
		return
			null
	
	generate generationDeclaration takes contextName, contextSubName
		entry ret = null
		var methodName = "generate"
		entry parameters = {}
		entry body "" = {}
		var undefined = false
		generationDeclaration to element
			tokenName
				var generateName = 'element
				set methodName
					generator buildString
						"generate"
						generator camelize
							generateName
				entry defaultToken = variable: generateName "IToken";
				generator addContext
					contextName
					contextSubName
					methodName
					defaultToken
				parameters += defaultToken
				var methodParameterList as Map<String,List<type_listener>>
					methodParameters get
						contextName
				if methodParameterList does not containsKey methodName
					var newList
						new ArrayList<type_listener>
					methodParameterList put
						methodName
						newList
					newList += defaultToken
					set undefined = true
				
				if generateName is "root"
					set ret = methodDeclaration {\"void" \methodName parameters body}
				else
					set ret = methodDeclaration {\"Entry" \methodName parameters body}
			
			parameter
				var parameter = 'element->takeName
				var variable as variable = null
				var type_unknown
					static type_listener TYPE_UNKNOWN 
				if undefined is true
					set variable = variable: parameter type_unknown;
					var methodParametersMap as Map<String,List<type_listener>>
						methodParameters get
							contextName
					var methodParametersList as List<type_listener>
						methodParametersMap get
							methodName
					methodParametersList += variable
				else
					if methodName is "generate"
						set variable = variable: parameter type_unknown;
					else				
						var methodParametersMap as Map<String,List<type_listener>>
							methodParameters get
								contextName
						var methodParametersList as List<type_listener>
							methodParametersMap get
								methodName
						var listener as type_listener
							methodParametersList get
								parameters size
						var type
							listener getType
						set variable = variable: parameter type;
						variable addListener
							listener
				var castToType
					generator getCastType
						element
						contextName
						contextSubName
				if castToType is not null
					variable changeType
						castToType
				parameters += variable
				var myContext as Map<String,Map<String,variable>>
					contexts get
						contextName
				if myContext does not containsKey methodName
					generator addContext
						contextName
						contextSubName
						methodName
						NO_DEFAULT_TOKEN
				var mySpecificContext as Map<String,variable>
					myContext get
						methodName
				mySpecificContext put
					parameter
					variable
			entry_declaration
				body +=
					generate entryDeclaration: 2 contextName methodName;
			body_element
				body +=
					generate bodyElement:2 contextName methodName null;
		
		if ret is null
			var thisContext as Map<String,Map<String,variable>>
					contexts get
						contextName
			if thisContext does not containsKey methodName
				generator addContext
					contextName
					contextSubName
					methodName
					NO_DEFAULT_TOKEN
			set ret = methodDeclaration {\"void" \methodName parameters body}
			var firstParameter as type_listener
				parameters get
					0
			firstParameter changeType
				"ParseContext"
		return
			ret
	
	
	generate entryDeclaration takes tabs, contextName, contextSubName
		var entryName = 'entryDeclaration->entryName
		var definition = entryDeclaration->entry_definition
		var retEntry as variable = null
		if definition is not null
			var assignment as method
				generator generateEntryDefinition
					definition
					contextName
					contextSubName
			var assignmentType
				assignment getType
			set retEntry = variable: entryName assignmentType assignment;
		else
			set retEntry = variable: entryName "Entry" \"null";
		
		contexts ->contextName ->contextSubName put
			entryName
			retEntry
		
		entry section "" = {(tabs |retEntry|)}
		var delimToken = entryDeclaration ->delimiter
		if delimToken is not null
			section+=(tabs semicoloned {method: \entryName "setDelimiter" {``'delimToken``};})
			retEntry changeType
				"ListEntry"
		return
			section
	
	
	generate bodyElement takes tabs, contextName, contextSubName, retType as type
		bodyElement to atom
			error_statement
				var errorStatement
					generate callErr: contextName contextSubName;
				return
					(tabs |errorStatement|)
			return_statement
				var returnStatement
					generate returnStatement: contextName contextSubName retType;
				return
					(tabs |returnStatement|)
			if_statement
				return
					generate ifStatement: tabs contextName contextSubName retType;				
			check_call
				return
					check generateCheckCheck
						atom
						tabs
						contextName
						contextSubName				
			each_call
				return
					generate eachCall: tabs contextName contextSubName retType;				
			token_declaration
				var variable as variable
					generate variableDeclaration: contextName contextSubName;
				variable changeType
					"IToken"
				return
					(tabs |variable|)
			variable_declaration
				var variableStatement
					generate variableDeclaration: contextName contextSubName;
				return
					(tabs |variableStatement|)
			set_call
				var setStatement
					generate setCall: contextName contextSubName;
				return
					(tabs |setStatement|)
			flip_switch
				return
					generate flipSwitch:tabs contextName contextSubName retType;
			token_expansion
				return
					generate tokenExpansion:tabs contextName contextSubName retType;
			inline_addition_call
				var inlineAdditionStatement
					generate inlineAddition: contextName contextSubName;
				return 
					(tabs semicoloned {|inlineAdditionStatement|})
			method_call
				var methodStatement
					generate methodCall:contextName contextSubName;
				return
					(tabs semicoloned {|methodStatement|})
		error
			"Method Parameter (004)"
			'bodyElement
	
	generate callErr takes contextName, contextSubName
		entry output "+" = {}
		callErr to element
			entry
				output += ``'element``
			variable_or_token_name
				output +=
					generate variableOrTokenName: contextName contextSubName;
		return
			errorCall {output}
	
	generate returnStatement takes contextName, contextSubName, retType as type
		entry parameters = {}
		entry ret = method:  "returnCall" parameters ;
		if retType is not null
			retType setSubject
				ret
		returnStatement to element
			generate_call
				var call as method
					generate methodCall: contextName contextSubName;
				parameters += call
				ret changeType
					call getType
			method_call			
				var call as method
					generate methodCall: contextName contextSubName;
				parameters += call
				ret changeType
					call getType
			boolean_statement
				parameters += 
					generate booleanStatement: contextName contextSubName;
				ret changeType
					"Boolean"
			entry_definition
				var entry as method
					generate entryDefinition:contextName contextSubName;
				parameters += entry
				ret changeType
					entry getType
			method_parameter
				var entry as method
					generate methodParameter:false contextName contextSubName;
				parameters += entry
				if entry does getIsNull
					ret setIsNull
						true
				else
					if entry does hasType
						ret changeType
							entry getType
					else
						entry addListener
							ret
		
		return
			ret
	
	generate eachCall takes tabs, contextName, contextSubName, retType as type
		var type_unknown
			static type_listener TYPE_UNKNOWN
		entry forComplete "" = {}
		var eachName
			'eachCall ->eachName
		entry variable = variable: eachName type_unknown;
		var iterableName = 'eachCall->iterable
		var iterable as variable = null
		if contexts ->contextName ->contextSubName does containsKey iterableName
			set iterable = contexts ->contextName ->contextSubName ->iterableName
			var iterableType
				iterable getType
			var indexOfAngle 
				iterableType indexOf
					"<"
			if indexOfAngle > -1
				var indexOfSecond
					iterableType indexOf
						","
				if indexOfSecond is -1
					set indexOfSecond
						iterableType lastIndexOf
							">"
				variable changeType
					iterableType substring
						indexOfAngle+1
						indexOfSecond
		else
			var myContext as Map<String,variable>
				contexts -> contextName -> contextSubName
			check context myContext containsKey iterableName
				Each (011):"+iterableName+" does not exist in context:"+contextName+":"+contextSubName+"
		
		set ifIndex = ifIndex+1
		var forName
			generator buildString
				contextSubName
				".for"
				'ifIndex
		generator addContext
			contextName
			contextSubName
			forName
			contexts ->contextName ->contextSubName ->DEFAULT_TOKEN
		contexts->contextName->forName put
			variable getName
			variable
		entry forBody "" = {}
		eachCall body_element to bodyElement
			forBody +=
				generate bodyElement:tabs+1 contextName forName retType;
		entry forStatement = forStatementCall {variable \iterableName forBody}
		forComplete += (tabs forStatement)
		forComplete += (tabs \"}")
		return
			forComplete
	
	generate ifStatement takes tabs, contextName, contextSubName, retType as type
		entry realIfPart "" = {}
		var ifPart = realIfPart
		entry ifBody "" = {}
		var elseBody as ListEntry = null
		set ifIndex = ifIndex+1
		var ifContextName
			generator buildString
				contextSubName
				".if"
				'ifIndex
		generator addContext
			contextName
			contextSubName
			ifContextName
			contexts->contextName->contextSubName->DEFAULT_TOKEN
		ifStatement to element
			boolean_statement
				ifPart += 
					generate booleanStatement: contextName contextSubName;
			body_element				
				ifBody += 
					generate bodyElement: tabs+1 contextName ifContextName retType;
			else_statement
				entry realElseBody "" = {}
				set elseBody = realElseBody 
				element to atom
					entry_declaration				
						elseBody +=
							generate entryDeclaration: tabs+1 contextName ifContextName;
					body_element
						elseBody += 
							generate bodyElement: tabs+1 contextName ifContextName retType;
		
		entry ret "" = {}
		ifPart += ifBody
		ret += (tabs ifStatementCall |ifPart|)
		ret += (tabs \"}")
		if elseBody is not null
			ret += (tabs elseStatementCall {elseBody})
			ret += (tabs \"}")
		return
			ret
	
	
	generate flipSwitch takes tabs, contextName, contextSubName, retType as type
		var varName = 'flipSwitch -> variable_names
		var myContext as Map<String,variable>
			contexts->contextName->contextSubName
		check context myContext containsKey varName
			(002) Context not found in "+contextName+":"+contextSubName+"
		entry left = null
		var first = true
		entry ret "" = {}
		flipSwitch to element
			left
				set left = equalsCall {\varName ``'element``}
			right
				entry right = setCall {\varName ``'element``}				
				entry ifPart = null
				if first is true
					set ifPart = ifStatementCall {left (tabs+1 right)}
				else
					set ifPart = elseIfStatementCall {left (tabs+1 right)}
				entry ifStatement "" = {(tabs ifPart) }
				ifStatement += (tabs \"}")
				ret += ifStatement
				set first = false
			else_statement
				entry body "" = {}
				element body_element to atom
					body +=
						generate bodyElement: tabs+1 contextName contextSubName retType;
				
				entry elseStatement "" = {(tabs elseStatementCall {body})}
				elseStatement += (tabs \"}")				
				ret += elseStatement
		return
			ret
	
	generate setCall takes contextName, contextSubName
		var varName = null
		var variable as variable = null
		var assignment as type_listener = null
		var typeName = null
		var cast = false
		setCall to element
			subject
				set varName = 'element
				if contexts->contextName->contextSubName does not containsKey varName
					var type_unknown
						static type_listener TYPE_UNKNOWN
					set variable = variable: varName type_unknown null;
					variable setDefined
						false
					contexts->contextName->contextSubName put
						varName
						variable
					check defined variable isDefined truth
						(003) variable "+varName+" was not defined in context "+contextName+":"+contextSubName+"
				else 
					set variable = contexts->contextName->contextSubName->varName
			
			boolean_statement
				set assignment as method
					generate booleanStatement: contextName contextSubName;
			method_call
				set assignment as method
					generate methodCall: contextName contextSubName;
			method_parameter
				set assignment as method
					generate methodParameter: false contextName contextSubName;
			castToType				
				set typeName
					generator getCastType
						setCall
						contextName
						contextSubName
				set cast = true
		if assignment does hasType
			variable changeType
				assignment getType
		else
			if variable does hasType
				assignment changeType
					variable getType
		
		var assignmentAsEntry as Entry
			assignment		
		if cast is true
			variable changeType
				typeName
			set assignmentAsEntry = method: "castCall" {\typeName assignmentAsEntry};
		return
			setCall {\varName assignmentAsEntry}
	
	generate inlineAddition takes contextName, contextSubName
		var lastSubjectToken
			inlineAddition->subject
		set lastSubjectToken
			lastSubjectToken getLast
		var subject as Entry
			generator generateMethodParameter
				lastSubjectToken
				false
				contextName
				contextSubName
		entry parameter = null
		token parameters
			inlineAddition->parameter
		parameters to element
			boolean_statement
				set parameter
					generate booleanStatement: contextName contextSubName;
			method_parameter
				set parameter
					generate methodParameter: false contextName contextSubName;
			method_call
				set parameter
					generate methodCall: contextName contextSubName;
		
		return
			method: subject "add" {parameter}; 
	
	generate tokenExpansion takes tabs, contextName, contextSubName, retType as type
		var tokenName = null
		tokenExpansion to element
			token_names
				set tokenName = 'element
				var myContext as Map<String,variable>
					contexts->contextName->contextSubName
				check context myContext containsKey tokenName
					(006) context:"+contextName+":"+contextSubName+" does not contain token "+tokenName+"
			getName
				entry ret = method: \tokenName "getName" {};
				ret changeType
					"String"
				return
					ret
			all_type_tokens
				var allTypeTokens = element
				var specificNameString = 'allTypeTokens->specificTokenName
				var camelizedSpecificName
					generator camelize
						specificNameString
				entry specificName = \camelizedSpecificName
				entry childName = \'allTypeTokens->tokenName
				var contextTokenSubName 
					generator buildString
						contextSubName
						"."
						'childName
				entry childToken = variable: 'childName "IToken";
				generator addContext
					contextName
					contextSubName
					contextTokenSubName
					childToken
				if specificNameString is not "*"
					var allNameString
						generator buildString
							'childName
							'specificName
					entry allName = \allNameString
					entry alls = variable: allNameString "List<IToken>" method: \tokenName "getAll" {``specificNameString``};;
					entry ret "" = {(tabs alls)}
					entry ifBody "" = {}
					entry forBody "" = {}
					token bodyToken
						element->body
					bodyToken to bones
						entry_declaration
							forBody +=
								generate entryDeclaration: tabs+2 contextName contextTokenSubName;
						body_element
							forBody +=
								generate bodyElement: tabs+2 contextName contextTokenSubName retType;
					
					ifBody += (tabs+1 forStatementCall { variablePrototype {\"IToken" childName} allName forBody})
					ifBody += (tabs+1 \"}")
					
					ret += (tabs ifStatementCall { operatorCall { allName \"!=" \"null" } ifBody})
					ret += (tabs \"}")
					return
						ret
				else
					entry ret "" = {}
					entry forBody "" = {}
					var childKeyNameString
						generator buildString
							'childName
							"Key"
					entry childKeyName = \childKeyNameString
					forBody += (tabs+1 variable: 'childName "IToken" method: \tokenName "get" {childKeyName};;)
					token bodyToken
						element->body
					bodyToken to bones
						entry_declaration
							forBody +=
								generate entryDeclaration: tabs+1 contextName contextTokenSubName;
						body_element
							forBody +=
								generate bodyElement: tabs+1 contextName contextTokenSubName retType;
					
					ret += (tabs tokenForStatementCall {childKeyName \tokenName forBody} )
					ret += (tabs \"}")
					return
						ret
			
			clause_type_tokens
				entry forBody "" = {}
				entry childName = null
				entry childKeyName = null
				entry childKeyNameGetName = null
				var childToken as variable = null
				var first = true
				var elseBody as ListEntry = null
				var contextTokenSubName = null
				element to clause
					tokenName
						set childName = \'clause
						var childKeyNameString
							generator buildString
								'childName
								"Key"
						set childKeyName = \childKeyNameString
						set childKeyNameGetName = method: childKeyName "getName" {};
						set contextTokenSubName 
							generator buildString
								contextSubName
								"."
								'childName
						
						set childToken = variable: 'childName "IToken" method: \tokenName "get" {childKeyName};;
						generator addContext
							contextName
							contextSubName
							contextTokenSubName
							childToken
					token_clause						
						var clauseNameString = 'clause->specificTokenName
						entry clauseName = null
						var isElse = false
						if clauseNameString is not "else"
							set clauseName = ``clauseNameString``
						else
							entry realElseBody "" = {}
							set elseBody = realElseBody
							set isElse = true
						entry clauseBody "" = {}
						token bodyToken
							clause->body
						if isElse is true and first is true
							clauseBody+=(tabs+1 childToken)
							bodyToken to bones
								entry_declaration
									clauseBody +=
										generate entryDeclaration: tabs+1 contextName contextTokenSubName;
								body_element
									clauseBody +=
										generate bodyElement: tabs+1 contextName contextTokenSubName retType;
							set elseBody = clauseBody
						else
							clauseBody += (tabs+2 childToken)
							bodyToken to bones
								entry_declaration
									clauseBody +=
										generate entryDeclaration: tabs+2 contextName contextTokenSubName;
								body_element
									clauseBody +=
										generate bodyElement: tabs+2 contextName contextTokenSubName retType;
							if isElse is true
								set elseBody = clauseBody
							else
								entry ifPart = null
								if first is true
									set ifPart = (tabs+1 ifStatementCall { method: clauseName "equals" {childKeyNameGetName}; clauseBody})
								else
									set ifPart = (tabs+1 elseIfStatementCall { method: clauseName "equals" {childKeyNameGetName}; clauseBody})
								entry clauseComplete "" = {ifPart}
								clauseComplete += (tabs+1 \"}")
								forBody += clauseComplete
						set first = false
				if elseBody is not null
					if forBody does isEmpty						
						forBody += elseBody
					else
						forBody += (tabs+1 elseStatementCall {elseBody})
						forBody += (tabs+1 \"}")
				
				entry forPart = tokenForStatementCall {childKeyName \tokenName forBody}
				entry forComplete "" = { (tabs forPart) }
				forComplete += (tabs \"}")
				return
					forComplete
		error tokenExpansion
			"Unable to generate Token Expansion (006)"			
	
	generate variableDeclaration takes contextName, contextSubName
		var varName = null
		var typeName
			static type_listener TYPE_UNKNOWN
		entry assignment = \"null"
		var cast = false
		variableDeclaration to element
			variableName
				set varName = 'element
			tokenName
				set varName = 'element				
			castToType				
				set typeName
					generator getCastType
						variableDeclaration
						contextName
						contextSubName
				set cast = true
			method_call
				var method as method
					generate methodCall: contextName contextSubName;
				set assignment = method
				if cast is false
					if method does hasType
						set typeName
							method getType
					else
						method changeType
							typeName
			method_parameter
				var parameter as method
					generate methodParameter: false contextName contextSubName;
				set assignment = parameter
				if cast is false
					if parameter does hasType
						set typeName
							parameter getType
					else
						parameter changeType
							typeName
			boolean_statement
				var bool as method 
					generate booleanStatement: contextName contextSubName;
				set assignment = bool
				set typeName = "Boolean"
		
		if contexts->contextName->contextSubName does containsKey varName
			var variable as variable = contexts->contextName->contextSubName->varName
			variable changeType
				typeName
			if cast is true
				variable setAssignment
					castCall {\typeName assignment}
			else
				variable setAssignment
					assignment
			
			return
				variable
		else
			if cast is true
				set assignment = castCall {\typeName assignment}
			entry variable = variable: varName typeName assignment;
			contexts->contextName->contextSubName put
				varName
				variable
			return
				variable
	
	generate methodCall takes contextName, contextSubName
		var isStatic
			methodCall->isStatic is not null
		var subject = methodCall -> subject
		var subjectAsMethodParameter = subject->method_parameter
		
		var subjectName as Entry = null
		var isGenerate = false
		var method_new
			static method NEW_METHOD
		if subjectAsMethodParameter is not null
			set subjectName
				generator generateMethodParameter
					subjectAsMethodParameter
					isStatic
					contextName
					contextSubName
		else
			var subName = 'subject
			set subjectName = \subName
			if subName is "generate"
				set isGenerate = true
			else
				if subName is "new"
					set subjectName
						static method NEW_METHOD
		var methodName = null
		if subjectName is method_new
			set methodName = "$constructorCall"
		else
			set methodName = 'methodCall->methodName
			if isGenerate is false and methodName is "single"
				set methodName = "getSingle"
		
		var theTrueMethod = null
		var undefined = false
		if isGenerate is true
			set theTrueMethod
				generator buildString
					"generate"
					generator camelize
						methodName
			if methodParameters->contextName does not containsKey theTrueMethod
				methodParameters->contextName put
					theTrueMethod
					new ArrayList<type_listener>
				set undefined = true
			else
				set undefined = false
		else
			set theTrueMethod = methodName
			methodParameters->contextName put
				theTrueMethod
				new ArrayList<type_listener>
			set undefined = true
		entry parameters = parameters: undefined contextName theTrueMethod;
		var ret as method = null
		if isGenerate is true
			var defaultToken as variable = contexts->contextName->contextSubName->DEFAULT_TOKEN
			var defaultTokenName
				defaultToken getName
			entry tokenParam = method: defaultTokenName;
			tokenParam changeType 
				"IToken"
			parameters += tokenParam
			set ret = method: "noSubjectCall" {\theTrueMethod parameters};
			ret changeType
				"Entry"
		else
			if isStatic is true
				set ret = method: "staticGetVariableCall" {subjectName \methodName parameters};
			else
				set ret = method: subjectName methodName parameters;
				if subjectName is method_new
					ret changeType
						methodName
				else
					if methodName is "getSingle"
						ret changeType
							"Entry"
		
		methodCall to element
			angle_braces
				generate inlineParameter: parameters contextName contextSubName;
			angle_class
				var entry as method
					generate angleClasses: contextName contextSubName;
				var entryType
					entry getType
				set ret = method: subjectName entryType parameters;
				ret changeType
					entryType
				return
					ret
			boolean_statement
				parameters +=
					generate booleanStatement: contextName contextSubName;
			method_parameter
				parameters +=
					generate methodParameter: false contextName contextSubName;
			method_call
				parameters +=
					generate methodCall: contextName contextSubName;
		if isStatic is true and parameters is not empty
			ret setElementName
				"staticMethodCall"
		else
			if methodCall->generator_names is not null
				entry realRet = method:"generatorMethodCall" {\'methodCall->generator_names ret};
				ret addListener
					realRet
				realRet changeType
					ret getType
				realRet setDefaultType
					ret getDefaultType
				set ret = realRet
		return
			ret
	
	generate inlineParameter takes parameters as parameters, contextName, contextSubName
		inlineParameter method_parameter to parameter
			parameters +=
				generate methodParameter: false contextName contextSubName;
		return
			null
	
	generate angleClasses takes contextName, contextSubName
		var typeName as StringBuilder
			new StringBuilder
		var comma = ""
		angleClasses to element
			class_names
				typeName append
					comma
				set comma = ","
				typeName append
					'element
			property_names
				typeName append
					comma
				set comma = ","
				typeName append
					generator buildString
						"I"
						generator camelize
							'element
			entry_class_names
				typeName append
					comma
				set comma = ","
				typeName append
					generator buildString
						generator camelize
							'element
						"Entry"
			braces
				var entry as method
					generate angleClasses:contextName contextSubName;
				typeName append
					"<"
				typeName append
					entry getType
				typeName append
					">"	
		
		entry ret = method: 'typeName;
		ret changeType
			'typeName
		return
			ret
	
	generate methodParameter takes isStatic, contextName, contextSubName
		methodParameter to element
			NULL
				entry param = method: 'element;
				param setIsNull
					true
				return
					param
			TRUE				
				entry param = method: "true";
				param changeType
					"Boolean"
				return
					param
			FALSE
				entry param = method: "false";
				param changeType
					"Boolean"
				return
					param
			NUMBER
				entry param = method: 'element;
				param changeType
					"Integer"
				return
					param
			generate_call
				return
					generate methodCall: contextName contextSubName;
			getKeyName
				var keyName
					generator buildString
						contexts->contextName->contextSubName->DEFAULT_TOKEN getName
						"Key"
				entry param = method: \keyName "getName" {};
				param changeType
					"String"
				return
					param
			entry_definition
				return
					generate entryDefinition: contextName contextSubName;
			entry_names
				var variableName = 'element
				entry param = method: variableName;
				var variable as variable = contexts->contextName->contextSubName->variableName
				if variable is null
					var type_unknown
						static type_listener TYPE_UNKNOWN
					set variable = variable: variableName type_unknown null;
					variable setDefined
						false
					contexts->contextName->contextSubName put
						variableName
						variable
					check defined variable isDefined truth
						(040) variable "+variableName+" is not defined in context "+contextName+":"+contextSubName+"
				
				set param = method: variableName;
				if variable does hasType
					param changeType
						variable getType
				else
					param addListener
						variable
				if methodParameter->getString is not null
					entry retEntry = method: param "getString" {};
					retEntry changeType
						"String"
					return
						retEntry
				else
					return
						param
			class_names
				var param as method = null
				var type
					generator camelize
						'element
				if isStatic is true
					set param = method: type;
				else
					entry method_new = \""
					set method_new
						static method NEW_METHOD
					set param = method: method_new type {};
				
				param changeType
					type
				return
					param
			generator_names
				var name = 'element
				entry param = method: "generatorCall" {\name};
				param changeType
					generator camelize
						generator buildString
							name
							"Generator"
				return
					param
			property_names
				var name
					generator buildString
						"I"
						generator camelize
							'element
				entry param = method: name;
				param changeType
					name
				return
					param
			entry_class_names
				var name 
					generator buildString
						generator camelize
							'element
						"Entry"
				entry param = method: name;
				param changeType
					name
				return
					param
			string
				var string
					generator buildString
						"\""
						'element
						"\""
				entry param = method: string;
				param changeType
					"String"
				return
					param
			variable_or_token_name
				return
					generate variableOrTokenName: contextName contextSubName;
		
		error methodParameter
			"(002) Method Parameter unable to generate!"
	
	generate variableOrTokenName takes contextName, contextSubName
		var isGetString
			variableOrTokenName -> getString is not null
		var ret as method = null
		var isToken = false
		variableOrTokenName to element
			token_names
				set ret = method: 'element;
				ret changeType
					"IToken"
				set isToken = true
			variable_names
				set ret = method: 'element;
			option
				element to atom
					NAME
						set ret = method: ret "get" {``'atom``};
					variable_names
						if isToken is true
							set ret = method: ret "get" {``'atom``};
						else
							set ret = method: ret "get" {\'atom};
				if isToken is true
					ret changeType
						"IToken"
			arithmatic
				set ret as method
					generate arithmatic: false contextName contextSubName;
		
		if isGetString is true
			var retType
				ret getType
			if retType is "IToken"
				set ret = method: ret "getString" {};
			else
				set ret = method: ret "toString" {};
			ret changeType 
				"String"
		return
			ret
	
	generate arithmatic takes mustBeNumber, contextName, contextSubName
		var ret as method = null
		arithmatic to element
			arithmatic
				var next as method
					generate arithmatic: mustBeNumber contextName contextSubName;
				if ret is null
					set ret = next
				else
					var entries as ListEntry
						ret getParameters
					entries += next
				if next does hasType
					ret changeType
						next getType
			operand
				if ret is not null
					ret changeType
						"Integer"
				set ret = method: "operatorCall" {ret \'element};
				set mustBeNumber = true
			variable_names
				var variableName = 'element
				var variable as variable
					contexts->contextName->contextSubName->variableName
				if variable is null
					var type_unknown
						static type_listener TYPE_UNKNOWN
					set variable = variable: variableName type_unknown null;
					variable setDefined
						false
					contexts->contextName->contextSubName put
						variableName
						variable
					check defined variable isDefined truth
						(004) Variable "+variableName+" is not defined in context:"+contextName+":"+contextSubName+"
				set ret = method: variableName;
				
				if variable does hasType
					ret changeType
						variable getType
				else
					ret addListener
						variable
				var variableType
					variable getType
				if variableType is "Integer"
					set mustBeNumber = true
			NUMBER
				var number = 'element
				set ret = method: number;
				set mustBeNumber = true
		
		if mustBeNumber is true
			ret changeType
				"Integer"
		return
			ret
	
	generate booleanStatement takes contextName, contextSubName
		var bool as method = null
		booleanStatement to element
			boolean_clause
				set bool as method
					generate booleanClause: contextName contextSubName;
			continuationStatement
				if 'element->continuationOperator is "and "
					set bool = method: "operatorCall" {bool \"&&"};
				else
					set bool = method: "operatorCall" {bool \"||"};
				
				var boolParameters as ListEntry
					bool getParameters
				token clause
					element->boolean_clause
				boolParameters +=
					generator generateBooleanClause: clause contextName contextSubName;
		set bool = method:"newBooleanCall" {bool};
		bool changeType: "Boolean";
		return
			bool
	
	generate booleanClause takes contextName, contextSubName
		var notStatement = booleanClause->notStatement
		if notStatement is not null
			var operand as method
				generator generateMethodParameter: notStatement->method_parameter false contextName contextSubName;
			operand changeType: "Boolean";
			return
				method: "exactDuoCall" {\"!" operand};
		else
			var containsToken = booleanClause->containsStatement
			if containsToken is not null
				entry operation = method:\'containsToken->token_names "containsKey" {``'containsToken->argument``};
				operation changeType: "Boolean";
				return
					operation
			else
				token statement
					booleanClause->operatedStatement
				var hasRight = true
				if statement is null
					set statement = booleanClause->methodWithNoArgument
					set hasRight = false
				var operatorState = -1
				var previousDefaultType = null
				var left as method
					generator generateMethodParameter
						statement->left->method_parameter
						false
						contextName
						contextSubName
				var operator = statement->operator
				var doesMethodName = null
				if operator->IS is not null
					if operator->NOT is not null						
						set operatorState = 1
					else
						set operatorState = 0
				else
					if operator->DOES is not null
						if operator->NOT is not null
							set operatorState = 4
						else
							set operatorState = 3
						set doesMethodName = 'operator->methodName
					else
						set operatorState = 2
				if hasRight is true
					token rightToken
						statement->right
					var right as method = null
					var isPrimitive = false
					rightToken to element
						method_parameter
							set right as method
								generate methodParameter: false contextName contextSubName;
							var leftType
								left getType
							var rightType
								right getType
							var leftNull
								left does getIsNull
							var rightNull
								right does getIsNull
							set isPrimitive
								leftType is "Integer" or leftType is "Boolean" or rightType is "Integer" or rightType is "Boolean" or leftNull is true or rightNull is true
							if operatorState is 2
								left changeType:"Integer";
								right changeType:"Integer";
								return
									method:"operatorCall" {left \'operator right};
							var leftHasType
								left hasType
							if operatorState <= 2
								if leftHasType is false and right does hasType
									left changeType
										right getType
								else
									if leftHasType is true and right does not hasType
										right changeType
											left getType
							if isPrimitive is true							
								if operatorState is 0
									return
										method: "operatorCall" {left \"==" right};
								else
									if operatorState is 1
										return
											method: "operatorCall" {left \"!=" right};
							else
								if operatorState is 0
									return
										method:"equalsCall" {left right};
								if operatorState is 1
									return
										method:"notEqualsCall" {left right};
								if operatorState is 3
									return
										method: left doesMethodName {right};
								if operatorState is 4
									return 
										method: "exactDuoCall" {\"!" method:left doesMethodName {right};};
						SINGULAR
							if operatorState is 0
								return
									method: left "isSingular" {};
							if operatorState is 1
								return
									method: "exactDuoCall" {\"!" method: left "isSingular" {};};
						EMPTY
							if operatorState is 0
								return
									method: left "isEmpty" {};
							if operatorState is 1
								return
									method:"exactDuoCall" {\"!" method:left "isEmpty" {};};
				else
					if operatorState is 3
						return
							method: left doesMethodName {};
					if operatorState is 4
						return
							method: "exactDuoCall" {\"!" method: left doesMethodName {};};
		error booleanClause
			"(009)"
	
	generate entryDefinition takes contextName, contextSubName
		if entryDefinition->generate_call is not null
			return
				generator generateMethodCall
					entryDefinition->generate_call
					contextName
					contextSubName
		var getSingle = entryDefinition->getSingle
		if getSingle is not null
			var entryName = 'getSingle
			if contexts->contextName->contextSubName does not containsKey entryName
				entry newEntry = variable:entryName "Entry";
				newEntry setDefined: false;
				contexts->contextName->contextSubName put: entryName newEntry;
			var entryType
				contexts->contextName->contextSubName->entryName getType
			if entryType does contains "Entry"
				contexts->contextName->contextSubName->entryName changeType: "Entry";
			entry def = method:\entryName "getSingle" {};
			def changeType: "Entry";
			return
				def
		token quoteEntry
			entryDefinition->quoted
		if quoteEntry is not null
			var ret as method = null
			quoteEntry to element
				entry
					set ret = method:new_method "QuoteEntry" {``'element``};
				variable_or_token_name
					set ret = method:new_method "QuoteEntry" { generate variableOrTokenName: contextName contextSubName; };
			ret changeType: "QuoteEntry";
			return
				ret
		token stringEntry
			entryDefinition->string
		if stringEntry is not null
			var ret as method = null
			stringEntry to choice
				entry
					set ret = method: new_method "StringEntry" {``'choice``};
				variable_or_token_name
					set ret = method: new_method "StringEntry" { generate variableOrTokenName: contextName contextSubName;};
			ret changeType:"StringEntry";
			return
				ret
		
		var elementNameToken = entryDefinition->element_names
		var isVariableName = false
		if elementNameToken is null
			set elementNameToken = entryDefinition->variable_names
			set isVariableName = true
		var listEntryToken = entryDefinition->list_entry_definition
		entry listEntry = null
		var ret as method = null
		if listEntryToken is not null
			set listEntry = generate listEntryDefinition: contextName contextSubName;
		if elementNameToken is null
			if listEntryToken is null
				var entryClassName = entryDefinition->entry_class_names
				if entryClassName is not null
					entry parameters = {}
					entryDefinition method_parameter to methodParameter
						parameters += generate methodParameter:false contextName contextSubName;
					var className
						generator buildString
							generator camelize
								'entryClassName
							"Entry"
					set ret = method:new_method className parameters;
					ret changeType: className;
					return
						ret
				else
					var tabBrace = entryDefinition->tab_braces
					var arithmatic = tabBrace->arithmatic
					var entryDefinitionToken = tabBrace->entry_definition
					var arithmaticEntry
						generator generateArithmatic
							arithmatic
							false
							contextName
							contextSubName
					if entryDefinitionToken is not null
						var entryDefinitionEntry
							generator generateEntryDefinition
								entryDefinitionToken
								contextName
								contextSubName
						set ret = method: new_method "TabEntry" { |arithmaticEntry| method:new_method "ListEntry" { |entryDefinitionEntry| };};
					else
						set ret = method: new_method "TabEntry" { |arithmaticEntry| method:new_method "ListEntry" {\'tabBrace->entry_names};};
			else
				return
					listEntry
		else
			token specificGenerator
				entryDefinition->gen
			entry specificGeneratorName = null
			if isVariableName is true
				if specificGenerator is not null
					set specificGeneratorName = \'specificGenerator
				else
					set specificGeneratorName = \generatorName
				set ret =  method:new_method "ElementEntry" { generatorElementWithVariable {specificGeneratorName \'elementNameToken } {listEntry}};
			else
				if specificGenerator is not null
					var specificGeneratorClassName
						generator camelize
							'specificGenerator
					set specificGeneratorName = \specificGeneratorClassName
				else
					set specificGeneratorName = \contextName
				set ret =  method:new_method "ElementEntry" { generatorElement { specificGeneratorName \'elementNameToken } {listEntry}};
		
		ret changeType: "Entry";
		return
			ret
	
	generate listEntryDefinition takes contextName, contextSubName
		listEntryDefinition to element
			list
				entry ret = {}
				element to atom
					entry_definition
						ret += generate entryDefinition: contextName contextSubName;
					generate_call
						ret+=generate MethodCall: contextName contextSubName;
					variable_names
						var varName = 'atom
						var variable as variable
							generator getVariable:varName contextName contextSubName "Entry" "List Entry Definition(006)";
						var varType
							variable getType
						if varType does not contains "Entry"
							variable changeType:"Entry";
						ret+= method:varName;
					entry_names
						var entryName = 'atom
						
						var variable as variable
							generator getVariable:entryName contextName contextSubName "Entry" "List Entry Definition(007)";
						var varType
							variable getType
						if varType does not contains "Entry"
							variable changeType:"Entry";
						ret+=method:entryName;
				entry new_method = \""
				entry retEntry = method:new_method "ListEntry" ret;
				retEntry changeType:"ListEntry";
				return
					retEntry
			string				
				entry ret = {}
				element to atom
					entry
						ret += method:new_method "StringEntry" {``'atom``};
					quoted
						atom to quark
							entry
								ret += method:new_method "QuoteEntry" {``'quark``};
							variable_or_token_name
								ret += method:new_method "QuoteEntry" {generate variableOrTokenName: contextName contextSubName;};
					else
						ret += method:new_method "StringEntry" { generate variableOrTokenName: contextName contextSubName;};
				entry retEntry = method:new_method "ListEntry" ret;
				retEntry changeType:"ListEntry";
				return
					retEntry
			exact_variable
				var variableName = 'element->variable_names
				var variable as variable
					generator getVariable
						variableName
						contextName
						contextSubName
						"ListEntry"
						"ListEntryDefinition (020)"				
				variable changeType:"ListEntry";
				entry ret = method:variableName;
				ret changeType
					"ListEntry"
				return
					ret
		error listEntryDefinition
			"(003)"
	
	aux addContext takes contextName, contextSubName, newContextName, newDefaultEntry as variable
		if contexts does not containsKey contextName
			contexts put
				contextName
				new HashMap<String,Map<String,variable>>
			methodParameters put
				contextName
				new HashMap<String,List<type_listener>>
		var context as Map<String,variable>
			new HashMap<String,variable>
		contexts->contextName put
			newContextName
			context
		if contextSubName is not null
			var iterableContext as Set<String>
				contexts->contextName->contextSubname keySet
			each varName in iterableContext
				context put
					varName
					contexts->contextName->contextSubName->varName
		context put
			DEFAULT_TOKEN
			newDefaultEntry
		context put
			newDefaultEntry getName
			newDefaultEntry
		if contextSubName is not null
			var previousDefault as variable
				contexts->contextName->contextSubName->DEFAULT_TOKEN
			context put
				previousDefault getName
				previousDefault
	
	aux getCastType takes castToken as IToken, contextName, contextSubName 
		token castToType
			castToken->castToType
		if castToType is not null		
			var ret as method
				generator generateAngleClasses
					castToType
					contextName
					contextSubName
			return
				ret getType
		return
			null
	
	aux getParameter takes parameter as IToken, contextName, contextSubName, methodName
		var parameterName = 'parameter->takeName
		var type_unknown
			static type_listener TYPE_UNKNOWN
		entry variable = variable:parameterName type_unknown;
		var castType
			generator getCastType:parameter contextName contextSubName;
		if castType is not null
			variable changeType:castType;
		contexts->contextName->methodName put:parameterName variable;
		return
			variable
	
	aux getVariable takes variableName, contextName, contextSubName, defaultType, errorIfUndefined
		var ret as variable = null
		if contexts->contextName->contextSubName does not containsKey variableName
			if contexts->contextName->LOCAL_CONTEXT does containsKey variableName
				set ret = contexts->contextName->LOCAL_CONTEXT->variableName
				return
					ret
			entry variable = variable:variableName defaultType;
			variable setDefined:false;
			contexts->contextName->contextSubName put
				variableName
				variable
			check defined variable defined truth
				"+errorIfUndefined+"
		set ret = contexts->contextName->contextSubName->variableName
		return
			ret
	
	
	public void setup(ParseContext data) {
		NO_DEFAULT_TOKEN = new VariableEntry("$NO_DEFAULT","IToken",null);
		file = data.getFile();
		String fileName = data.getFileName();
		int indexOfDot = fileName.lastIndexOf('.');
		if(indexOfDot>-1)fileName = fileName.substring(0, indexOfDot);
		directory = new File("../Generated"+camelize(fileName)+"/src/gen/");
		directory.mkdirs();

		System.out.println(directory.getAbsolutePath());
	}

	public void generate(ParseContext data){
		generateAll(data.getList("class_definitions").getNewTokens(),"class_dec");

		addFile(directory,"Generators.java",new ListEntry(new StringEntry("Generators"),new StringEntry("Object")));
		ListEntry genNames = new ListEntry();
		genNames.setDelimiter("\n\tpublic static final ");
		genNames.startWithDelimiter(true);
		ListEntry genList = new ListEntry();
		IToken metaTokens = data.getList("meta_declarations").getNewTokens();

		if(metaTokens!=null){
			for(IToken.Key metaToken:metaTokens.keySet()){
				String pureName = metaTokens.get(metaToken).get("metaName").getString();
				String metaName = camelize(pureName)+"Flow";
				addFile(directory,metaName+".java",new ListEntry(new StringEntry(metaName),new StringEntry("FlowController")));
				addEntry(directory,metaName+".java","meta",new ListEntry(generateMeta(metaTokens.get(metaToken))));			

			}
		}
		for(String className:generatorNames){
			StringEntry generatorName = new StringEntry(camelize(className));
			genNames.add(new ElementEntry(Generators.generator,"generatorDeclaration",new ListEntry(generatorName,new StringEntry(className),generatorName)));
			genList.add(className);			
		}
		ListEntry entry = new ListEntry(genNames,new ElementEntry(Generators.generator,"generatorListDeclaration",new ListEntry(genList)));
		entry.setDelimiter("\n\tpublic static final ");
		addEntry(getName(),directory,"Generators.java","generators",entry);
	}


	public Entry generateMeta(IToken metaToken){
		String metaName = metaToken.get("metaName").getString();
		Entry mainCall = new ElementEntry(Generators.generator,"flowMain",new ListEntry(new StringEntry(camelize(metaName))));
		ListEntry variableDeclarations = new ListEntry();
		variableDeclarations.setDelimiter("\n\tprivate ");
		variableDeclarations.startWithDelimiter(true);
		ListEntry methodDeclarations = new ListEntry();
		methodDeclarations.setDelimiter("");
		ListEntry generateDeclaration = new ListEntry();
		generateDeclaration.setDelimiter("");
		ListEntry ret = new ListEntry(
				mainCall,
				variableDeclarations,generateDeclaration,methodDeclarations);
		ret.setDelimiter("\n");
		addContext(metaName,null,LOCAL_CONTEXT,NO_DEFAULT_TOKEN);
		for(IToken.Key key:metaToken.keySet()){
			if("variable_declaration".equals(key.getName())){
				VariableEntry var = (VariableEntry) generateVariableDeclaration(metaToken.get(key),metaName,LOCAL_CONTEXT);
				variableDeclarations.add(var);
				TypeEntry type = new TypeEntry(var);
				methodDeclarations.add(new TabEntry(0,new ElementEntry(this,"methodDeclaration",
						new ListEntry(type,new StringEntry("get"+camelize(var.getName())),new ListEntry(),
								new TabEntry(2,new ElementEntry(this,"returnCall",new ListEntry(new StringEntry(var.getName()))))))));
			}
			else if("meta_method_declaration".equals(key.getName())){

				String methodName = metaToken.get(key).get("methodName").getString();
				addContext(metaName,LOCAL_CONTEXT,methodName,NO_DEFAULT_TOKEN);
				ListEntry parameters = new ListEntry();

				ListEntry body = new ListEntry();
				body.setDelimiter("");
				for(IToken.Key paramKey: metaToken.get(key).keySet()){
					if("parameter".equals(paramKey.getName())){
						VariableEntry param = getParameter(metaToken.get(key).get(paramKey),metaName,LOCAL_CONTEXT,methodName);
						if("generate".equals(methodName)){
							param.changeType("ParseContext");
						}
						parameters.add(param);
					}
					else if("entry_declaration".equals(paramKey.getName())){
						body.add(generateEntryDeclaration(metaToken.get(key).get(paramKey),2,metaName,methodName));
					}
					else if("body_element".equals(paramKey.getName())){
						body.add(generateBodyElement(metaToken.get(key).get(paramKey),2,metaName,methodName,null));
					}
				}
				methodDeclarations.add(new TabEntry(0,new ElementEntry(this,"methodDeclaration",
						new ListEntry(new StringEntry("void"),new StringEntry(methodName),new ListEntry(parameters),
								body))));
			}
		}

		if(!contexts.get(metaName).containsKey("assignListElementNames")){
			//methodDeclarations.add(new TabEntry(0,new ElementEntry(Generators.generator,"methodDeclaration",new ListEntry(new StringEntry("void"),new StringEntry("assignListElementNames"),new StringEntry("ParseContext data, IToken rootToken"),new ListEntry()))));
		}		
		if(!contexts.get(metaName).containsKey("setup")){
			methodDeclarations.add(new TabEntry(0,new ElementEntry(Generators.generator,"methodDeclaration",new ListEntry(new StringEntry("void"),new StringEntry("setup"),new StringEntry("ParseContext context"),new ListEntry()))));
		}
		methodDeclarations.add(new TabEntry(0,new ElementEntry(this,"methodDeclaration",
				new ListEntry(new StringEntry("Generator[]"),new StringEntry("getGenerators"),new ListEntry(),
						new TabEntry(2,new ElementEntry(this,"returnCall",new ListEntry(new StringEntry("Generators._"))))))));
		return ret;
	}