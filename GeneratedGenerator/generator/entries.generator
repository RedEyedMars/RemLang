
entry variable uses type_listener
	constant DEFAULT_ACCESS
		0
	constant PUBLIC_ACCESS
		1
	constant PRIVATE_ACCESS
		2	
	var name
		null
	entry assignment = null
	var defined
		true
	var isFinal
		false
	var isStatic
		false
	var access
		DEFAULT_ACCESS
	var showType
		true
	setAccess takes newAccess
		set access
			newAccess
		set assignment as Entry = {}
	setDefined takes isDefined
		set defined
			isDefined
	setStatic takes newStatic
		set isStatic
			newStatic
	setFinal takes newFinal
		set isFinal
			newFinal
	isDefined takes checkCase
		return
			defined is checkCase
	constructor
		set name
			"null"
	constructor takes initialName
		set name
			initialName		
		set assignment
			null
		set showType
			false
	constructor takes initialName, initialType
		set name
			initialName
		this changeType
			initialType
		set assignment
			null
	constructor takes initialName, initialType, newAssignment
		set name
			initialName
		this changeType
			initialType
		set assignment
			newAssignment
	
	setAssignment takes newAssignment
		set assignment
			newAssignment
	output
			[name] if assignment is null and showType is false
			+
			["private "] if access is PRIVATE_ACCESS and showType is true
			["public "] if access is PUBLIC_ACCESS and showType is true
			+
			["static "] if isStatic is true and showType is true
			+
			["final "] if isFinal is true and showType is true
			+
			generator typeAndName [type name] if assignment is null and showType is true
			generator variableDeclaration {[type] [name] assignment} if showType is true
		if type is "$UNKNOWN"
			this changeType
				defaultType

entry parameters
	var undefined
		false
	var contextName
		null
	var contextSubName
		null
	entry listEntry = {}
	constructor takes initialUndefined, initialContextName, initialContextSubName
		set undefined = initialUndefined
		set contextName = initialContextName
		set contextSubName = initialContextSubName
	
	isEmpty
		return
			listEntry is empty
	
	add takes entry as Entry
		var methodParameters as Map<String,Map<String,List<type_listener>>>
			generator getMethodParameters
		var listener_entry as type_listener
			entry
		if undefined is true
			methodParameters->contextName->contextSubName += listener_entry
		else
			var listSize as Integer
				listEntry size
			if methodParameters->contextName->contextSubName->listSize does not hasType
				methodParameters->contextName->contextSubName->listSize changeType
					listener_entry getType
		var result as Boolean
			listEntry add
				entry
		return
			result
	
	output
			listEntry if listEntry is not null

entry type
	var subject as type_listener
		null
	var defaultType
		"void"
	setSubject takes newSubject
		set subject
			newSubject
	setDefaultType takes newDefaultType
		set defaultType
			newDefaultType
	
	constructor takes initialSubject
		set subject
			initialSubject
	
	constructor
		set subject
			null
	
	output
			[defaultType] if subject is null
			get_type: subject; otherwise

entry get_type
	var type
		""
	constructor takes subject as type_listener
		var hasType
			subject hasType
		if hasType is true
			set type
				subject getType
		else
			set type
				subject getDefaultType
	
	output
			[type] if type is not null


entry method uses type_listener
	constant NEW_METHOD
		\"new"
	var subject
		null
	var methodName
		"$NO_METHOD_NAME"
	var parameters
		{}
	var isNull
		false
	var elementName
		null
	setIsNull takes b
		set isNull
			b
	setMethodNames takes newName
		set methodName
			newName
	setElementName takes newName
		set elementName
			newName
	constructor takes
			initialElementName
			initialParameters as ListEntry
		set elementName
			initialElementName
		set parameters
			initialParameters	
	constructor takes
			initialMethodName
		set methodName
			initialMethodName	
	constructor takes
			initialSubject as Entry
			initialMethodName
			initialParameters as ListEntry
		set methodName
			initialMethodName
		set subject
			initialSubject
		set parameters
			initialParameters
	
	constructor takes
			initialSubject as Entry
			initialMethodName
			initialParameters as parameters
		set methodName
			initialMethodName
		set subject
			initialSubject
		set parameters
			initialParameters getListEntry
	
	output
			generator elementName |parameters| if elementName is not null
			generator exactCall { [methodName] } if subject is null
			generator newObjectCall { [methodName] { parameters } } if NEW_METHOD is subject
			generator methodCall {subject [methodName] { parameters } } otherwise
		if type is "$UNKNOWN"
			this changeType
				defaultType


property type_listener
	constant TYPE_UNKNOWN	
		"$UNKNOWN"
	var type
		static type_listener TYPE_UNKNOWN
	var defaultType
		"String"
	var listeners as List<type_listener>
		null		
	setDefaultType takes newDefaultType
		if listeners is not null
			each listener in listeners
				listener setDefaultType
					newDefaultType
		set defaultType
			newDefaultType
	addListener takes listener as type_listener
		if listeners is null
			set listeners
				new ArrayList<type_listener>
		listeners add
			listener
	changeType takes newType
		if listeners is not null
			each listener in listeners
				listener changeType
					newType
		set type
			newType
	hasType
		return
			type is "$UNKNOWN"
